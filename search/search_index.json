{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"aioswitcher documentation","text":""},{"location":"codedocs/","title":"Code documentation","text":"<p>Switcher integration main module.</p> <p>Switcher integration TCP socket API module.</p> <p>Switcher integration TCP socket API messages.</p> <p>Switcher integration API remote related classes and functions.</p> <p>Switcher integration, UDP Bridge module.</p> <p>Switcher integration device module.</p> <p>Switcher integration device module tools.</p> <p>Switcher integration schedule module.</p> <p>Switcher integration schedule parser module.</p> <p>Switcher integration schedule module tools.</p>"},{"location":"codedocs/#src.aioswitcher.api.Command","title":"<code>Command</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum for turning the device on or off.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>@unique\nclass Command(Enum):\n\"\"\"Enum for turning the device on or off.\"\"\"\n\n    ON = \"1\"\n    OFF = \"0\"\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi","title":"<code>SwitcherApi</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Switcher TCP based API.</p> <p>Parameters:</p> Name Type Description Default <code>ip_address</code> <code>str</code> <p>the ip address assigned to the device.</p> required <code>device_id</code> <code>str</code> <p>the id of the desired device.</p> required <code>port</code> <code>int</code> <p>the port of the device, default is 9957.</p> <code>SWITCHER_TCP_PORT_TYPE1</code> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>class SwitcherApi(ABC):\n\"\"\"Switcher TCP based API.\n\n    Args:\n        ip_address: the ip address assigned to the device.\n        device_id: the id of the desired device.\n        port: the port of the device, default is 9957.\n\n    \"\"\"\n\n    def __init__(\n        self, ip_address: str, device_id: str, port: int = SWITCHER_TCP_PORT_TYPE1\n    ) -&gt; None:\n\"\"\"Initialize the Switcher TCP connection API.\"\"\"\n        self._ip_address = ip_address\n        self._device_id = device_id\n        self._port = port\n        self._connected = False\n\n    @property\n    def connected(self) -&gt; bool:\n\"\"\"Return true if api is connected.\"\"\"\n        return self._connected\n\n    async def __aenter__(self) -&gt; \"SwitcherApi\":\n\"\"\"Enter SwitcherApi asynchronous context manager.\n\n        Returns:\n            This instance of ``aioswitcher.api.SwitcherApi``.\n\n        \"\"\"\n        await self.connect()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n\"\"\"Exit SwitcherApi asynchronous context manager.\"\"\"\n        await self.disconnect()\n\n    async def connect(self) -&gt; None:\n\"\"\"Connect to asynchronous socket and get reader and writer object.\"\"\"\n        logger.info(\"connecting to the switcher device\")\n        self._reader, self._writer = await open_connection(\n            host=self._ip_address,\n            port=self._port,\n            family=AF_INET,\n        )\n\n        self._connected = True\n        logger.info(\"switcher device connected\")\n\n    async def disconnect(self) -&gt; None:\n\"\"\"Disconnect from asynchronous socket.\"\"\"\n        if hasattr(self, \"_writer\") and self._writer:\n            logger.info(\"disconnecting from the switcher device\")\n            self._writer.close()\n            await self._writer.wait_closed()\n        else:\n            logger.info(\"switcher device not connected\")\n        self._connected = False\n\n    async def _login(\n        self, device_type: Union[DeviceType, None] = None\n    ) -&gt; Tuple[str, SwitcherLoginResponse]:\n\"\"\"Use for sending the login packet to the device.\n\n        Returns:\n            A tuple of the hex timestamp and an instance of ``SwitcherLoginResponse``.\n\n        Note:\n            This is a private function used by other functions, do not call this\n            function directly.\n\n        \"\"\"\n        timestamp = current_timestamp_to_hexadecimal()\n        if (\n            device_type\n            and device_type == DeviceType.BREEZE\n            or device_type == DeviceType.RUNNER\n            or device_type == DeviceType.RUNNER_MINI\n        ):\n            packet = packets.LOGIN2_PACKET_TYPE2.format(timestamp, self._device_id)\n        else:\n            packet = packets.LOGIN_PACKET_TYPE1.format(timestamp)\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a login packet\")\n        self._writer.write(unhexlify(signed_packet))\n        response = await self._reader.read(1024)\n        return timestamp, SwitcherLoginResponse(response)\n\n    async def stop(self) -&gt; SwitcherBaseResponse:\n\"\"\"Use for stopping the shutter.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n        \"\"\"\n        logger.debug(\"about to send stop shutter command\")\n        timestamp, login_resp = await self._login(DeviceType.RUNNER)\n        if not login_resp.successful:\n            logger.error(\"Failed to log into device with id %s\", self._device_id)\n            raise RuntimeError(\"login request was not successful\")\n\n        logger.debug(\n            \"logged in session_id=%s, timestamp=%s\", login_resp.session_id, timestamp\n        )\n\n        packet = packets.RUNNER_STOP_COMMAND.format(\n            login_resp.session_id, timestamp, self._device_id\n        )\n\n        packet = set_message_length(packet)\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a stop control packet\")\n\n        self._writer.write(unhexlify(signed_packet))\n        response = await self._reader.read(1024)\n        return SwitcherBaseResponse(response)\n\n    async def get_state(self) -&gt; SwitcherStateResponse:\n\"\"\"Use for sending the get state packet to the device.\n\n        Returns:\n            An instance of ``SwitcherStateResponse``.\n        \"\"\"\n        raise NotImplementedError\n\n    async def get_breeze_state(self) -&gt; SwitcherThermostatStateResponse:\n\"\"\"Use for sending the get state packet to the Breeze device.\n\n        Returns:\n            An instance of ``SwitcherThermostatStateResponse``.\n\n        \"\"\"\n        raise NotImplementedError\n\n    async def control_device(\n        self, command: Command, minutes: int = 0\n    ) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the control packet to the device.\n\n        Args:\n            command: use the ``aioswitcher.api.Command`` enum.\n            minutes: if turning-on optionally incorporate a timer.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        raise NotImplementedError\n\n    async def control_breeze_device(\n        self,\n        remote: SwitcherBreezeRemote,\n        state: Union[DeviceState, None] = None,\n        mode: Union[ThermostatMode, None] = None,\n        target_temp: int = 0,\n        fan_level: Union[ThermostatFanLevel, None] = None,\n        swing: Union[ThermostatSwing, None] = None,\n        update_state: bool = False,\n    ) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the control packet to the Breeze device.\n\n        Args:\n            remote: the remote for the breeze device\n            state: the desired state of the device\n            mode: the desired mode of the device\n            target_temp: the target temperature\n            fan_level: the desired fan level\n            swing: the desired swing state\n            update_state: update the device state without controlling the device\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        raise NotImplementedError\n\n    async def set_position(self, position: int = 0) -&gt; SwitcherBaseResponse:\n\"\"\"Use for setting the shutter position of the Runner and Runner Mini devices.\n\n        Args:\n            position: the position to set the device to, default to 0.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        raise NotImplementedError\n\n    async def set_device_name(self, name: str) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the set name packet to the device.\n\n        Args:\n            name: string name with the length of 2 &gt;= x &gt;= 32.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        raise NotImplementedError\n\n    async def set_auto_shutdown(self, full_time: timedelta) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the set auto-off packet to the device.\n\n        Args:\n            full_time: timedelta value containing the configuration value for\n                auto-shutdown.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        raise NotImplementedError\n\n    async def get_schedules(self) -&gt; SwitcherGetSchedulesResponse:\n\"\"\"Use for retrieval of the schedules from the device.\n\n        Returns:\n            An instance of ``SwitcherGetSchedulesResponse``.\n\n        \"\"\"\n        raise NotImplementedError\n\n    async def delete_schedule(self, schedule_id: str) -&gt; SwitcherBaseResponse:\n\"\"\"Use for deleting a schedule from the device.\n\n        Use ``get_schedules`` to retrieve the schedule instance.\n\n        Args:\n            schedule_id: the identification of the schedule for deletion.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        raise NotImplementedError\n\n    async def create_schedule(\n        self, start_time: str, end_time: str, days: Set[Days] = set()\n    ) -&gt; SwitcherBaseResponse:\n\"\"\"Use for creating a new schedule in the next empty schedule slot.\n\n        Args:\n            start_time: a string start time in %H:%M format. e.g. 13:00.\n            end_time: a string start time in %H:%M format. e.g. 13:00.\n            days: for recurring schedules, add ``Days``.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.connected","title":"<code>connected: bool</code>  <code>property</code>","text":"<p>Return true if api is connected.</p>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enter SwitcherApi asynchronous context manager.</p> <p>Returns:</p> Type Description <code>SwitcherApi</code> <p>This instance of <code>aioswitcher.api.SwitcherApi</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def __aenter__(self) -&gt; \"SwitcherApi\":\n\"\"\"Enter SwitcherApi asynchronous context manager.\n\n    Returns:\n        This instance of ``aioswitcher.api.SwitcherApi``.\n\n    \"\"\"\n    await self.connect()\n    return self\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.__aexit__","title":"<code>__aexit__(exc_type, exc_value, traceback)</code>  <code>async</code>","text":"<p>Exit SwitcherApi asynchronous context manager.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: Optional[Type[BaseException]],\n    exc_value: Optional[BaseException],\n    traceback: Optional[TracebackType],\n) -&gt; None:\n\"\"\"Exit SwitcherApi asynchronous context manager.\"\"\"\n    await self.disconnect()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.__init__","title":"<code>__init__(ip_address, device_id, port=SWITCHER_TCP_PORT_TYPE1)</code>","text":"<p>Initialize the Switcher TCP connection API.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>def __init__(\n    self, ip_address: str, device_id: str, port: int = SWITCHER_TCP_PORT_TYPE1\n) -&gt; None:\n\"\"\"Initialize the Switcher TCP connection API.\"\"\"\n    self._ip_address = ip_address\n    self._device_id = device_id\n    self._port = port\n    self._connected = False\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Connect to asynchronous socket and get reader and writer object.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def connect(self) -&gt; None:\n\"\"\"Connect to asynchronous socket and get reader and writer object.\"\"\"\n    logger.info(\"connecting to the switcher device\")\n    self._reader, self._writer = await open_connection(\n        host=self._ip_address,\n        port=self._port,\n        family=AF_INET,\n    )\n\n    self._connected = True\n    logger.info(\"switcher device connected\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.control_breeze_device","title":"<code>control_breeze_device(remote, state=None, mode=None, target_temp=0, fan_level=None, swing=None, update_state=False)</code>  <code>async</code>","text":"<p>Use for sending the control packet to the Breeze device.</p> <p>Parameters:</p> Name Type Description Default <code>remote</code> <code>SwitcherBreezeRemote</code> <p>the remote for the breeze device</p> required <code>state</code> <code>Union[DeviceState, None]</code> <p>the desired state of the device</p> <code>None</code> <code>mode</code> <code>Union[ThermostatMode, None]</code> <p>the desired mode of the device</p> <code>None</code> <code>target_temp</code> <code>int</code> <p>the target temperature</p> <code>0</code> <code>fan_level</code> <code>Union[ThermostatFanLevel, None]</code> <p>the desired fan level</p> <code>None</code> <code>swing</code> <code>Union[ThermostatSwing, None]</code> <p>the desired swing state</p> <code>None</code> <code>update_state</code> <code>bool</code> <p>update the device state without controlling the device</p> <code>False</code> <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def control_breeze_device(\n    self,\n    remote: SwitcherBreezeRemote,\n    state: Union[DeviceState, None] = None,\n    mode: Union[ThermostatMode, None] = None,\n    target_temp: int = 0,\n    fan_level: Union[ThermostatFanLevel, None] = None,\n    swing: Union[ThermostatSwing, None] = None,\n    update_state: bool = False,\n) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the control packet to the Breeze device.\n\n    Args:\n        remote: the remote for the breeze device\n        state: the desired state of the device\n        mode: the desired mode of the device\n        target_temp: the target temperature\n        fan_level: the desired fan level\n        swing: the desired swing state\n        update_state: update the device state without controlling the device\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.control_device","title":"<code>control_device(command, minutes=0)</code>  <code>async</code>","text":"<p>Use for sending the control packet to the device.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Command</code> <p>use the <code>aioswitcher.api.Command</code> enum.</p> required <code>minutes</code> <code>int</code> <p>if turning-on optionally incorporate a timer.</p> <code>0</code> <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def control_device(\n    self, command: Command, minutes: int = 0\n) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the control packet to the device.\n\n    Args:\n        command: use the ``aioswitcher.api.Command`` enum.\n        minutes: if turning-on optionally incorporate a timer.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.create_schedule","title":"<code>create_schedule(start_time, end_time, days=set())</code>  <code>async</code>","text":"<p>Use for creating a new schedule in the next empty schedule slot.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>str</code> <p>a string start time in %H:%M format. e.g. 13:00.</p> required <code>end_time</code> <code>str</code> <p>a string start time in %H:%M format. e.g. 13:00.</p> required <code>days</code> <code>Set[Days]</code> <p>for recurring schedules, add <code>Days</code>.</p> <code>set()</code> <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def create_schedule(\n    self, start_time: str, end_time: str, days: Set[Days] = set()\n) -&gt; SwitcherBaseResponse:\n\"\"\"Use for creating a new schedule in the next empty schedule slot.\n\n    Args:\n        start_time: a string start time in %H:%M format. e.g. 13:00.\n        end_time: a string start time in %H:%M format. e.g. 13:00.\n        days: for recurring schedules, add ``Days``.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.delete_schedule","title":"<code>delete_schedule(schedule_id)</code>  <code>async</code>","text":"<p>Use for deleting a schedule from the device.</p> <p>Use <code>get_schedules</code> to retrieve the schedule instance.</p> <p>Parameters:</p> Name Type Description Default <code>schedule_id</code> <code>str</code> <p>the identification of the schedule for deletion.</p> required <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def delete_schedule(self, schedule_id: str) -&gt; SwitcherBaseResponse:\n\"\"\"Use for deleting a schedule from the device.\n\n    Use ``get_schedules`` to retrieve the schedule instance.\n\n    Args:\n        schedule_id: the identification of the schedule for deletion.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Disconnect from asynchronous socket.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def disconnect(self) -&gt; None:\n\"\"\"Disconnect from asynchronous socket.\"\"\"\n    if hasattr(self, \"_writer\") and self._writer:\n        logger.info(\"disconnecting from the switcher device\")\n        self._writer.close()\n        await self._writer.wait_closed()\n    else:\n        logger.info(\"switcher device not connected\")\n    self._connected = False\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.get_breeze_state","title":"<code>get_breeze_state()</code>  <code>async</code>","text":"<p>Use for sending the get state packet to the Breeze device.</p> <p>Returns:</p> Type Description <code>SwitcherThermostatStateResponse</code> <p>An instance of <code>SwitcherThermostatStateResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def get_breeze_state(self) -&gt; SwitcherThermostatStateResponse:\n\"\"\"Use for sending the get state packet to the Breeze device.\n\n    Returns:\n        An instance of ``SwitcherThermostatStateResponse``.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.get_schedules","title":"<code>get_schedules()</code>  <code>async</code>","text":"<p>Use for retrieval of the schedules from the device.</p> <p>Returns:</p> Type Description <code>SwitcherGetSchedulesResponse</code> <p>An instance of <code>SwitcherGetSchedulesResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def get_schedules(self) -&gt; SwitcherGetSchedulesResponse:\n\"\"\"Use for retrieval of the schedules from the device.\n\n    Returns:\n        An instance of ``SwitcherGetSchedulesResponse``.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.get_state","title":"<code>get_state()</code>  <code>async</code>","text":"<p>Use for sending the get state packet to the device.</p> <p>Returns:</p> Type Description <code>SwitcherStateResponse</code> <p>An instance of <code>SwitcherStateResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def get_state(self) -&gt; SwitcherStateResponse:\n\"\"\"Use for sending the get state packet to the device.\n\n    Returns:\n        An instance of ``SwitcherStateResponse``.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.set_auto_shutdown","title":"<code>set_auto_shutdown(full_time)</code>  <code>async</code>","text":"<p>Use for sending the set auto-off packet to the device.</p> <p>Parameters:</p> Name Type Description Default <code>full_time</code> <code>timedelta</code> <p>timedelta value containing the configuration value for auto-shutdown.</p> required <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def set_auto_shutdown(self, full_time: timedelta) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the set auto-off packet to the device.\n\n    Args:\n        full_time: timedelta value containing the configuration value for\n            auto-shutdown.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.set_device_name","title":"<code>set_device_name(name)</code>  <code>async</code>","text":"<p>Use for sending the set name packet to the device.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>string name with the length of 2 &gt;= x &gt;= 32.</p> required <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def set_device_name(self, name: str) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the set name packet to the device.\n\n    Args:\n        name: string name with the length of 2 &gt;= x &gt;= 32.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.set_position","title":"<code>set_position(position=0)</code>  <code>async</code>","text":"<p>Use for setting the shutter position of the Runner and Runner Mini devices.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int</code> <p>the position to set the device to, default to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def set_position(self, position: int = 0) -&gt; SwitcherBaseResponse:\n\"\"\"Use for setting the shutter position of the Runner and Runner Mini devices.\n\n    Args:\n        position: the position to set the device to, default to 0.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Use for stopping the shutter.</p> <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def stop(self) -&gt; SwitcherBaseResponse:\n\"\"\"Use for stopping the shutter.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n    \"\"\"\n    logger.debug(\"about to send stop shutter command\")\n    timestamp, login_resp = await self._login(DeviceType.RUNNER)\n    if not login_resp.successful:\n        logger.error(\"Failed to log into device with id %s\", self._device_id)\n        raise RuntimeError(\"login request was not successful\")\n\n    logger.debug(\n        \"logged in session_id=%s, timestamp=%s\", login_resp.session_id, timestamp\n    )\n\n    packet = packets.RUNNER_STOP_COMMAND.format(\n        login_resp.session_id, timestamp, self._device_id\n    )\n\n    packet = set_message_length(packet)\n    signed_packet = sign_packet_with_crc_key(packet)\n\n    logger.debug(\"sending a stop control packet\")\n\n    self._writer.write(unhexlify(signed_packet))\n    response = await self._reader.read(1024)\n    return SwitcherBaseResponse(response)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType1Api","title":"<code>SwitcherType1Api</code>","text":"<p>         Bases: <code>SwitcherApi</code></p> <p>Switcher Type1 devices (Plug, V2, Touch, V4) TCP based API.</p> <p>Parameters:</p> Name Type Description Default <code>ip_address</code> <code>str</code> <p>the ip address assigned to the device.</p> required <code>device_id</code> <code>str</code> <p>the id of the desired device.</p> required Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>@final\nclass SwitcherType1Api(SwitcherApi):\n\"\"\"Switcher Type1 devices (Plug, V2, Touch, V4) TCP based API.\n\n    Args:\n        ip_address: the ip address assigned to the device.\n        device_id: the id of the desired device.\n    \"\"\"\n\n    def __init__(self, ip_address: str, device_id: str) -&gt; None:\n\"\"\"Initialize the Switcher TCP connection API.\"\"\"\n        super().__init__(ip_address, device_id, SWITCHER_TCP_PORT_TYPE1)\n\n    async def get_state(self) -&gt; SwitcherStateResponse:\n\"\"\"Use for sending the get state packet to the device.\n\n        Returns:\n            An instance of ``SwitcherStateResponse``.\n        \"\"\"\n        timestamp, login_resp = await self._login()\n        if login_resp.successful:\n            packet = packets.GET_STATE_PACKET_TYPE1.format(\n                login_resp.session_id, timestamp, self._device_id\n            )\n            signed_packet = sign_packet_with_crc_key(packet)\n\n            logger.debug(\"sending a get state packet\")\n            self._writer.write(unhexlify(signed_packet))\n            state_resp = await self._reader.read(1024)\n            try:\n                response = SwitcherStateResponse(state_resp)\n                if response.successful:\n                    return response\n            except (KeyError, ValueError) as ve:\n                raise RuntimeError(\"get state request was not successful\") from ve\n        raise RuntimeError(\"login request was not successful\")\n\n    async def control_device(\n        self, command: Command, minutes: int = 0\n    ) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the control packet to the device.\n\n        Args:\n            command: use the ``aioswitcher.api.Command`` enum.\n            minutes: if turning-on optionally incorporate a timer.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        timestamp, login_resp = await self._login()\n        timer = (\n            minutes_to_hexadecimal_seconds(minutes)\n            if minutes &gt; 0\n            else packets.NO_TIMER_REQUESTED\n        )\n        packet = packets.SEND_CONTROL_PACKET.format(\n            login_resp.session_id,\n            timestamp,\n            self._device_id,\n            command.value,\n            timer,\n        )\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a control packet\")\n        self._writer.write(unhexlify(signed_packet))\n        response = await self._reader.read(1024)\n        return SwitcherBaseResponse(response)\n\n    async def set_auto_shutdown(self, full_time: timedelta) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the set auto-off packet to the device.\n\n        Args:\n            full_time: timedelta value containing the configuration value for\n                auto-shutdown.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        timestamp, login_resp = await self._login()\n        auto_shutdown = timedelta_to_hexadecimal_seconds(full_time)\n        packet = packets.SET_AUTO_OFF_SET_PACKET.format(\n            login_resp.session_id,\n            timestamp,\n            self._device_id,\n            auto_shutdown,\n        )\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a set auto shutdown packet\")\n        self._writer.write(unhexlify(signed_packet))\n        response = await self._reader.read(1024)\n        return SwitcherBaseResponse(response)\n\n    async def set_device_name(self, name: str) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the set name packet to the device.\n\n        Args:\n            name: string name with the length of 2 &gt;= x &gt;= 32.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        timestamp, login_resp = await self._login()\n        device_name = string_to_hexadecimale_device_name(name)\n        packet = packets.UPDATE_DEVICE_NAME_PACKET.format(\n            login_resp.session_id,\n            timestamp,\n            self._device_id,\n            device_name,\n        )\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a set name packet\")\n        self._writer.write(unhexlify(signed_packet))\n        response = await self._reader.read(1024)\n        return SwitcherBaseResponse(response)\n\n    async def get_schedules(self) -&gt; SwitcherGetSchedulesResponse:\n\"\"\"Use for retrieval of the schedules from the device.\n\n        Returns:\n            An instance of ``SwitcherGetSchedulesResponse``.\n\n        \"\"\"\n        timestamp, login_resp = await self._login()\n        packet = packets.GET_SCHEDULES_PACKET.format(\n            login_resp.session_id,\n            timestamp,\n            self._device_id,\n        )\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a get schedules packet\")\n        self._writer.write(unhexlify(signed_packet))\n        response = await self._reader.read(1024)\n        return SwitcherGetSchedulesResponse(response)\n\n    async def delete_schedule(self, schedule_id: str) -&gt; SwitcherBaseResponse:\n\"\"\"Use for deleting a schedule from the device.\n\n        Use ``get_schedules`` to retrieve the schedule instance.\n\n        Args:\n            schedule_id: the identification of the schedule for deletion.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        timestamp, login_resp = await self._login()\n        packet = packets.DELETE_SCHEDULE_PACKET.format(\n            login_resp.session_id, timestamp, self._device_id, schedule_id\n        )\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a delete schedule packet\")\n        self._writer.write(unhexlify(signed_packet))\n        response = await self._reader.read(1024)\n        return SwitcherBaseResponse(response)\n\n    async def create_schedule(\n        self, start_time: str, end_time: str, days: Set[Days] = set()\n    ) -&gt; SwitcherBaseResponse:\n\"\"\"Use for creating a new schedule in the next empty schedule slot.\n\n        Args:\n            start_time: a string start time in %H:%M format. e.g. 13:00.\n            end_time: a string start time in %H:%M format. e.g. 13:00.\n            days: for recurring schedules, add ``Days``.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        timestamp, login_resp = await self._login()\n\n        start_time_hex = time_to_hexadecimal_timestamp(start_time)\n        end_time_hex = time_to_hexadecimal_timestamp(end_time)\n        weekdays = (\n            weekdays_to_hexadecimal(days)\n            if len(days) &gt; 0\n            else packets.NON_RECURRING_SCHEDULE\n        )\n        new_schedule = packets.SCHEDULE_CREATE_DATA_FORMAT.format(\n            weekdays, start_time_hex, end_time_hex\n        )\n        packet = packets.CREATE_SCHEDULE_PACKET.format(\n            login_resp.session_id,\n            timestamp,\n            self._device_id,\n            new_schedule,\n        )\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a create schedule packet\")\n        self._writer.write(unhexlify(signed_packet))\n        response = await self._reader.read(1024)\n        return SwitcherBaseResponse(response)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType1Api.__init__","title":"<code>__init__(ip_address, device_id)</code>","text":"<p>Initialize the Switcher TCP connection API.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>def __init__(self, ip_address: str, device_id: str) -&gt; None:\n\"\"\"Initialize the Switcher TCP connection API.\"\"\"\n    super().__init__(ip_address, device_id, SWITCHER_TCP_PORT_TYPE1)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType1Api.control_device","title":"<code>control_device(command, minutes=0)</code>  <code>async</code>","text":"<p>Use for sending the control packet to the device.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Command</code> <p>use the <code>aioswitcher.api.Command</code> enum.</p> required <code>minutes</code> <code>int</code> <p>if turning-on optionally incorporate a timer.</p> <code>0</code> <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def control_device(\n    self, command: Command, minutes: int = 0\n) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the control packet to the device.\n\n    Args:\n        command: use the ``aioswitcher.api.Command`` enum.\n        minutes: if turning-on optionally incorporate a timer.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    timestamp, login_resp = await self._login()\n    timer = (\n        minutes_to_hexadecimal_seconds(minutes)\n        if minutes &gt; 0\n        else packets.NO_TIMER_REQUESTED\n    )\n    packet = packets.SEND_CONTROL_PACKET.format(\n        login_resp.session_id,\n        timestamp,\n        self._device_id,\n        command.value,\n        timer,\n    )\n    signed_packet = sign_packet_with_crc_key(packet)\n\n    logger.debug(\"sending a control packet\")\n    self._writer.write(unhexlify(signed_packet))\n    response = await self._reader.read(1024)\n    return SwitcherBaseResponse(response)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType1Api.create_schedule","title":"<code>create_schedule(start_time, end_time, days=set())</code>  <code>async</code>","text":"<p>Use for creating a new schedule in the next empty schedule slot.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>str</code> <p>a string start time in %H:%M format. e.g. 13:00.</p> required <code>end_time</code> <code>str</code> <p>a string start time in %H:%M format. e.g. 13:00.</p> required <code>days</code> <code>Set[Days]</code> <p>for recurring schedules, add <code>Days</code>.</p> <code>set()</code> <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def create_schedule(\n    self, start_time: str, end_time: str, days: Set[Days] = set()\n) -&gt; SwitcherBaseResponse:\n\"\"\"Use for creating a new schedule in the next empty schedule slot.\n\n    Args:\n        start_time: a string start time in %H:%M format. e.g. 13:00.\n        end_time: a string start time in %H:%M format. e.g. 13:00.\n        days: for recurring schedules, add ``Days``.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    timestamp, login_resp = await self._login()\n\n    start_time_hex = time_to_hexadecimal_timestamp(start_time)\n    end_time_hex = time_to_hexadecimal_timestamp(end_time)\n    weekdays = (\n        weekdays_to_hexadecimal(days)\n        if len(days) &gt; 0\n        else packets.NON_RECURRING_SCHEDULE\n    )\n    new_schedule = packets.SCHEDULE_CREATE_DATA_FORMAT.format(\n        weekdays, start_time_hex, end_time_hex\n    )\n    packet = packets.CREATE_SCHEDULE_PACKET.format(\n        login_resp.session_id,\n        timestamp,\n        self._device_id,\n        new_schedule,\n    )\n    signed_packet = sign_packet_with_crc_key(packet)\n\n    logger.debug(\"sending a create schedule packet\")\n    self._writer.write(unhexlify(signed_packet))\n    response = await self._reader.read(1024)\n    return SwitcherBaseResponse(response)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType1Api.delete_schedule","title":"<code>delete_schedule(schedule_id)</code>  <code>async</code>","text":"<p>Use for deleting a schedule from the device.</p> <p>Use <code>get_schedules</code> to retrieve the schedule instance.</p> <p>Parameters:</p> Name Type Description Default <code>schedule_id</code> <code>str</code> <p>the identification of the schedule for deletion.</p> required <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def delete_schedule(self, schedule_id: str) -&gt; SwitcherBaseResponse:\n\"\"\"Use for deleting a schedule from the device.\n\n    Use ``get_schedules`` to retrieve the schedule instance.\n\n    Args:\n        schedule_id: the identification of the schedule for deletion.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    timestamp, login_resp = await self._login()\n    packet = packets.DELETE_SCHEDULE_PACKET.format(\n        login_resp.session_id, timestamp, self._device_id, schedule_id\n    )\n    signed_packet = sign_packet_with_crc_key(packet)\n\n    logger.debug(\"sending a delete schedule packet\")\n    self._writer.write(unhexlify(signed_packet))\n    response = await self._reader.read(1024)\n    return SwitcherBaseResponse(response)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType1Api.get_schedules","title":"<code>get_schedules()</code>  <code>async</code>","text":"<p>Use for retrieval of the schedules from the device.</p> <p>Returns:</p> Type Description <code>SwitcherGetSchedulesResponse</code> <p>An instance of <code>SwitcherGetSchedulesResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def get_schedules(self) -&gt; SwitcherGetSchedulesResponse:\n\"\"\"Use for retrieval of the schedules from the device.\n\n    Returns:\n        An instance of ``SwitcherGetSchedulesResponse``.\n\n    \"\"\"\n    timestamp, login_resp = await self._login()\n    packet = packets.GET_SCHEDULES_PACKET.format(\n        login_resp.session_id,\n        timestamp,\n        self._device_id,\n    )\n    signed_packet = sign_packet_with_crc_key(packet)\n\n    logger.debug(\"sending a get schedules packet\")\n    self._writer.write(unhexlify(signed_packet))\n    response = await self._reader.read(1024)\n    return SwitcherGetSchedulesResponse(response)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType1Api.get_state","title":"<code>get_state()</code>  <code>async</code>","text":"<p>Use for sending the get state packet to the device.</p> <p>Returns:</p> Type Description <code>SwitcherStateResponse</code> <p>An instance of <code>SwitcherStateResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def get_state(self) -&gt; SwitcherStateResponse:\n\"\"\"Use for sending the get state packet to the device.\n\n    Returns:\n        An instance of ``SwitcherStateResponse``.\n    \"\"\"\n    timestamp, login_resp = await self._login()\n    if login_resp.successful:\n        packet = packets.GET_STATE_PACKET_TYPE1.format(\n            login_resp.session_id, timestamp, self._device_id\n        )\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a get state packet\")\n        self._writer.write(unhexlify(signed_packet))\n        state_resp = await self._reader.read(1024)\n        try:\n            response = SwitcherStateResponse(state_resp)\n            if response.successful:\n                return response\n        except (KeyError, ValueError) as ve:\n            raise RuntimeError(\"get state request was not successful\") from ve\n    raise RuntimeError(\"login request was not successful\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType1Api.set_auto_shutdown","title":"<code>set_auto_shutdown(full_time)</code>  <code>async</code>","text":"<p>Use for sending the set auto-off packet to the device.</p> <p>Parameters:</p> Name Type Description Default <code>full_time</code> <code>timedelta</code> <p>timedelta value containing the configuration value for auto-shutdown.</p> required <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def set_auto_shutdown(self, full_time: timedelta) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the set auto-off packet to the device.\n\n    Args:\n        full_time: timedelta value containing the configuration value for\n            auto-shutdown.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    timestamp, login_resp = await self._login()\n    auto_shutdown = timedelta_to_hexadecimal_seconds(full_time)\n    packet = packets.SET_AUTO_OFF_SET_PACKET.format(\n        login_resp.session_id,\n        timestamp,\n        self._device_id,\n        auto_shutdown,\n    )\n    signed_packet = sign_packet_with_crc_key(packet)\n\n    logger.debug(\"sending a set auto shutdown packet\")\n    self._writer.write(unhexlify(signed_packet))\n    response = await self._reader.read(1024)\n    return SwitcherBaseResponse(response)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType1Api.set_device_name","title":"<code>set_device_name(name)</code>  <code>async</code>","text":"<p>Use for sending the set name packet to the device.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>string name with the length of 2 &gt;= x &gt;= 32.</p> required <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def set_device_name(self, name: str) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the set name packet to the device.\n\n    Args:\n        name: string name with the length of 2 &gt;= x &gt;= 32.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    timestamp, login_resp = await self._login()\n    device_name = string_to_hexadecimale_device_name(name)\n    packet = packets.UPDATE_DEVICE_NAME_PACKET.format(\n        login_resp.session_id,\n        timestamp,\n        self._device_id,\n        device_name,\n    )\n    signed_packet = sign_packet_with_crc_key(packet)\n\n    logger.debug(\"sending a set name packet\")\n    self._writer.write(unhexlify(signed_packet))\n    response = await self._reader.read(1024)\n    return SwitcherBaseResponse(response)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType2Api","title":"<code>SwitcherType2Api</code>","text":"<p>         Bases: <code>SwitcherApi</code></p> <p>Switcher Type2 devices (Breeze, Runners) TCP based API.</p> <p>Parameters:</p> Name Type Description Default <code>ip_address</code> <code>str</code> <p>the ip address assigned to the device.</p> required <code>device_id</code> <code>str</code> <p>the id of the desired device.</p> required Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>@final\nclass SwitcherType2Api(SwitcherApi):\n\"\"\"Switcher Type2 devices (Breeze, Runners) TCP based API.\n\n    Args:\n        ip_address: the ip address assigned to the device.\n        device_id: the id of the desired device.\n    \"\"\"\n\n    def __init__(self, ip_address: str, device_id: str) -&gt; None:\n\"\"\"Initialize the Switcher TCP connection API.\"\"\"\n        super().__init__(ip_address, device_id, SWITCHER_TCP_PORT_TYPE2)\n\n    async def control_breeze_device(\n        self,\n        remote: SwitcherBreezeRemote,\n        state: Union[DeviceState, None] = None,\n        mode: Union[ThermostatMode, None] = None,\n        target_temp: int = 0,\n        fan_level: Union[ThermostatFanLevel, None] = None,\n        swing: Union[ThermostatSwing, None] = None,\n        update_state: bool = False,\n    ) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the control packet to the Breeze device.\n\n        Args:\n            remote: the remote for the breeze device\n            state: optionally the desired state of the device\n            mode: optionally the desired mode of the device\n            target_temp: optionally the target temperature\n            fan_level: optionally the desired fan level\n            swing: optionally the desired swing state\n            update_state: update the device state without controlling the device\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        timestamp, login_resp = await self._login(DeviceType.BREEZE)\n        if not login_resp.successful:\n            logger.error(\"Failed to log into device id %s\", self._device_id)\n            raise RuntimeError(\"login request was not successful\")\n\n        logger.debug(\n            \"logged in session_id=%s, timestamp=%s\", login_resp.session_id, timestamp\n        )\n\n        cmd_response: Union[SwitcherBaseResponse, None] = None\n        if (\n            state\n            or mode\n            or target_temp\n            or fan_level\n            or (swing and not remote._separated_swing_command)\n        ):\n            current_state = await self._get_breeze_state(timestamp, login_resp)\n            if not current_state.successful:\n                raise RuntimeError(\"get state request was not successful\")\n\n            logger.debug(\"got current breeze device state\")\n\n            state = state or current_state.state\n            mode = mode or current_state.mode\n            target_temp = target_temp or current_state.target_temperature\n            fan_level = fan_level or current_state.fan_level\n            set_swing = swing or current_state.swing\n            if remote._separated_swing_command:\n                set_swing = ThermostatSwing.OFF\n            if update_state:\n                packet = packets.BREEZE_UPDATE_STATUS_PACKET.format(\n                    login_resp.session_id,\n                    timestamp,\n                    self._device_id,\n                    state.value,\n                    mode.value,\n                    target_temp,\n                    fan_level.value,\n                    set_swing.value,\n                )\n                logger.debug(\"sending a set status packet\")\n            else:\n                command = remote.build_command(\n                    state, mode, target_temp, fan_level, set_swing, current_state.state\n                )\n\n                packet = packets.BREEZE_COMMAND_PACKET.format(\n                    login_resp.session_id,\n                    timestamp,\n                    self._device_id,\n                    command.length,\n                    command.command,\n                )\n                logger.debug(\"sending a control packet\")\n\n            packet = set_message_length(packet)\n            signed_packet = sign_packet_with_crc_key(packet)\n\n            self._writer.write(unhexlify(signed_packet))\n            response = await self._reader.read(1024)\n            cmd_response = SwitcherBaseResponse(response)\n\n            if not cmd_response.successful:\n                raise RuntimeError(\"set state request was not successful\")\n\n        if remote._separated_swing_command and swing and not update_state:\n            # if device is SPECIAL SWING device and user requested a swing change\n            cmd_response = await self._control_breeze_swing_device(\n                timestamp, login_resp.session_id, remote, swing\n            )\n\n        if cmd_response:\n            return cmd_response\n        raise RuntimeError(\"control breeze device failed\")\n\n    async def _control_breeze_swing_device(\n        self,\n        timestamp: str,\n        session_id: str,\n        remote: SwitcherBreezeRemote,\n        swing: ThermostatSwing,\n    ) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the control packet to the Breeze device.\n\n        Args:\n            timestamp: the timestamp from the login response\n            session_id: the session_id from the login response\n            remote: the remote for the breeze device\n            swing: the desired swing state\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        logger.debug(\"about to send Breeze special swing command\")\n        command = remote.build_swing_command(swing)\n        packet = packets.BREEZE_COMMAND_PACKET.format(\n            session_id,\n            timestamp,\n            self._device_id,\n            command.length,\n            command.command,\n        )\n\n        packet = set_message_length(packet)\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a control packet\")\n\n        self._writer.write(unhexlify(signed_packet))\n        response = await self._reader.read(1024)\n        return SwitcherBaseResponse(response)\n\n    async def set_position(self, position: int = 0) -&gt; SwitcherBaseResponse:\n\"\"\"Use for setting the shutter position of the Runner and Runner Mini devices.\n\n        Args:\n            position: the position to set the device to, default to 0.\n\n        Returns:\n            An instance of ``SwitcherBaseResponse``.\n\n        \"\"\"\n        hex_pos = \"{0:0{1}x}\".format(position, 2)\n\n        logger.debug(\"about to send set position command\")\n        timestamp, login_resp = await self._login(DeviceType.RUNNER)\n        if not login_resp.successful:\n            logger.error(\"Failed to log into device with id %s\", self._device_id)\n            raise RuntimeError(\"login request was not successful\")\n\n        logger.debug(\n            \"logged in session_id=%s, timestamp=%s\", login_resp.session_id, timestamp\n        )\n\n        packet = packets.RUNNER_SET_POSITION.format(\n            login_resp.session_id, timestamp, self._device_id, hex_pos\n        )\n\n        packet = set_message_length(packet)\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a control packet\")\n\n        self._writer.write(unhexlify(signed_packet))\n        response = await self._reader.read(1024)\n        return SwitcherBaseResponse(response)\n\n    async def get_breeze_state(self) -&gt; SwitcherThermostatStateResponse:\n\"\"\"Use for sending the get state packet to the Breeze device.\n\n        Returns:\n            An instance of ``SwitcherThermostatStateResponse``.\n\n        \"\"\"\n        timestamp, login_resp = await self._login(DeviceType.BREEZE)\n        if login_resp.successful:\n            return await self._get_breeze_state(timestamp, login_resp)\n        raise RuntimeError(\"login request was not successful\")\n\n    async def _get_breeze_state(\n        self, timestamp: str, login_resp: SwitcherLoginResponse\n    ) -&gt; SwitcherThermostatStateResponse:\n        packet = packets.GET_STATE_PACKET2_TYPE2.format(\n            login_resp.session_id, timestamp, self._device_id\n        )\n\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a get state packet\")\n        self._writer.write(unhexlify(signed_packet))\n        state_resp = await self._reader.read(1024)\n        try:\n            response = SwitcherThermostatStateResponse(state_resp)\n            return response\n        except (KeyError, ValueError) as ve:\n            raise RuntimeError(\"get breeze state request was not successful\") from ve\n\n    async def get_shutter_state(self) -&gt; SwitcherShutterStateResponse:\n\"\"\"Use for sending the get state packet to the Runner device.\n\n        Returns:\n            An instance of ``SwitcherShutterStateResponse``.\n\n        \"\"\"\n        timestamp, login_resp = await self._login(DeviceType.RUNNER)\n        if login_resp.successful:\n            packet = packets.GET_STATE_PACKET2_TYPE2.format(\n                login_resp.session_id, timestamp, self._device_id\n            )\n\n            signed_packet = sign_packet_with_crc_key(packet)\n\n            logger.debug(\"sending a get state packet\")\n            self._writer.write(unhexlify(signed_packet))\n            state_resp = await self._reader.read(1024)\n            try:\n                response = SwitcherShutterStateResponse(state_resp)\n                return response\n            except (KeyError, ValueError) as ve:\n                raise RuntimeError(\n                    \"get shutter state request was not successful\"\n                ) from ve\n        raise RuntimeError(\"login request was not successful\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType2Api.__init__","title":"<code>__init__(ip_address, device_id)</code>","text":"<p>Initialize the Switcher TCP connection API.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>def __init__(self, ip_address: str, device_id: str) -&gt; None:\n\"\"\"Initialize the Switcher TCP connection API.\"\"\"\n    super().__init__(ip_address, device_id, SWITCHER_TCP_PORT_TYPE2)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType2Api.control_breeze_device","title":"<code>control_breeze_device(remote, state=None, mode=None, target_temp=0, fan_level=None, swing=None, update_state=False)</code>  <code>async</code>","text":"<p>Use for sending the control packet to the Breeze device.</p> <p>Parameters:</p> Name Type Description Default <code>remote</code> <code>SwitcherBreezeRemote</code> <p>the remote for the breeze device</p> required <code>state</code> <code>Union[DeviceState, None]</code> <p>optionally the desired state of the device</p> <code>None</code> <code>mode</code> <code>Union[ThermostatMode, None]</code> <p>optionally the desired mode of the device</p> <code>None</code> <code>target_temp</code> <code>int</code> <p>optionally the target temperature</p> <code>0</code> <code>fan_level</code> <code>Union[ThermostatFanLevel, None]</code> <p>optionally the desired fan level</p> <code>None</code> <code>swing</code> <code>Union[ThermostatSwing, None]</code> <p>optionally the desired swing state</p> <code>None</code> <code>update_state</code> <code>bool</code> <p>update the device state without controlling the device</p> <code>False</code> <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def control_breeze_device(\n    self,\n    remote: SwitcherBreezeRemote,\n    state: Union[DeviceState, None] = None,\n    mode: Union[ThermostatMode, None] = None,\n    target_temp: int = 0,\n    fan_level: Union[ThermostatFanLevel, None] = None,\n    swing: Union[ThermostatSwing, None] = None,\n    update_state: bool = False,\n) -&gt; SwitcherBaseResponse:\n\"\"\"Use for sending the control packet to the Breeze device.\n\n    Args:\n        remote: the remote for the breeze device\n        state: optionally the desired state of the device\n        mode: optionally the desired mode of the device\n        target_temp: optionally the target temperature\n        fan_level: optionally the desired fan level\n        swing: optionally the desired swing state\n        update_state: update the device state without controlling the device\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    timestamp, login_resp = await self._login(DeviceType.BREEZE)\n    if not login_resp.successful:\n        logger.error(\"Failed to log into device id %s\", self._device_id)\n        raise RuntimeError(\"login request was not successful\")\n\n    logger.debug(\n        \"logged in session_id=%s, timestamp=%s\", login_resp.session_id, timestamp\n    )\n\n    cmd_response: Union[SwitcherBaseResponse, None] = None\n    if (\n        state\n        or mode\n        or target_temp\n        or fan_level\n        or (swing and not remote._separated_swing_command)\n    ):\n        current_state = await self._get_breeze_state(timestamp, login_resp)\n        if not current_state.successful:\n            raise RuntimeError(\"get state request was not successful\")\n\n        logger.debug(\"got current breeze device state\")\n\n        state = state or current_state.state\n        mode = mode or current_state.mode\n        target_temp = target_temp or current_state.target_temperature\n        fan_level = fan_level or current_state.fan_level\n        set_swing = swing or current_state.swing\n        if remote._separated_swing_command:\n            set_swing = ThermostatSwing.OFF\n        if update_state:\n            packet = packets.BREEZE_UPDATE_STATUS_PACKET.format(\n                login_resp.session_id,\n                timestamp,\n                self._device_id,\n                state.value,\n                mode.value,\n                target_temp,\n                fan_level.value,\n                set_swing.value,\n            )\n            logger.debug(\"sending a set status packet\")\n        else:\n            command = remote.build_command(\n                state, mode, target_temp, fan_level, set_swing, current_state.state\n            )\n\n            packet = packets.BREEZE_COMMAND_PACKET.format(\n                login_resp.session_id,\n                timestamp,\n                self._device_id,\n                command.length,\n                command.command,\n            )\n            logger.debug(\"sending a control packet\")\n\n        packet = set_message_length(packet)\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        self._writer.write(unhexlify(signed_packet))\n        response = await self._reader.read(1024)\n        cmd_response = SwitcherBaseResponse(response)\n\n        if not cmd_response.successful:\n            raise RuntimeError(\"set state request was not successful\")\n\n    if remote._separated_swing_command and swing and not update_state:\n        # if device is SPECIAL SWING device and user requested a swing change\n        cmd_response = await self._control_breeze_swing_device(\n            timestamp, login_resp.session_id, remote, swing\n        )\n\n    if cmd_response:\n        return cmd_response\n    raise RuntimeError(\"control breeze device failed\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType2Api.get_breeze_state","title":"<code>get_breeze_state()</code>  <code>async</code>","text":"<p>Use for sending the get state packet to the Breeze device.</p> <p>Returns:</p> Type Description <code>SwitcherThermostatStateResponse</code> <p>An instance of <code>SwitcherThermostatStateResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def get_breeze_state(self) -&gt; SwitcherThermostatStateResponse:\n\"\"\"Use for sending the get state packet to the Breeze device.\n\n    Returns:\n        An instance of ``SwitcherThermostatStateResponse``.\n\n    \"\"\"\n    timestamp, login_resp = await self._login(DeviceType.BREEZE)\n    if login_resp.successful:\n        return await self._get_breeze_state(timestamp, login_resp)\n    raise RuntimeError(\"login request was not successful\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType2Api.get_shutter_state","title":"<code>get_shutter_state()</code>  <code>async</code>","text":"<p>Use for sending the get state packet to the Runner device.</p> <p>Returns:</p> Type Description <code>SwitcherShutterStateResponse</code> <p>An instance of <code>SwitcherShutterStateResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def get_shutter_state(self) -&gt; SwitcherShutterStateResponse:\n\"\"\"Use for sending the get state packet to the Runner device.\n\n    Returns:\n        An instance of ``SwitcherShutterStateResponse``.\n\n    \"\"\"\n    timestamp, login_resp = await self._login(DeviceType.RUNNER)\n    if login_resp.successful:\n        packet = packets.GET_STATE_PACKET2_TYPE2.format(\n            login_resp.session_id, timestamp, self._device_id\n        )\n\n        signed_packet = sign_packet_with_crc_key(packet)\n\n        logger.debug(\"sending a get state packet\")\n        self._writer.write(unhexlify(signed_packet))\n        state_resp = await self._reader.read(1024)\n        try:\n            response = SwitcherShutterStateResponse(state_resp)\n            return response\n        except (KeyError, ValueError) as ve:\n            raise RuntimeError(\n                \"get shutter state request was not successful\"\n            ) from ve\n    raise RuntimeError(\"login request was not successful\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.SwitcherType2Api.set_position","title":"<code>set_position(position=0)</code>  <code>async</code>","text":"<p>Use for setting the shutter position of the Runner and Runner Mini devices.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int</code> <p>the position to set the device to, default to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>SwitcherBaseResponse</code> <p>An instance of <code>SwitcherBaseResponse</code>.</p> Source code in <code>src/aioswitcher/api/__init__.py</code> <pre><code>async def set_position(self, position: int = 0) -&gt; SwitcherBaseResponse:\n\"\"\"Use for setting the shutter position of the Runner and Runner Mini devices.\n\n    Args:\n        position: the position to set the device to, default to 0.\n\n    Returns:\n        An instance of ``SwitcherBaseResponse``.\n\n    \"\"\"\n    hex_pos = \"{0:0{1}x}\".format(position, 2)\n\n    logger.debug(\"about to send set position command\")\n    timestamp, login_resp = await self._login(DeviceType.RUNNER)\n    if not login_resp.successful:\n        logger.error(\"Failed to log into device with id %s\", self._device_id)\n        raise RuntimeError(\"login request was not successful\")\n\n    logger.debug(\n        \"logged in session_id=%s, timestamp=%s\", login_resp.session_id, timestamp\n    )\n\n    packet = packets.RUNNER_SET_POSITION.format(\n        login_resp.session_id, timestamp, self._device_id, hex_pos\n    )\n\n    packet = set_message_length(packet)\n    signed_packet = sign_packet_with_crc_key(packet)\n\n    logger.debug(\"sending a control packet\")\n\n    self._writer.write(unhexlify(signed_packet))\n    response = await self._reader.read(1024)\n    return SwitcherBaseResponse(response)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser","title":"<code>StateMessageParser</code>  <code>dataclass</code>","text":"<p>Use for parsing api messages.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>@final\n@dataclass\nclass StateMessageParser:\n\"\"\"Use for parsing api messages.\"\"\"\n\n    response: InitVar[bytes]\n\n    def __post_init__(self, response: bytes) -&gt; None:\n\"\"\"Post initialization of the parser.\"\"\"\n        self._hex_response = hexlify(response)\n\n    def get_power_consumption(self) -&gt; int:\n\"\"\"Return the current power consumption of the device.\"\"\"\n        hex_power = self._hex_response[154:162]\n        return int(hex_power[2:4] + hex_power[0:2], 16)\n\n    def get_time_left(self) -&gt; str:\n\"\"\"Return the time left for the device current run.\"\"\"\n        hex_time_left = self._hex_response[178:186]\n        time_left_seconds = int(\n            hex_time_left[6:8]\n            + hex_time_left[4:6]\n            + hex_time_left[2:4]\n            + hex_time_left[0:2],\n            16,\n        )\n        return seconds_to_iso_time(time_left_seconds)\n\n    def get_time_on(self) -&gt; str:\n\"\"\"Return how long the device has been on.\"\"\"\n        hex_time_on = self._hex_response[186:194]\n        time_on_seconds = int(\n            hex_time_on[6:8] + hex_time_on[4:6] + hex_time_on[2:4] + hex_time_on[0:2],\n            16,\n        )\n        return seconds_to_iso_time(time_on_seconds)\n\n    def get_auto_shutdown(self) -&gt; str:\n\"\"\"Return the value of the auto shutdown configuration.\"\"\"\n        hex_auto_off = self._hex_response[194:202]\n        auto_off_seconds = int(\n            hex_auto_off[6:8]\n            + hex_auto_off[4:6]\n            + hex_auto_off[2:4]\n            + hex_auto_off[0:2],\n            16,\n        )\n        return seconds_to_iso_time(auto_off_seconds)\n\n    def get_state(self) -&gt; DeviceState:\n\"\"\"Return the current device state.\"\"\"\n        hex_state = self._hex_response[150:152].decode()\n        states = dict(map(lambda s: (s.value, s), DeviceState))\n        return states[hex_state]\n\n    def get_thermostat_state(self) -&gt; DeviceState:\n\"\"\"Return the current thermostat state.\"\"\"\n        hex_power = self._hex_response[156:158].decode()\n        return DeviceState.OFF if hex_power == DeviceState.OFF.value else DeviceState.ON\n\n    def get_thermostat_mode(self) -&gt; ThermostatMode:\n\"\"\"Return the current thermostat mode.\"\"\"\n        hex_mode = self._hex_response[158:160]\n        modes = dict(map(lambda s: (s.value, s), ThermostatMode))\n        try:\n            return modes[hex_mode.decode()]\n        except KeyError:\n            return ThermostatMode.COOL\n\n    def get_thermostat_temp(self) -&gt; float:\n\"\"\"Return the current temp of the thermostat.\"\"\"\n        return int(self._hex_response[154:156] + self._hex_response[152:154], 16) / 10\n\n    def get_thermostat_target_temp(self) -&gt; int:\n\"\"\"Return the current temperature of the thermostat.\"\"\"\n        hex_temp = self._hex_response[160:162]\n        return int(hex_temp, 16)\n\n    def get_thermostat_fan_level(self) -&gt; ThermostatFanLevel:\n\"\"\"Return the current thermostat fan level.\"\"\"\n        hex_level = self._hex_response[162:163].decode()\n        levels = dict(map(lambda s: (s.value, s), ThermostatFanLevel))\n        try:\n            return levels[hex_level]\n        except KeyError:\n            return ThermostatFanLevel.LOW\n\n    def get_thermostat_swing(self) -&gt; ThermostatSwing:\n\"\"\"Return the current thermostat fan swing.\"\"\"\n        hex_swing = self._hex_response[163:164].decode()\n        return (\n            ThermostatSwing.OFF\n            if hex_swing == ThermostatSwing.OFF.value\n            else ThermostatSwing.ON\n        )\n\n    def get_thermostat_remote_id(self) -&gt; str:\n\"\"\"Return the current thermostat remote.\"\"\"\n        remote_hex = unhexlify(self._hex_response)\n        return remote_hex[84:92].decode().rstrip(\"\\x00\")\n\n    def get_shutter_position(self) -&gt; int:\n\"\"\"Return the current shutter position.\"\"\"\n        hex_pos = self._hex_response[152:154].decode()\n        return int(hex_pos, 16)\n\n    def get_shutter_direction(self) -&gt; ShutterDirection:\n\"\"\"Return the current shutter direction.\"\"\"\n        hex_dir = self._hex_response[156:160].decode()\n        directions = dict(map(lambda s: (s.value, s), ShutterDirection))\n        return directions[hex_dir]\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.__post_init__","title":"<code>__post_init__(response)</code>","text":"<p>Post initialization of the parser.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def __post_init__(self, response: bytes) -&gt; None:\n\"\"\"Post initialization of the parser.\"\"\"\n    self._hex_response = hexlify(response)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_auto_shutdown","title":"<code>get_auto_shutdown()</code>","text":"<p>Return the value of the auto shutdown configuration.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_auto_shutdown(self) -&gt; str:\n\"\"\"Return the value of the auto shutdown configuration.\"\"\"\n    hex_auto_off = self._hex_response[194:202]\n    auto_off_seconds = int(\n        hex_auto_off[6:8]\n        + hex_auto_off[4:6]\n        + hex_auto_off[2:4]\n        + hex_auto_off[0:2],\n        16,\n    )\n    return seconds_to_iso_time(auto_off_seconds)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_power_consumption","title":"<code>get_power_consumption()</code>","text":"<p>Return the current power consumption of the device.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_power_consumption(self) -&gt; int:\n\"\"\"Return the current power consumption of the device.\"\"\"\n    hex_power = self._hex_response[154:162]\n    return int(hex_power[2:4] + hex_power[0:2], 16)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_shutter_direction","title":"<code>get_shutter_direction()</code>","text":"<p>Return the current shutter direction.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_shutter_direction(self) -&gt; ShutterDirection:\n\"\"\"Return the current shutter direction.\"\"\"\n    hex_dir = self._hex_response[156:160].decode()\n    directions = dict(map(lambda s: (s.value, s), ShutterDirection))\n    return directions[hex_dir]\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_shutter_position","title":"<code>get_shutter_position()</code>","text":"<p>Return the current shutter position.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_shutter_position(self) -&gt; int:\n\"\"\"Return the current shutter position.\"\"\"\n    hex_pos = self._hex_response[152:154].decode()\n    return int(hex_pos, 16)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_state","title":"<code>get_state()</code>","text":"<p>Return the current device state.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_state(self) -&gt; DeviceState:\n\"\"\"Return the current device state.\"\"\"\n    hex_state = self._hex_response[150:152].decode()\n    states = dict(map(lambda s: (s.value, s), DeviceState))\n    return states[hex_state]\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_thermostat_fan_level","title":"<code>get_thermostat_fan_level()</code>","text":"<p>Return the current thermostat fan level.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_thermostat_fan_level(self) -&gt; ThermostatFanLevel:\n\"\"\"Return the current thermostat fan level.\"\"\"\n    hex_level = self._hex_response[162:163].decode()\n    levels = dict(map(lambda s: (s.value, s), ThermostatFanLevel))\n    try:\n        return levels[hex_level]\n    except KeyError:\n        return ThermostatFanLevel.LOW\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_thermostat_mode","title":"<code>get_thermostat_mode()</code>","text":"<p>Return the current thermostat mode.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_thermostat_mode(self) -&gt; ThermostatMode:\n\"\"\"Return the current thermostat mode.\"\"\"\n    hex_mode = self._hex_response[158:160]\n    modes = dict(map(lambda s: (s.value, s), ThermostatMode))\n    try:\n        return modes[hex_mode.decode()]\n    except KeyError:\n        return ThermostatMode.COOL\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_thermostat_remote_id","title":"<code>get_thermostat_remote_id()</code>","text":"<p>Return the current thermostat remote.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_thermostat_remote_id(self) -&gt; str:\n\"\"\"Return the current thermostat remote.\"\"\"\n    remote_hex = unhexlify(self._hex_response)\n    return remote_hex[84:92].decode().rstrip(\"\\x00\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_thermostat_state","title":"<code>get_thermostat_state()</code>","text":"<p>Return the current thermostat state.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_thermostat_state(self) -&gt; DeviceState:\n\"\"\"Return the current thermostat state.\"\"\"\n    hex_power = self._hex_response[156:158].decode()\n    return DeviceState.OFF if hex_power == DeviceState.OFF.value else DeviceState.ON\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_thermostat_swing","title":"<code>get_thermostat_swing()</code>","text":"<p>Return the current thermostat fan swing.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_thermostat_swing(self) -&gt; ThermostatSwing:\n\"\"\"Return the current thermostat fan swing.\"\"\"\n    hex_swing = self._hex_response[163:164].decode()\n    return (\n        ThermostatSwing.OFF\n        if hex_swing == ThermostatSwing.OFF.value\n        else ThermostatSwing.ON\n    )\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_thermostat_target_temp","title":"<code>get_thermostat_target_temp()</code>","text":"<p>Return the current temperature of the thermostat.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_thermostat_target_temp(self) -&gt; int:\n\"\"\"Return the current temperature of the thermostat.\"\"\"\n    hex_temp = self._hex_response[160:162]\n    return int(hex_temp, 16)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_thermostat_temp","title":"<code>get_thermostat_temp()</code>","text":"<p>Return the current temp of the thermostat.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_thermostat_temp(self) -&gt; float:\n\"\"\"Return the current temp of the thermostat.\"\"\"\n    return int(self._hex_response[154:156] + self._hex_response[152:154], 16) / 10\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_time_left","title":"<code>get_time_left()</code>","text":"<p>Return the time left for the device current run.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_time_left(self) -&gt; str:\n\"\"\"Return the time left for the device current run.\"\"\"\n    hex_time_left = self._hex_response[178:186]\n    time_left_seconds = int(\n        hex_time_left[6:8]\n        + hex_time_left[4:6]\n        + hex_time_left[2:4]\n        + hex_time_left[0:2],\n        16,\n    )\n    return seconds_to_iso_time(time_left_seconds)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.StateMessageParser.get_time_on","title":"<code>get_time_on()</code>","text":"<p>Return how long the device has been on.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def get_time_on(self) -&gt; str:\n\"\"\"Return how long the device has been on.\"\"\"\n    hex_time_on = self._hex_response[186:194]\n    time_on_seconds = int(\n        hex_time_on[6:8] + hex_time_on[4:6] + hex_time_on[2:4] + hex_time_on[0:2],\n        16,\n    )\n    return seconds_to_iso_time(time_on_seconds)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherBaseResponse","title":"<code>SwitcherBaseResponse</code>  <code>dataclass</code>","text":"<p>Representation of the switcher base response message.</p> <p>Applicable for all messages that do no require post initialization. e.g. not applicable for SwitcherLoginResponse, SwitcherStateResponse, SwitcherGetScheduleResponse.</p> <p>Parameters:</p> Name Type Description Default <code>unparsed_response</code> <code>bytes</code> <p>the raw response from the device.</p> required Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>@dataclass\nclass SwitcherBaseResponse:\n\"\"\"Representation of the switcher base response message.\n\n    Applicable for all messages that do no require post initialization.\n    e.g. not applicable for SwitcherLoginResponse, SwitcherStateResponse,\n    SwitcherGetScheduleResponse.\n\n    Args:\n        unparsed_response: the raw response from the device.\n\n    \"\"\"\n\n    unparsed_response: bytes\n\n    @property\n    def successful(self) -&gt; bool:\n\"\"\"Return true if the response is not empty.\n\n        Partially indicating the request was successful.\n        \"\"\"\n        return self.unparsed_response is not None and len(self.unparsed_response) &gt; 0\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherBaseResponse.successful","title":"<code>successful: bool</code>  <code>property</code>","text":"<p>Return true if the response is not empty.</p> <p>Partially indicating the request was successful.</p>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherGetSchedulesResponse","title":"<code>SwitcherGetSchedulesResponse</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SwitcherBaseResponse</code></p> <p>Representation of the switcher get schedule message.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>@final\n@dataclass\nclass SwitcherGetSchedulesResponse(SwitcherBaseResponse):\n\"\"\"Representation of the switcher get schedule message.\"\"\"\n\n    schedules: Set[SwitcherSchedule] = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Post initialization of the message.\"\"\"\n        self.schedules = get_schedules(self.unparsed_response)\n\n    @property\n    def found_schedules(self) -&gt; bool:\n\"\"\"Return true if found schedules in the response.\"\"\"\n        return len(self.schedules) &gt; 0\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherGetSchedulesResponse.found_schedules","title":"<code>found_schedules: bool</code>  <code>property</code>","text":"<p>Return true if found schedules in the response.</p>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherGetSchedulesResponse.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post initialization of the message.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization of the message.\"\"\"\n    self.schedules = get_schedules(self.unparsed_response)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherLoginResponse","title":"<code>SwitcherLoginResponse</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SwitcherBaseResponse</code></p> <p>Representations of the switcher login response message.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>@final\n@dataclass\nclass SwitcherLoginResponse(SwitcherBaseResponse):\n\"\"\"Representations of the switcher login response message.\"\"\"\n\n    session_id: str = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Post initialization of the response.\"\"\"\n        try:\n            self.session_id = hexlify(self.unparsed_response)[16:24].decode()\n        except Exception as exc:\n            raise ValueError(\"failed to parse login response message\") from exc\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherLoginResponse.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post initialization of the response.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization of the response.\"\"\"\n    try:\n        self.session_id = hexlify(self.unparsed_response)[16:24].decode()\n    except Exception as exc:\n        raise ValueError(\"failed to parse login response message\") from exc\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherShutterStateResponse","title":"<code>SwitcherShutterStateResponse</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SwitcherBaseResponse</code></p> <p>Representation of the Switcher shutter devices state response message.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>@final\n@dataclass\nclass SwitcherShutterStateResponse(SwitcherBaseResponse):\n\"\"\"Representation of the Switcher shutter devices state response message.\"\"\"\n\n    position: int = field(init=False)\n    direction: ShutterDirection = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Post initialization of the message.\"\"\"\n        parser = StateMessageParser(self.unparsed_response)\n\n        self.direction = parser.get_shutter_direction()\n        self.position = parser.get_shutter_position()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherShutterStateResponse.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post initialization of the message.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization of the message.\"\"\"\n    parser = StateMessageParser(self.unparsed_response)\n\n    self.direction = parser.get_shutter_direction()\n    self.position = parser.get_shutter_position()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherStateResponse","title":"<code>SwitcherStateResponse</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SwitcherBaseResponse</code></p> <p>Representation of the switcher state response message.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>@final\n@dataclass\nclass SwitcherStateResponse(SwitcherBaseResponse):\n\"\"\"Representation of the switcher state response message.\"\"\"\n\n    state: DeviceState = field(init=False)\n    time_left: str = field(init=False)\n    time_on: str = field(init=False)\n    auto_shutdown: str = field(init=False)\n    power_consumption: int = field(init=False)\n    electric_current: float = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Post initialization of the message.\"\"\"\n        parser = StateMessageParser(self.unparsed_response)\n\n        self.state = parser.get_state()\n        self.time_left = parser.get_time_left()\n        self.time_on = parser.get_time_on()\n        self.auto_shutdown = parser.get_auto_shutdown()\n        self.power_consumption = parser.get_power_consumption()\n        self.electric_current = watts_to_amps(self.power_consumption)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherStateResponse.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post initialization of the message.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization of the message.\"\"\"\n    parser = StateMessageParser(self.unparsed_response)\n\n    self.state = parser.get_state()\n    self.time_left = parser.get_time_left()\n    self.time_on = parser.get_time_on()\n    self.auto_shutdown = parser.get_auto_shutdown()\n    self.power_consumption = parser.get_power_consumption()\n    self.electric_current = watts_to_amps(self.power_consumption)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherThermostatStateResponse","title":"<code>SwitcherThermostatStateResponse</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SwitcherBaseResponse</code></p> <p>Representation of the Switcher thermostat device state response message.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>@final\n@dataclass\nclass SwitcherThermostatStateResponse(SwitcherBaseResponse):\n\"\"\"Representation of the Switcher thermostat device state response message.\"\"\"\n\n    state: DeviceState = field(init=False)\n    mode: ThermostatMode = field(init=False)\n    fan_level: ThermostatFanLevel = field(init=False)\n    temperature: float = field(init=False)\n    target_temperature: int = field(init=False)\n    swing: ThermostatSwing = field(init=False)\n    remote_id: str = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Post initialization of the message.\"\"\"\n        parser = StateMessageParser(self.unparsed_response)\n\n        self.state = parser.get_thermostat_state()\n        self.mode = parser.get_thermostat_mode()\n        self.fan_level = parser.get_thermostat_fan_level()\n        self.temperature = parser.get_thermostat_temp()\n        self.target_temperature = parser.get_thermostat_target_temp()\n        self.swing = parser.get_thermostat_swing()\n        self.remote_id = parser.get_thermostat_remote_id()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherThermostatStateResponse.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post initialization of the message.</p> Source code in <code>src/aioswitcher/api/messages.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization of the message.\"\"\"\n    parser = StateMessageParser(self.unparsed_response)\n\n    self.state = parser.get_thermostat_state()\n    self.mode = parser.get_thermostat_mode()\n    self.fan_level = parser.get_thermostat_fan_level()\n    self.temperature = parser.get_thermostat_temp()\n    self.target_temperature = parser.get_thermostat_target_temp()\n    self.swing = parser.get_thermostat_swing()\n    self.remote_id = parser.get_thermostat_remote_id()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeCommand","title":"<code>SwitcherBreezeCommand</code>","text":"<p>Representations of the Switcher Breeze command message.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>a string command ready to be parsed and sent</p> required Source code in <code>src/aioswitcher/api/remotes.py</code> <pre><code>@final\nclass SwitcherBreezeCommand:\n\"\"\"Representations of the Switcher Breeze command message.\n\n    Args:\n        command: a string command ready to be parsed and sent\n\n    \"\"\"\n\n    def __init__(self, command: str) -&gt; None:\n\"\"\"Initialize the Breeze command.\"\"\"\n        self.command = command\n        self.length = self._get_command_length()\n\n    def _get_command_length(self) -&gt; str:\n\"\"\"Get command length.\n\n        Note:\n            This is a private function used by other functions, do not call this\n            function directly.\n\n        \"\"\"\n        return \"{:x}\".format(int(len(self.command) / 2)).ljust(4, \"0\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeCommand.__init__","title":"<code>__init__(command)</code>","text":"<p>Initialize the Breeze command.</p> Source code in <code>src/aioswitcher/api/remotes.py</code> <pre><code>def __init__(self, command: str) -&gt; None:\n\"\"\"Initialize the Breeze command.\"\"\"\n    self.command = command\n    self.length = self._get_command_length()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemote","title":"<code>SwitcherBreezeRemote</code>","text":"<p>Class that represent a remote for a Breeze device/s.</p> <p>Parameters:</p> Name Type Description Default <code>ir_set</code> <code>Dict[str, Any]</code> <p>a dictionary for all supported remotes</p> required Source code in <code>src/aioswitcher/api/remotes.py</code> <pre><code>@final\nclass SwitcherBreezeRemote:\n\"\"\"Class that represent a remote for a Breeze device/s.\n\n    Args:\n        ir_set: a dictionary for all supported remotes\n\n    \"\"\"\n\n    def __init__(self, ir_set: Dict[str, Any]) -&gt; None:\n\"\"\"Initialize the remote by parsing the ir_set data.\"\"\"\n        self._min_temp = 100  # ridiculously high number\n        self._max_temp = -100  # ridiculously low number\n        self._on_off_type = False\n        self._remote_id: str = ir_set[\"IRSetID\"]\n        # _ir_wave_map hosts a shrunk version of the ir_set file which ignores\n        # unused data and map key to dict{\"HexCode\": str, \"Para\": str}\n        # this is being built by the _resolve_capabilities method\n        self._ir_wave_map: Dict[str, Dict[str, str]] = {}\n        self._modes_features: Dict[ThermostatMode, Dict[str, Any]] = {}\n\"\"\"\n        self._modes_features basically explains the available features\n            (Swing/Fan levels/ temp control of each mode)\n        Example of _modes_features for ELEC7022 IRSet remote\n        {\n            &lt; ThermostatMode.AUTO: ('01', 'auto') &gt;: {\n                'swing': False,\n                'fan_levels': set(),\n                'temperature_control': False\n            }, &lt; ThermostatMode.DRY: ('02', 'dry') &gt;: {\n                'swing': False,\n                'fan_levels': set(),\n                'temperature_control': False\n            }, &lt; ThermostatMode.FAN: ('03', 'fan') &gt;: {\n                'swing': False,\n                'fan_levels': {\n                    &lt; ThermostatFanLevel.HIGH: ('3', 'high') &gt; ,\n                    &lt; ThermostatFanLevel.AUTO: ('0', 'auto') &gt; ,\n                    &lt; ThermostatFanLevel.MEDIUM: ('2', 'medium') &gt; ,\n                    &lt; ThermostatFanLevel.LOW: ('1', 'low') &gt;\n                },\n                'temperature_control': False\n            }, &lt; ThermostatMode.COOL: ('04', 'cool') &gt;: {\n                'swing': False,\n                'fan_levels': {\n                    &lt; ThermostatFanLevel.HIGH: ('3', 'high') &gt; ,\n                    &lt; ThermostatFanLevel.AUTO: ('0', 'auto') &gt; ,\n                    &lt; ThermostatFanLevel.MEDIUM: ('2', 'medium') &gt; ,\n                    &lt; ThermostatFanLevel.LOW: ('1', 'low') &gt;\n                },\n                'temperature_control': True\n            }, &lt; ThermostatMode.HEAT: ('05', 'heat') &gt;: {\n                'swing': True,\n                'fan_levels': {\n                    &lt; ThermostatFanLevel.HIGH: ('3', 'high') &gt; ,\n                    &lt; ThermostatFanLevel.AUTO: ('0', 'auto') &gt; ,\n                    &lt; ThermostatFanLevel.MEDIUM: ('2', 'medium') &gt; ,\n                    &lt; ThermostatFanLevel.LOW: ('1', 'low') &gt;\n                },\n                'temperature_control': True\n            }\n        }\n        \"\"\"\n        self._separated_swing_command = (\n            self._remote_id in SPECIAL_SWING_COMMAND_REMOTE_IDS\n        )\n\n        self._resolve_capabilities(ir_set)\n\n    @property\n    def modes_features(\n        self,\n    ) -&gt; Dict[ThermostatMode, Dict[str, Any]]:\n\"\"\"Getter for supported feature per mode.\"\"\"\n        return self._modes_features\n\n    @property\n    def supported_modes(self) -&gt; List[ThermostatMode]:\n\"\"\"Getter for supported modes.\"\"\"\n        return list(self.modes_features.keys())\n\n    @property\n    def max_temperature(self) -&gt; int:\n\"\"\"Getter for Maximum supported temperature.\"\"\"\n        return self._max_temp\n\n    @property\n    def min_temperature(self) -&gt; int:\n\"\"\"Getter for Minimum supported temperature.\"\"\"\n        return self._min_temp\n\n    @property\n    def remote_id(self) -&gt; str:\n\"\"\"Getter for remote id.\"\"\"\n        return self._remote_id\n\n    @property\n    def separated_swing_command(self) -&gt; bool:\n\"\"\"Getter for which indicates if the AC has a separated swing command.\"\"\"\n        return self._separated_swing_command\n\n    @property\n    def on_off_type(self) -&gt; bool:\n\"\"\"Getter for which indicates if the AC if on/off (toggle) type.\"\"\"\n        return self._on_off_type\n\n    def _lookup_key_in_irset(self, key: List[str]) -&gt; None:\n\"\"\"Use this to look for a key in the IRSet file.\n\n        Args:\n            key: a reference to List of strings representing parts of the command.\n\n        Note:\n            This is a private function used by other functions, do not call this\n            function directly.\n\n        \"\"\"\n        while (\n            len(key) != 1\n        ):  # we match this condition with the key contains at least the mode\n            # Try to lookup the key as is in the ir set map\n            if \"\".join(key) not in self._ir_wave_map:\n                # we didn't find a key, remove feature from the key and try to\n                # look again.\n                # The first feature removed is the swing \"_d1\"\n                # Secondly is the fan level (_f0, _f1, _f2, _f3)\n                # lastly we stay at least with the mode part\n                removed_element = key.pop()\n                logger.debug(f\"Removed {removed_element} from the key\")\n            else:\n                # found a match, with modified list\n                return\n\n    def build_swing_command(self, swing: ThermostatSwing) -&gt; SwitcherBreezeCommand:\n\"\"\"Build a special command to control swing on special remotes.\n\n        Args:\n            swing: the desired swing state\n\n        Returns:\n            An instance of ``SwitcherBreezeCommand``\n\n        \"\"\"\n        key = \"FUN_d0\" if swing == ThermostatSwing.OFF else \"FUN_d1\"\n        try:\n            command = (\n                self._ir_wave_map[\"\".join(key)][\"Para\"]\n                + \"|\"\n                + self._ir_wave_map[\"\".join(key)][\"HexCode\"]\n            )\n        except KeyError:\n            logger.error(\n                f'The special swing key \"{key}\"        \\\n                    does not exist in the IRSet database!'\n            )\n            raise RuntimeError(\n                f'The special swing key \"{key}\"'\n                \" does not exist in the IRSet database!\"\n            )\n\n        return SwitcherBreezeCommand(\n            \"00000000\" + hexlify(str(command).encode()).decode()\n        )\n\n    def build_command(\n        self,\n        state: DeviceState,\n        mode: ThermostatMode,\n        target_temp: int,\n        fan_level: ThermostatFanLevel,\n        swing: ThermostatSwing,\n        current_state: Union[DeviceState, None] = None,\n    ) -&gt; SwitcherBreezeCommand:\n\"\"\"Build command that controls the Breeze device.\n\n        Args:\n            state: the desired state of the device\n            mode: the desired mode of the device\n            target_temp: the target temperature\n            fan_level: the desired fan level\n            swing: the desired swing state\n            current_state: optionally, for toggle device, pass previous state to avoid\n                redundant requests\n\n        Returns:\n            An instance of ``SwitcherBreezeCommand``\n\n        \"\"\"\n        key: List[str] = []\n        command = \"\"\n        # verify the target temp and set maximum if we provided with higher number\n        if target_temp &gt; self._max_temp:\n            target_temp = self._max_temp\n\n        # verify the target temp and set minimum if we provided with lower number\n        elif target_temp &lt; self._min_temp:\n            target_temp = self._min_temp\n\n        if mode not in self.supported_modes:\n            raise RuntimeError(\n                f'Invalid mode \"{mode.display}\", available modes for this device are: '\n                f\"{', '.join([x.display for x in self.supported_modes])}\"\n            )\n\n        # non toggle AC, just turn it off\n        if not self._on_off_type and state == DeviceState.OFF:\n            key.append(\"off\")\n        else:\n            # This is a toggle mode AC, we determine here whether the first bit should\n            # be on or off in order to change the AC state based on its current state.\n            if self._on_off_type and current_state and current_state != state:\n                # This is a toggle mode AC.\n                key.append(\"on_\")\n\n            # for toggle mode AC - set state. for non toggle AC mode set state and turn\n            # it on.\n            if self._on_off_type or (not self._on_off_type and state == DeviceState.ON):\n                # Auto and Dry can sometimes have a FAN level and in other cases\n                # it might not have. in any case we try to add the request fan\n                # level to the key, if we get a match we fulfill the request, otherwise\n                # we remove the fan and lookup the key again\n                if mode in [\n                    ThermostatMode.AUTO,\n                    ThermostatMode.DRY,\n                    ThermostatMode.FAN,\n                ]:\n                    # the command key should start with mode (aa/ad/ar/ah)\n                    key.append(MODE_TO_COMMAND[mode])\n                    # add the requested fan level (_f0, _f1, _f2, _f3)\n                    key.append(\"_\" + FAN_LEVEL_TO_COMMAND[fan_level])\n\n                    # add the swing On (_d1) to the key\n                    if swing == ThermostatSwing.ON:\n                        key.append(\"_d1\")\n\n                    self._lookup_key_in_irset(key)\n\n                if mode in [ThermostatMode.COOL, ThermostatMode.HEAT]:\n                    key.append(MODE_TO_COMMAND[mode])\n                    key.append(str(target_temp))\n                    key.append(\"_\" + FAN_LEVEL_TO_COMMAND[fan_level])\n                    if swing == ThermostatSwing.ON:\n                        key.append(\"_d1\")\n\n                    self._lookup_key_in_irset(key)\n\n        command = (\n            self._ir_wave_map[\"\".join(key)][\"Para\"]\n            + \"|\"\n            + self._ir_wave_map[\"\".join(key)][\"HexCode\"]\n        )\n        return SwitcherBreezeCommand(\n            \"00000000\" + hexlify(str(command).encode()).decode()\n        )\n\n    def _resolve_capabilities(self, ir_set: Dict[str, Any]) -&gt; None:\n\"\"\"Parse the ir_set of the remote and build capability data struct.\n\n        Args:\n            ir_set: a dictionary for all supported remotes\n\n        Note:\n            This is a private function used by other functions, do not call this\n            function directly.\n\n        \"\"\"\n        if ir_set[\"OnOffType\"] == 1:\n            self._on_off_type = True\n\n        mode = None\n\n        for wave in ir_set[\"IRWaveList\"]:\n            key = wave[\"Key\"]\n            try:\n                mode = COMMAND_TO_MODE[key[0:2]]\n                if mode not in self._modes_features:\n                    self._modes_features[mode] = {\n                        \"swing\": False,\n                        \"fan_levels\": set(),\n                        \"temperature_control\": False,\n                    }\n\n                    # This type of ACs support swing mode in every mode\n                    if self.separated_swing_command:\n                        self._modes_features[mode][\"swing\"] = True\n\n            except KeyError:\n                pass\n\n            fan_level = re.match(r\".+(f\\d)\", key)\n            if fan_level and mode:\n                self._modes_features[mode][\"fan_levels\"].add(\n                    COMMAND_TO_FAN_LEVEL[fan_level.group(1)]\n                )\n\n            temp = key[2:4]\n            if temp.isdigit():\n                if mode and not self._modes_features[mode][\"temperature_control\"]:\n                    self._modes_features[mode][\"temperature_control\"] = True\n                temp = int(temp)\n                if temp &gt; self._max_temp:\n                    self._max_temp = temp\n                if temp &lt; self._min_temp:\n                    self._min_temp = temp\n\n            if mode:\n                self._modes_features[mode][\"swing\"] |= \"d1\" in key\n\n            self._ir_wave_map[key] = {\"Para\": wave[\"Para\"], \"HexCode\": wave[\"HexCode\"]}\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemote.max_temperature","title":"<code>max_temperature: int</code>  <code>property</code>","text":"<p>Getter for Maximum supported temperature.</p>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemote.min_temperature","title":"<code>min_temperature: int</code>  <code>property</code>","text":"<p>Getter for Minimum supported temperature.</p>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemote.modes_features","title":"<code>modes_features: Dict[ThermostatMode, Dict[str, Any]]</code>  <code>property</code>","text":"<p>Getter for supported feature per mode.</p>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemote.on_off_type","title":"<code>on_off_type: bool</code>  <code>property</code>","text":"<p>Getter for which indicates if the AC if on/off (toggle) type.</p>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemote.remote_id","title":"<code>remote_id: str</code>  <code>property</code>","text":"<p>Getter for remote id.</p>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemote.separated_swing_command","title":"<code>separated_swing_command: bool</code>  <code>property</code>","text":"<p>Getter for which indicates if the AC has a separated swing command.</p>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemote.supported_modes","title":"<code>supported_modes: List[ThermostatMode]</code>  <code>property</code>","text":"<p>Getter for supported modes.</p>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemote.__init__","title":"<code>__init__(ir_set)</code>","text":"<p>Initialize the remote by parsing the ir_set data.</p> Source code in <code>src/aioswitcher/api/remotes.py</code> <pre><code>def __init__(self, ir_set: Dict[str, Any]) -&gt; None:\n\"\"\"Initialize the remote by parsing the ir_set data.\"\"\"\n    self._min_temp = 100  # ridiculously high number\n    self._max_temp = -100  # ridiculously low number\n    self._on_off_type = False\n    self._remote_id: str = ir_set[\"IRSetID\"]\n    # _ir_wave_map hosts a shrunk version of the ir_set file which ignores\n    # unused data and map key to dict{\"HexCode\": str, \"Para\": str}\n    # this is being built by the _resolve_capabilities method\n    self._ir_wave_map: Dict[str, Dict[str, str]] = {}\n    self._modes_features: Dict[ThermostatMode, Dict[str, Any]] = {}\n\"\"\"\n    self._modes_features basically explains the available features\n        (Swing/Fan levels/ temp control of each mode)\n    Example of _modes_features for ELEC7022 IRSet remote\n    {\n        &lt; ThermostatMode.AUTO: ('01', 'auto') &gt;: {\n            'swing': False,\n            'fan_levels': set(),\n            'temperature_control': False\n        }, &lt; ThermostatMode.DRY: ('02', 'dry') &gt;: {\n            'swing': False,\n            'fan_levels': set(),\n            'temperature_control': False\n        }, &lt; ThermostatMode.FAN: ('03', 'fan') &gt;: {\n            'swing': False,\n            'fan_levels': {\n                &lt; ThermostatFanLevel.HIGH: ('3', 'high') &gt; ,\n                &lt; ThermostatFanLevel.AUTO: ('0', 'auto') &gt; ,\n                &lt; ThermostatFanLevel.MEDIUM: ('2', 'medium') &gt; ,\n                &lt; ThermostatFanLevel.LOW: ('1', 'low') &gt;\n            },\n            'temperature_control': False\n        }, &lt; ThermostatMode.COOL: ('04', 'cool') &gt;: {\n            'swing': False,\n            'fan_levels': {\n                &lt; ThermostatFanLevel.HIGH: ('3', 'high') &gt; ,\n                &lt; ThermostatFanLevel.AUTO: ('0', 'auto') &gt; ,\n                &lt; ThermostatFanLevel.MEDIUM: ('2', 'medium') &gt; ,\n                &lt; ThermostatFanLevel.LOW: ('1', 'low') &gt;\n            },\n            'temperature_control': True\n        }, &lt; ThermostatMode.HEAT: ('05', 'heat') &gt;: {\n            'swing': True,\n            'fan_levels': {\n                &lt; ThermostatFanLevel.HIGH: ('3', 'high') &gt; ,\n                &lt; ThermostatFanLevel.AUTO: ('0', 'auto') &gt; ,\n                &lt; ThermostatFanLevel.MEDIUM: ('2', 'medium') &gt; ,\n                &lt; ThermostatFanLevel.LOW: ('1', 'low') &gt;\n            },\n            'temperature_control': True\n        }\n    }\n    \"\"\"\n    self._separated_swing_command = (\n        self._remote_id in SPECIAL_SWING_COMMAND_REMOTE_IDS\n    )\n\n    self._resolve_capabilities(ir_set)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemote.build_command","title":"<code>build_command(state, mode, target_temp, fan_level, swing, current_state=None)</code>","text":"<p>Build command that controls the Breeze device.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>DeviceState</code> <p>the desired state of the device</p> required <code>mode</code> <code>ThermostatMode</code> <p>the desired mode of the device</p> required <code>target_temp</code> <code>int</code> <p>the target temperature</p> required <code>fan_level</code> <code>ThermostatFanLevel</code> <p>the desired fan level</p> required <code>swing</code> <code>ThermostatSwing</code> <p>the desired swing state</p> required <code>current_state</code> <code>Union[DeviceState, None]</code> <p>optionally, for toggle device, pass previous state to avoid redundant requests</p> <code>None</code> <p>Returns:</p> Type Description <code>SwitcherBreezeCommand</code> <p>An instance of <code>SwitcherBreezeCommand</code></p> Source code in <code>src/aioswitcher/api/remotes.py</code> <pre><code>def build_command(\n    self,\n    state: DeviceState,\n    mode: ThermostatMode,\n    target_temp: int,\n    fan_level: ThermostatFanLevel,\n    swing: ThermostatSwing,\n    current_state: Union[DeviceState, None] = None,\n) -&gt; SwitcherBreezeCommand:\n\"\"\"Build command that controls the Breeze device.\n\n    Args:\n        state: the desired state of the device\n        mode: the desired mode of the device\n        target_temp: the target temperature\n        fan_level: the desired fan level\n        swing: the desired swing state\n        current_state: optionally, for toggle device, pass previous state to avoid\n            redundant requests\n\n    Returns:\n        An instance of ``SwitcherBreezeCommand``\n\n    \"\"\"\n    key: List[str] = []\n    command = \"\"\n    # verify the target temp and set maximum if we provided with higher number\n    if target_temp &gt; self._max_temp:\n        target_temp = self._max_temp\n\n    # verify the target temp and set minimum if we provided with lower number\n    elif target_temp &lt; self._min_temp:\n        target_temp = self._min_temp\n\n    if mode not in self.supported_modes:\n        raise RuntimeError(\n            f'Invalid mode \"{mode.display}\", available modes for this device are: '\n            f\"{', '.join([x.display for x in self.supported_modes])}\"\n        )\n\n    # non toggle AC, just turn it off\n    if not self._on_off_type and state == DeviceState.OFF:\n        key.append(\"off\")\n    else:\n        # This is a toggle mode AC, we determine here whether the first bit should\n        # be on or off in order to change the AC state based on its current state.\n        if self._on_off_type and current_state and current_state != state:\n            # This is a toggle mode AC.\n            key.append(\"on_\")\n\n        # for toggle mode AC - set state. for non toggle AC mode set state and turn\n        # it on.\n        if self._on_off_type or (not self._on_off_type and state == DeviceState.ON):\n            # Auto and Dry can sometimes have a FAN level and in other cases\n            # it might not have. in any case we try to add the request fan\n            # level to the key, if we get a match we fulfill the request, otherwise\n            # we remove the fan and lookup the key again\n            if mode in [\n                ThermostatMode.AUTO,\n                ThermostatMode.DRY,\n                ThermostatMode.FAN,\n            ]:\n                # the command key should start with mode (aa/ad/ar/ah)\n                key.append(MODE_TO_COMMAND[mode])\n                # add the requested fan level (_f0, _f1, _f2, _f3)\n                key.append(\"_\" + FAN_LEVEL_TO_COMMAND[fan_level])\n\n                # add the swing On (_d1) to the key\n                if swing == ThermostatSwing.ON:\n                    key.append(\"_d1\")\n\n                self._lookup_key_in_irset(key)\n\n            if mode in [ThermostatMode.COOL, ThermostatMode.HEAT]:\n                key.append(MODE_TO_COMMAND[mode])\n                key.append(str(target_temp))\n                key.append(\"_\" + FAN_LEVEL_TO_COMMAND[fan_level])\n                if swing == ThermostatSwing.ON:\n                    key.append(\"_d1\")\n\n                self._lookup_key_in_irset(key)\n\n    command = (\n        self._ir_wave_map[\"\".join(key)][\"Para\"]\n        + \"|\"\n        + self._ir_wave_map[\"\".join(key)][\"HexCode\"]\n    )\n    return SwitcherBreezeCommand(\n        \"00000000\" + hexlify(str(command).encode()).decode()\n    )\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemote.build_swing_command","title":"<code>build_swing_command(swing)</code>","text":"<p>Build a special command to control swing on special remotes.</p> <p>Parameters:</p> Name Type Description Default <code>swing</code> <code>ThermostatSwing</code> <p>the desired swing state</p> required <p>Returns:</p> Type Description <code>SwitcherBreezeCommand</code> <p>An instance of <code>SwitcherBreezeCommand</code></p> Source code in <code>src/aioswitcher/api/remotes.py</code> <pre><code>def build_swing_command(self, swing: ThermostatSwing) -&gt; SwitcherBreezeCommand:\n\"\"\"Build a special command to control swing on special remotes.\n\n    Args:\n        swing: the desired swing state\n\n    Returns:\n        An instance of ``SwitcherBreezeCommand``\n\n    \"\"\"\n    key = \"FUN_d0\" if swing == ThermostatSwing.OFF else \"FUN_d1\"\n    try:\n        command = (\n            self._ir_wave_map[\"\".join(key)][\"Para\"]\n            + \"|\"\n            + self._ir_wave_map[\"\".join(key)][\"HexCode\"]\n        )\n    except KeyError:\n        logger.error(\n            f'The special swing key \"{key}\"        \\\n                does not exist in the IRSet database!'\n        )\n        raise RuntimeError(\n            f'The special swing key \"{key}\"'\n            \" does not exist in the IRSet database!\"\n        )\n\n    return SwitcherBreezeCommand(\n        \"00000000\" + hexlify(str(command).encode()).decode()\n    )\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemoteManager","title":"<code>SwitcherBreezeRemoteManager</code>","text":"<p>Class for managing Breeze remotes.</p> <p>Parameters:</p> Name Type Description Default <code>remotes_db_path</code> <code>str</code> <p>optional path of supported remote json file</p> <code>BREEZE_REMOTE_DB_FPATH</code> Source code in <code>src/aioswitcher/api/remotes.py</code> <pre><code>class SwitcherBreezeRemoteManager:\n\"\"\"Class for managing Breeze remotes.\n\n    Args:\n        remotes_db_path: optional path of supported remote json file\n\n    \"\"\"\n\n    def __init__(self, remotes_db_path: str = BREEZE_REMOTE_DB_FPATH) -&gt; None:\n\"\"\"Initialize the Remote manager.\"\"\"\n        self._remotes_db: Dict[str, SwitcherBreezeRemote] = {}\n        self._remotes_db_fpath = remotes_db_path\n\n    def get_remote(self, remote_id: str) -&gt; SwitcherBreezeRemote:\n\"\"\"Get Breeze remote by the remote id.\n\n        Args:\n            remote_id: the id of the desired remote\n\n        Returns:\n            an instance of ``SwitcherBreezeRemote``\n\n        \"\"\"\n        # check if the remote was already loaded\n        if remote_id not in self._remotes_db:\n            # load the remote into the memory\n            with open(self._remotes_db_fpath) as remotes_fd:\n                self._remotes_db[remote_id] = SwitcherBreezeRemote(\n                    load(remotes_fd)[remote_id]\n                )\n\n        return self._remotes_db[remote_id]\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemoteManager.__init__","title":"<code>__init__(remotes_db_path=BREEZE_REMOTE_DB_FPATH)</code>","text":"<p>Initialize the Remote manager.</p> Source code in <code>src/aioswitcher/api/remotes.py</code> <pre><code>def __init__(self, remotes_db_path: str = BREEZE_REMOTE_DB_FPATH) -&gt; None:\n\"\"\"Initialize the Remote manager.\"\"\"\n    self._remotes_db: Dict[str, SwitcherBreezeRemote] = {}\n    self._remotes_db_fpath = remotes_db_path\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.api.remotes.SwitcherBreezeRemoteManager.get_remote","title":"<code>get_remote(remote_id)</code>","text":"<p>Get Breeze remote by the remote id.</p> <p>Parameters:</p> Name Type Description Default <code>remote_id</code> <code>str</code> <p>the id of the desired remote</p> required <p>Returns:</p> Type Description <code>SwitcherBreezeRemote</code> <p>an instance of <code>SwitcherBreezeRemote</code></p> Source code in <code>src/aioswitcher/api/remotes.py</code> <pre><code>def get_remote(self, remote_id: str) -&gt; SwitcherBreezeRemote:\n\"\"\"Get Breeze remote by the remote id.\n\n    Args:\n        remote_id: the id of the desired remote\n\n    Returns:\n        an instance of ``SwitcherBreezeRemote``\n\n    \"\"\"\n    # check if the remote was already loaded\n    if remote_id not in self._remotes_db:\n        # load the remote into the memory\n        with open(self._remotes_db_fpath) as remotes_fd:\n            self._remotes_db[remote_id] = SwitcherBreezeRemote(\n                load(remotes_fd)[remote_id]\n            )\n\n    return self._remotes_db[remote_id]\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser","title":"<code>DatagramParser</code>  <code>dataclass</code>","text":"<p>Utility class for parsing a datagram into various device properties.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>@final\n@dataclass(frozen=True)\nclass DatagramParser:\n\"\"\"Utility class for parsing a datagram into various device properties.\"\"\"\n\n    message: bytes\n\n    def is_switcher_originator(self) -&gt; bool:\n\"\"\"Verify the broadcast message had originated from a switcher device.\"\"\"\n        return hexlify(self.message)[0:4].decode() == \"fef0\" and (\n            len(self.message) == 165\n            or len(self.message) == 168  # Switcher Breeze\n            or len(self.message) == 159  # Switcher Runner and RunnerMini\n        )\n\n    def get_ip_type1(self) -&gt; str:\n\"\"\"Extract the IP address from the type1 broadcast message (Heater, Plug).\"\"\"\n        hex_ip = hexlify(self.message)[152:160]\n        ip_addr = int(hex_ip[6:8] + hex_ip[4:6] + hex_ip[2:4] + hex_ip[0:2], 16)\n        return inet_ntoa(pack(\"&lt;L\", ip_addr))\n\n    def get_ip_type2(self) -&gt; str:\n\"\"\"Extract the IP address from the broadcast message (Breeze, Runners).\"\"\"\n        hex_ip = hexlify(self.message)[154:162]\n        ip_addr = int(hex_ip[0:2] + hex_ip[2:4] + hex_ip[4:6] + hex_ip[6:8], 16)\n        return inet_ntoa(pack(\"&gt;L\", ip_addr))\n\n    def get_mac(self) -&gt; str:\n\"\"\"Extract the MAC address from the broadcast message.\"\"\"\n        hex_mac = hexlify(self.message)[160:172].decode().upper()\n        return (\n            hex_mac[0:2]\n            + \":\"\n            + hex_mac[2:4]\n            + \":\"\n            + hex_mac[4:6]\n            + \":\"\n            + hex_mac[6:8]\n            + \":\"\n            + hex_mac[8:10]\n            + \":\"\n            + hex_mac[10:12]\n        )\n\n    def get_name(self) -&gt; str:\n\"\"\"Extract the device name from the broadcast message.\"\"\"\n        return self.message[42:74].decode().rstrip(\"\\x00\")\n\n    def get_device_id(self) -&gt; str:\n\"\"\"Extract the device id from the broadcast message.\"\"\"\n        return hexlify(self.message)[36:42].decode()\n\n    def get_device_state(self) -&gt; DeviceState:\n\"\"\"Extract the device state from the broadcast message.\"\"\"\n        hex_device_state = hexlify(self.message)[266:268].decode()\n        return (\n            DeviceState.ON\n            if hex_device_state == DeviceState.ON.value\n            else DeviceState.OFF\n        )\n\n    def get_auto_shutdown(self) -&gt; str:\n\"\"\"Extract the auto shutdown value from the broadcast message.\"\"\"\n        hex_auto_shutdown_val = hexlify(self.message)[310:318]\n        int_auto_shutdown_val_secs = int(\n            hex_auto_shutdown_val[6:8]\n            + hex_auto_shutdown_val[4:6]\n            + hex_auto_shutdown_val[2:4]\n            + hex_auto_shutdown_val[0:2],\n            16,\n        )\n        return seconds_to_iso_time(int_auto_shutdown_val_secs)\n\n    def get_power_consumption(self) -&gt; int:\n\"\"\"Extract the power consumption from the broadcast message.\"\"\"\n        hex_power_consumption = hexlify(self.message)[270:278]\n        return int(hex_power_consumption[2:4] + hex_power_consumption[0:2], 16)\n\n    def get_remaining(self) -&gt; str:\n\"\"\"Extract the time remains for the current execution.\"\"\"\n        hex_remaining_time = hexlify(self.message)[294:302]\n        int_remaining_time_seconds = int(\n            hex_remaining_time[6:8]\n            + hex_remaining_time[4:6]\n            + hex_remaining_time[2:4]\n            + hex_remaining_time[0:2],\n            16,\n        )\n        return seconds_to_iso_time(int_remaining_time_seconds)\n\n    def get_device_type(self) -&gt; DeviceType:\n\"\"\"Extract the device type from the broadcast message.\"\"\"\n        hex_model = hexlify(self.message[74:76]).decode()\n        devices = dict(map(lambda d: (d.hex_rep, d), DeviceType))\n        return devices[hex_model]\n\n    # Switcher Runner and Runner Mini methods\n\n    def get_shutter_position(self) -&gt; int:\n\"\"\"Return the current position of the shutter 0 &lt;= pos &lt;= 100.\"\"\"\n        hex_pos = hexlify(self.message[135:137]).decode()\n        return int(hex_pos[2:4]) + int(hex_pos[0:2], 16)\n\n    def get_shutter_direction(self) -&gt; ShutterDirection:\n\"\"\"Return the current direction of the shutter (UP/DOWN/STOP).\"\"\"\n        hex_direction = hexlify(self.message[137:139]).decode()\n        directions = dict(map(lambda d: (d.value, d), ShutterDirection))\n        return directions[hex_direction]\n\n    # Switcher Breeze methods\n\n    def get_thermostat_temp(self) -&gt; float:\n\"\"\"Return the current temp of the thermostat.\"\"\"\n        hex_temp = hexlify(self.message[135:137]).decode()\n        return int(hex_temp[2:4] + hex_temp[0:2], 16) / 10\n\n    def get_thermostat_state(self) -&gt; DeviceState:\n\"\"\"Return the current thermostat state.\"\"\"\n        hex_power = hexlify(self.message[137:138]).decode()\n        return DeviceState.ON if hex_power == DeviceState.ON.value else DeviceState.OFF\n\n    def get_thermostat_mode(self) -&gt; ThermostatMode:\n\"\"\"Return the current thermostat mode.\"\"\"\n        hex_mode = hexlify(self.message[138:139]).decode()\n        states = dict(map(lambda s: (s.value, s), ThermostatMode))\n        return ThermostatMode.COOL if hex_mode not in states else states[hex_mode]\n\n    def get_thermostat_target_temp(self) -&gt; int:\n\"\"\"Return the current temp of the thermostat.\"\"\"\n        hex_temp = hexlify(self.message[139:140]).decode()\n        return int(hex_temp, 16)\n\n    def get_thermostat_fan_level(self) -&gt; ThermostatFanLevel:\n\"\"\"Return the current thermostat fan level.\"\"\"\n        hex_level = hexlify(self.message[140:141]).decode()\n        states = dict(map(lambda s: (s.value, s), ThermostatFanLevel))\n        return states[hex_level[0:1]]\n\n    def get_thermostat_swing(self) -&gt; ThermostatSwing:\n\"\"\"Return the current thermostat fan swing.\"\"\"\n        hex_swing = hexlify(self.message[140:141]).decode()\n\n        return (\n            ThermostatSwing.OFF\n            if hex_swing[1:2] == ThermostatSwing.OFF.value\n            else ThermostatSwing.ON\n        )\n\n    def get_thermostat_remote_id(self) -&gt; str:\n\"\"\"Return the current thermostat remote.\"\"\"\n        return self.message[143:151].decode()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_auto_shutdown","title":"<code>get_auto_shutdown()</code>","text":"<p>Extract the auto shutdown value from the broadcast message.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_auto_shutdown(self) -&gt; str:\n\"\"\"Extract the auto shutdown value from the broadcast message.\"\"\"\n    hex_auto_shutdown_val = hexlify(self.message)[310:318]\n    int_auto_shutdown_val_secs = int(\n        hex_auto_shutdown_val[6:8]\n        + hex_auto_shutdown_val[4:6]\n        + hex_auto_shutdown_val[2:4]\n        + hex_auto_shutdown_val[0:2],\n        16,\n    )\n    return seconds_to_iso_time(int_auto_shutdown_val_secs)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_device_id","title":"<code>get_device_id()</code>","text":"<p>Extract the device id from the broadcast message.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_device_id(self) -&gt; str:\n\"\"\"Extract the device id from the broadcast message.\"\"\"\n    return hexlify(self.message)[36:42].decode()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_device_state","title":"<code>get_device_state()</code>","text":"<p>Extract the device state from the broadcast message.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_device_state(self) -&gt; DeviceState:\n\"\"\"Extract the device state from the broadcast message.\"\"\"\n    hex_device_state = hexlify(self.message)[266:268].decode()\n    return (\n        DeviceState.ON\n        if hex_device_state == DeviceState.ON.value\n        else DeviceState.OFF\n    )\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_device_type","title":"<code>get_device_type()</code>","text":"<p>Extract the device type from the broadcast message.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_device_type(self) -&gt; DeviceType:\n\"\"\"Extract the device type from the broadcast message.\"\"\"\n    hex_model = hexlify(self.message[74:76]).decode()\n    devices = dict(map(lambda d: (d.hex_rep, d), DeviceType))\n    return devices[hex_model]\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_ip_type1","title":"<code>get_ip_type1()</code>","text":"<p>Extract the IP address from the type1 broadcast message (Heater, Plug).</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_ip_type1(self) -&gt; str:\n\"\"\"Extract the IP address from the type1 broadcast message (Heater, Plug).\"\"\"\n    hex_ip = hexlify(self.message)[152:160]\n    ip_addr = int(hex_ip[6:8] + hex_ip[4:6] + hex_ip[2:4] + hex_ip[0:2], 16)\n    return inet_ntoa(pack(\"&lt;L\", ip_addr))\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_ip_type2","title":"<code>get_ip_type2()</code>","text":"<p>Extract the IP address from the broadcast message (Breeze, Runners).</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_ip_type2(self) -&gt; str:\n\"\"\"Extract the IP address from the broadcast message (Breeze, Runners).\"\"\"\n    hex_ip = hexlify(self.message)[154:162]\n    ip_addr = int(hex_ip[0:2] + hex_ip[2:4] + hex_ip[4:6] + hex_ip[6:8], 16)\n    return inet_ntoa(pack(\"&gt;L\", ip_addr))\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_mac","title":"<code>get_mac()</code>","text":"<p>Extract the MAC address from the broadcast message.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_mac(self) -&gt; str:\n\"\"\"Extract the MAC address from the broadcast message.\"\"\"\n    hex_mac = hexlify(self.message)[160:172].decode().upper()\n    return (\n        hex_mac[0:2]\n        + \":\"\n        + hex_mac[2:4]\n        + \":\"\n        + hex_mac[4:6]\n        + \":\"\n        + hex_mac[6:8]\n        + \":\"\n        + hex_mac[8:10]\n        + \":\"\n        + hex_mac[10:12]\n    )\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_name","title":"<code>get_name()</code>","text":"<p>Extract the device name from the broadcast message.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_name(self) -&gt; str:\n\"\"\"Extract the device name from the broadcast message.\"\"\"\n    return self.message[42:74].decode().rstrip(\"\\x00\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_power_consumption","title":"<code>get_power_consumption()</code>","text":"<p>Extract the power consumption from the broadcast message.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_power_consumption(self) -&gt; int:\n\"\"\"Extract the power consumption from the broadcast message.\"\"\"\n    hex_power_consumption = hexlify(self.message)[270:278]\n    return int(hex_power_consumption[2:4] + hex_power_consumption[0:2], 16)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_remaining","title":"<code>get_remaining()</code>","text":"<p>Extract the time remains for the current execution.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_remaining(self) -&gt; str:\n\"\"\"Extract the time remains for the current execution.\"\"\"\n    hex_remaining_time = hexlify(self.message)[294:302]\n    int_remaining_time_seconds = int(\n        hex_remaining_time[6:8]\n        + hex_remaining_time[4:6]\n        + hex_remaining_time[2:4]\n        + hex_remaining_time[0:2],\n        16,\n    )\n    return seconds_to_iso_time(int_remaining_time_seconds)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_shutter_direction","title":"<code>get_shutter_direction()</code>","text":"<p>Return the current direction of the shutter (UP/DOWN/STOP).</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_shutter_direction(self) -&gt; ShutterDirection:\n\"\"\"Return the current direction of the shutter (UP/DOWN/STOP).\"\"\"\n    hex_direction = hexlify(self.message[137:139]).decode()\n    directions = dict(map(lambda d: (d.value, d), ShutterDirection))\n    return directions[hex_direction]\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_shutter_position","title":"<code>get_shutter_position()</code>","text":"<p>Return the current position of the shutter 0 &lt;= pos &lt;= 100.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_shutter_position(self) -&gt; int:\n\"\"\"Return the current position of the shutter 0 &lt;= pos &lt;= 100.\"\"\"\n    hex_pos = hexlify(self.message[135:137]).decode()\n    return int(hex_pos[2:4]) + int(hex_pos[0:2], 16)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_thermostat_fan_level","title":"<code>get_thermostat_fan_level()</code>","text":"<p>Return the current thermostat fan level.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_thermostat_fan_level(self) -&gt; ThermostatFanLevel:\n\"\"\"Return the current thermostat fan level.\"\"\"\n    hex_level = hexlify(self.message[140:141]).decode()\n    states = dict(map(lambda s: (s.value, s), ThermostatFanLevel))\n    return states[hex_level[0:1]]\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_thermostat_mode","title":"<code>get_thermostat_mode()</code>","text":"<p>Return the current thermostat mode.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_thermostat_mode(self) -&gt; ThermostatMode:\n\"\"\"Return the current thermostat mode.\"\"\"\n    hex_mode = hexlify(self.message[138:139]).decode()\n    states = dict(map(lambda s: (s.value, s), ThermostatMode))\n    return ThermostatMode.COOL if hex_mode not in states else states[hex_mode]\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_thermostat_remote_id","title":"<code>get_thermostat_remote_id()</code>","text":"<p>Return the current thermostat remote.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_thermostat_remote_id(self) -&gt; str:\n\"\"\"Return the current thermostat remote.\"\"\"\n    return self.message[143:151].decode()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_thermostat_state","title":"<code>get_thermostat_state()</code>","text":"<p>Return the current thermostat state.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_thermostat_state(self) -&gt; DeviceState:\n\"\"\"Return the current thermostat state.\"\"\"\n    hex_power = hexlify(self.message[137:138]).decode()\n    return DeviceState.ON if hex_power == DeviceState.ON.value else DeviceState.OFF\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_thermostat_swing","title":"<code>get_thermostat_swing()</code>","text":"<p>Return the current thermostat fan swing.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_thermostat_swing(self) -&gt; ThermostatSwing:\n\"\"\"Return the current thermostat fan swing.\"\"\"\n    hex_swing = hexlify(self.message[140:141]).decode()\n\n    return (\n        ThermostatSwing.OFF\n        if hex_swing[1:2] == ThermostatSwing.OFF.value\n        else ThermostatSwing.ON\n    )\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_thermostat_target_temp","title":"<code>get_thermostat_target_temp()</code>","text":"<p>Return the current temp of the thermostat.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_thermostat_target_temp(self) -&gt; int:\n\"\"\"Return the current temp of the thermostat.\"\"\"\n    hex_temp = hexlify(self.message[139:140]).decode()\n    return int(hex_temp, 16)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.get_thermostat_temp","title":"<code>get_thermostat_temp()</code>","text":"<p>Return the current temp of the thermostat.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def get_thermostat_temp(self) -&gt; float:\n\"\"\"Return the current temp of the thermostat.\"\"\"\n    hex_temp = hexlify(self.message[135:137]).decode()\n    return int(hex_temp[2:4] + hex_temp[0:2], 16) / 10\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.DatagramParser.is_switcher_originator","title":"<code>is_switcher_originator()</code>","text":"<p>Verify the broadcast message had originated from a switcher device.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def is_switcher_originator(self) -&gt; bool:\n\"\"\"Verify the broadcast message had originated from a switcher device.\"\"\"\n    return hexlify(self.message)[0:4].decode() == \"fef0\" and (\n        len(self.message) == 165\n        or len(self.message) == 168  # Switcher Breeze\n        or len(self.message) == 159  # Switcher Runner and RunnerMini\n    )\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.SwitcherBridge","title":"<code>SwitcherBridge</code>","text":"<p>Use for running a UDP client for bridging Switcher devices broadcast messages.</p> <p>Parameters:</p> Name Type Description Default <code>on_device</code> <code>Callable[[SwitcherBase], Any]</code> <p>a callable to which every new SwitcherBase device found will be send.</p> required <code>broadcast_ports</code> <code>List[int]</code> <p>broadcast ports list, default for type 1 devices is 20002, default for type 2 devices is 20003. On newer type1 devices, the port is 10002. On newer type2 devices, the port is 10003.</p> <code>[SWITCHER_UDP_PORT_TYPE1, SWITCHER_UDP_PORT_TYPE1_NEW_VERSION, SWITCHER_UDP_PORT_TYPE2, SWITCHER_UDP_PORT_TYPE2_NEW_VERSION]</code> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>@final\nclass SwitcherBridge:\n\"\"\"Use for running a UDP client for bridging Switcher devices broadcast messages.\n\n    Args:\n        on_device: a callable to which every new SwitcherBase device found will be send.\n        broadcast_ports: broadcast ports list, default for type 1 devices is 20002,\n            default for type 2 devices is 20003.\n            On newer type1 devices, the port is 10002.\n            On newer type2 devices, the port is 10003.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        on_device: Callable[[SwitcherBase], Any],\n        broadcast_ports: List[int] = [\n            SWITCHER_UDP_PORT_TYPE1,\n            SWITCHER_UDP_PORT_TYPE1_NEW_VERSION,\n            SWITCHER_UDP_PORT_TYPE2,\n            SWITCHER_UDP_PORT_TYPE2_NEW_VERSION,\n        ],\n    ) -&gt; None:\n\"\"\"Initialize the switcher bridge.\"\"\"\n        self._on_device = on_device\n        self._broadcast_ports = broadcast_ports\n        self._is_running = False\n        self._transports: Dict[int, Optional[BaseTransport]] = {}\n\n    async def __aenter__(self) -&gt; \"SwitcherBridge\":\n\"\"\"Enter SwitcherBridge asynchronous context manager.\"\"\"\n        await self.start()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n\"\"\"Exit the SwitcherBridge asynchronous context manager.\"\"\"\n        await self.stop()\n\n    async def start(self) -&gt; None:\n\"\"\"Create an asynchronous listener and start the bridge.\"\"\"\n        for broadcast_port in self._broadcast_ports:\n            logger.info(\"starting the udp bridge on port %s\", broadcast_port)\n            protocol_factory = UdpClientProtocol(\n                partial(_parse_device_from_datagram, self._on_device)\n            )\n            transport, protocol = await get_running_loop().create_datagram_endpoint(\n                lambda: protocol_factory,\n                local_addr=(\"0.0.0.0\", broadcast_port),  # nosec\n                family=AF_INET,\n            )\n            self._transports[broadcast_port] = transport\n            logger.debug(\"udp bridge on port %s started\", broadcast_port)\n\n        self._is_running = True\n\n    async def stop(self) -&gt; None:\n\"\"\"Stop the asynchronous bridge.\"\"\"\n        for broadcast_port in self._broadcast_ports:\n            transport = self._transports.get(broadcast_port)\n\n            if transport and not transport.is_closing():\n                logger.info(\"stopping the udp bridge on port %s\", broadcast_port)\n                transport.close()\n            else:\n                logger.info(\"udp bridge on port %s not started\", broadcast_port)\n\n        self._is_running = False\n\n    @property\n    def is_running(self) -&gt; bool:\n\"\"\"bool: Return true if bridge is running.\"\"\"\n        return self._is_running\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.SwitcherBridge.is_running","title":"<code>is_running: bool</code>  <code>property</code>","text":"<p>bool: Return true if bridge is running.</p>"},{"location":"codedocs/#src.aioswitcher.bridge.SwitcherBridge.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enter SwitcherBridge asynchronous context manager.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>async def __aenter__(self) -&gt; \"SwitcherBridge\":\n\"\"\"Enter SwitcherBridge asynchronous context manager.\"\"\"\n    await self.start()\n    return self\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.SwitcherBridge.__aexit__","title":"<code>__aexit__(exc_type, exc_value, traceback)</code>  <code>async</code>","text":"<p>Exit the SwitcherBridge asynchronous context manager.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: Optional[Type[BaseException]],\n    exc_value: Optional[BaseException],\n    traceback: Optional[TracebackType],\n) -&gt; None:\n\"\"\"Exit the SwitcherBridge asynchronous context manager.\"\"\"\n    await self.stop()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.SwitcherBridge.__init__","title":"<code>__init__(on_device, broadcast_ports=[SWITCHER_UDP_PORT_TYPE1, SWITCHER_UDP_PORT_TYPE1_NEW_VERSION, SWITCHER_UDP_PORT_TYPE2, SWITCHER_UDP_PORT_TYPE2_NEW_VERSION])</code>","text":"<p>Initialize the switcher bridge.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def __init__(\n    self,\n    on_device: Callable[[SwitcherBase], Any],\n    broadcast_ports: List[int] = [\n        SWITCHER_UDP_PORT_TYPE1,\n        SWITCHER_UDP_PORT_TYPE1_NEW_VERSION,\n        SWITCHER_UDP_PORT_TYPE2,\n        SWITCHER_UDP_PORT_TYPE2_NEW_VERSION,\n    ],\n) -&gt; None:\n\"\"\"Initialize the switcher bridge.\"\"\"\n    self._on_device = on_device\n    self._broadcast_ports = broadcast_ports\n    self._is_running = False\n    self._transports: Dict[int, Optional[BaseTransport]] = {}\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.SwitcherBridge.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Create an asynchronous listener and start the bridge.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>async def start(self) -&gt; None:\n\"\"\"Create an asynchronous listener and start the bridge.\"\"\"\n    for broadcast_port in self._broadcast_ports:\n        logger.info(\"starting the udp bridge on port %s\", broadcast_port)\n        protocol_factory = UdpClientProtocol(\n            partial(_parse_device_from_datagram, self._on_device)\n        )\n        transport, protocol = await get_running_loop().create_datagram_endpoint(\n            lambda: protocol_factory,\n            local_addr=(\"0.0.0.0\", broadcast_port),  # nosec\n            family=AF_INET,\n        )\n        self._transports[broadcast_port] = transport\n        logger.debug(\"udp bridge on port %s started\", broadcast_port)\n\n    self._is_running = True\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.SwitcherBridge.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the asynchronous bridge.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop the asynchronous bridge.\"\"\"\n    for broadcast_port in self._broadcast_ports:\n        transport = self._transports.get(broadcast_port)\n\n        if transport and not transport.is_closing():\n            logger.info(\"stopping the udp bridge on port %s\", broadcast_port)\n            transport.close()\n        else:\n            logger.info(\"udp bridge on port %s not started\", broadcast_port)\n\n    self._is_running = False\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.UdpClientProtocol","title":"<code>UdpClientProtocol</code>","text":"<p>         Bases: <code>DatagramProtocol</code></p> <p>Implementation of the Asyncio UDP DatagramProtocol.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>@final\nclass UdpClientProtocol(DatagramProtocol):\n\"\"\"Implementation of the Asyncio UDP DatagramProtocol.\"\"\"\n\n    def __init__(self, on_datagram: Callable[[bytes], None]) -&gt; None:\n\"\"\"Initialize the protocol.\"\"\"\n        self.transport: Optional[BaseTransport] = None\n        self._on_datagram = on_datagram\n\n    def connection_made(self, transport: BaseTransport) -&gt; None:\n\"\"\"Call on connection established.\"\"\"\n        self.transport = transport\n\n    def datagram_received(self, data: bytes, addr: Tuple[Any, Any]) -&gt; None:\n\"\"\"Call on datagram received.\"\"\"\n        self._on_datagram(data)\n\n    def error_received(self, exc: Optional[Exception]) -&gt; None:\n\"\"\"Call on exception received.\"\"\"\n        if exc:\n            logger.error(f\"udp client received error {exc}\")\n        else:\n            warn(\"udp client received error\")\n\n    def connection_lost(self, exc: Optional[Exception]) -&gt; None:\n\"\"\"Call on connection lost.\"\"\"\n        if exc:\n            logger.critical(f\"udp bridge lost its connection {exc}\")\n        else:\n            logger.info(\"udp connection stopped\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.UdpClientProtocol.__init__","title":"<code>__init__(on_datagram)</code>","text":"<p>Initialize the protocol.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def __init__(self, on_datagram: Callable[[bytes], None]) -&gt; None:\n\"\"\"Initialize the protocol.\"\"\"\n    self.transport: Optional[BaseTransport] = None\n    self._on_datagram = on_datagram\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.UdpClientProtocol.connection_lost","title":"<code>connection_lost(exc)</code>","text":"<p>Call on connection lost.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def connection_lost(self, exc: Optional[Exception]) -&gt; None:\n\"\"\"Call on connection lost.\"\"\"\n    if exc:\n        logger.critical(f\"udp bridge lost its connection {exc}\")\n    else:\n        logger.info(\"udp connection stopped\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.UdpClientProtocol.connection_made","title":"<code>connection_made(transport)</code>","text":"<p>Call on connection established.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def connection_made(self, transport: BaseTransport) -&gt; None:\n\"\"\"Call on connection established.\"\"\"\n    self.transport = transport\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.UdpClientProtocol.datagram_received","title":"<code>datagram_received(data, addr)</code>","text":"<p>Call on datagram received.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def datagram_received(self, data: bytes, addr: Tuple[Any, Any]) -&gt; None:\n\"\"\"Call on datagram received.\"\"\"\n    self._on_datagram(data)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.bridge.UdpClientProtocol.error_received","title":"<code>error_received(exc)</code>","text":"<p>Call on exception received.</p> Source code in <code>src/aioswitcher/bridge.py</code> <pre><code>def error_received(self, exc: Optional[Exception]) -&gt; None:\n\"\"\"Call on exception received.\"\"\"\n    if exc:\n        logger.error(f\"udp client received error {exc}\")\n    else:\n        warn(\"udp client received error\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.DeviceCategory","title":"<code>DeviceCategory</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum for relaying the device category.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@unique\nclass DeviceCategory(Enum):\n\"\"\"Enum for relaying the device category.\"\"\"\n\n    WATER_HEATER = auto()\n    POWER_PLUG = auto()\n    THERMOSTAT = auto()\n    SHUTTER = auto()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.DeviceState","title":"<code>DeviceState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum class representing the device's state.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@unique\nclass DeviceState(Enum):\n\"\"\"Enum class representing the device's state.\"\"\"\n\n    ON = \"01\", \"on\"\n    OFF = \"00\", \"off\"\n\n    def __new__(cls, value: str, display: str) -&gt; \"DeviceState\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n        new_enum = object.__new__(cls)\n        new_enum._value = value  # type: ignore\n        new_enum._display = display  # type: ignore\n        return new_enum\n\n    @property\n    def display(self) -&gt; str:\n\"\"\"Return the display name of the state.\"\"\"\n        return self._display  # type: ignore\n\n    @property\n    def value(self) -&gt; str:\n\"\"\"Return the value of the state.\"\"\"\n        return self._value  # type: ignore\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.DeviceState.display","title":"<code>display: str</code>  <code>property</code>","text":"<p>Return the display name of the state.</p>"},{"location":"codedocs/#src.aioswitcher.device.DeviceState.value","title":"<code>value: str</code>  <code>property</code>","text":"<p>Return the value of the state.</p>"},{"location":"codedocs/#src.aioswitcher.device.DeviceState.__new__","title":"<code>__new__(value, display)</code>","text":"<p>Override the default enum constructor and include extra properties.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>def __new__(cls, value: str, display: str) -&gt; \"DeviceState\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n    new_enum = object.__new__(cls)\n    new_enum._value = value  # type: ignore\n    new_enum._display = display  # type: ignore\n    return new_enum\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.DeviceType","title":"<code>DeviceType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum for relaying the type of the switcher devices.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@unique\nclass DeviceType(Enum):\n\"\"\"Enum for relaying the type of the switcher devices.\"\"\"\n\n    MINI = \"Switcher Mini\", \"030f\", 1, DeviceCategory.WATER_HEATER\n    POWER_PLUG = \"Switcher Power Plug\", \"01a8\", 1, DeviceCategory.POWER_PLUG\n    TOUCH = \"Switcher Touch\", \"030b\", 1, DeviceCategory.WATER_HEATER\n    V2_ESP = \"Switcher V2 (esp)\", \"01a7\", 1, DeviceCategory.WATER_HEATER\n    V2_QCA = \"Switcher V2 (qualcomm)\", \"01a1\", 1, DeviceCategory.WATER_HEATER\n    V4 = \"Switcher V4\", \"0317\", 1, DeviceCategory.WATER_HEATER\n    BREEZE = \"Switcher Breeze\", \"0e01\", 2, DeviceCategory.THERMOSTAT\n    RUNNER = \"Switcher Runner\", \"0c01\", 2, DeviceCategory.SHUTTER\n    RUNNER_MINI = \"Switcher Runner Mini\", \"0c02\", 2, DeviceCategory.SHUTTER\n\n    def __new__(\n        cls, value: str, hex_rep: str, protocol_type: int, category: DeviceCategory\n    ) -&gt; \"DeviceType\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n        new_enum = object.__new__(cls)\n        new_enum._value = value  # type: ignore\n        new_enum._hex_rep = hex_rep  # type: ignore\n        new_enum._protocol_type = protocol_type  # type: ignore\n        new_enum._category = category  # type: ignore\n        return new_enum\n\n    @property\n    def value(self) -&gt; str:\n\"\"\"Return the value of the state.\"\"\"\n        return self._value  # type: ignore\n\n    @property\n    def hex_rep(self) -&gt; str:\n\"\"\"Return the hexadecimal representation of the device type.\"\"\"\n        return self._hex_rep  # type: ignore\n\n    @property\n    def protocol_type(self) -&gt; int:\n\"\"\"Return the protocol type of the device.\"\"\"\n        return self._protocol_type  # type: ignore\n\n    @property\n    def category(self) -&gt; DeviceCategory:\n\"\"\"Return the category of the device type.\"\"\"\n        return self._category  # type: ignore\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.DeviceType.category","title":"<code>category: DeviceCategory</code>  <code>property</code>","text":"<p>Return the category of the device type.</p>"},{"location":"codedocs/#src.aioswitcher.device.DeviceType.hex_rep","title":"<code>hex_rep: str</code>  <code>property</code>","text":"<p>Return the hexadecimal representation of the device type.</p>"},{"location":"codedocs/#src.aioswitcher.device.DeviceType.protocol_type","title":"<code>protocol_type: int</code>  <code>property</code>","text":"<p>Return the protocol type of the device.</p>"},{"location":"codedocs/#src.aioswitcher.device.DeviceType.value","title":"<code>value: str</code>  <code>property</code>","text":"<p>Return the value of the state.</p>"},{"location":"codedocs/#src.aioswitcher.device.DeviceType.__new__","title":"<code>__new__(value, hex_rep, protocol_type, category)</code>","text":"<p>Override the default enum constructor and include extra properties.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>def __new__(\n    cls, value: str, hex_rep: str, protocol_type: int, category: DeviceCategory\n) -&gt; \"DeviceType\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n    new_enum = object.__new__(cls)\n    new_enum._value = value  # type: ignore\n    new_enum._hex_rep = hex_rep  # type: ignore\n    new_enum._protocol_type = protocol_type  # type: ignore\n    new_enum._category = category  # type: ignore\n    return new_enum\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.ShutterDirection","title":"<code>ShutterDirection</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum class representing the shutter device's position.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@final\nclass ShutterDirection(Enum):\n\"\"\"Enum class representing the shutter device's position.\"\"\"\n\n    SHUTTER_STOP = \"0000\", \"stop\"\n    SHUTTER_UP = \"0100\", \"up\"\n    SHUTTER_DOWN = \"0001\", \"down\"\n\n    def __new__(cls, value: str, display: str) -&gt; \"ShutterDirection\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n        new_enum = object.__new__(cls)\n        new_enum._value = value  # type: ignore\n        new_enum._display = display  # type: ignore\n        return new_enum\n\n    @property\n    def display(self) -&gt; str:\n\"\"\"Return the display name of the direction.\"\"\"\n        return self._display  # type: ignore\n\n    @property\n    def value(self) -&gt; str:\n\"\"\"Return the value of the direction.\"\"\"\n        return self._value  # type: ignore\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.ShutterDirection.display","title":"<code>display: str</code>  <code>property</code>","text":"<p>Return the display name of the direction.</p>"},{"location":"codedocs/#src.aioswitcher.device.ShutterDirection.value","title":"<code>value: str</code>  <code>property</code>","text":"<p>Return the value of the direction.</p>"},{"location":"codedocs/#src.aioswitcher.device.ShutterDirection.__new__","title":"<code>__new__(value, display)</code>","text":"<p>Override the default enum constructor and include extra properties.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>def __new__(cls, value: str, display: str) -&gt; \"ShutterDirection\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n    new_enum = object.__new__(cls)\n    new_enum._value = value  # type: ignore\n    new_enum._display = display  # type: ignore\n    return new_enum\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherBase","title":"<code>SwitcherBase</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Abstraction for all switcher devices.</p> <p>Parameters:</p> Name Type Description Default <code>device_type</code> <code>DeviceType</code> <p>the DeviceType appropriate member.</p> required <code>device_state</code> <code>DeviceState</code> <p>the DeviceState appropriate member.</p> required <code>device_id</code> <code>str</code> <p>the id retrieved from the device.</p> required <code>ip_address</code> <code>str</code> <p>the ip address assigned to the device.</p> required <code>mac_address</code> <code>str</code> <p>the mac address assigned to the device.</p> required <code>name</code> <code>str</code> <p>the name of the device.</p> required Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@dataclass\nclass SwitcherBase(ABC):\n\"\"\"Abstraction for all switcher devices.\n\n    Args:\n        device_type: the DeviceType appropriate member.\n        device_state: the DeviceState appropriate member.\n        device_id: the id retrieved from the device.\n        ip_address: the ip address assigned to the device.\n        mac_address: the mac address assigned to the device.\n        name: the name of the device.\n\n    \"\"\"\n\n    device_type: DeviceType\n    device_state: DeviceState\n    device_id: str\n    ip_address: str\n    mac_address: str\n    name: str\n    last_data_update: datetime = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Post initialization, set last_data_update to the instantiation datetime.\"\"\"\n        self.last_data_update = datetime.now()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherBase.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post initialization, set last_data_update to the instantiation datetime.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization, set last_data_update to the instantiation datetime.\"\"\"\n    self.last_data_update = datetime.now()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherPowerBase","title":"<code>SwitcherPowerBase</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Abstraction for all switcher devices reporting power data.</p> <p>Parameters:</p> Name Type Description Default <code>power_consumption</code> <code>int</code> <p>the current power consumption in watts.</p> required <code>electric_current</code> <code>float</code> <p>the current power consumption in amps.</p> required Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@dataclass\nclass SwitcherPowerBase(ABC):\n\"\"\"Abstraction for all switcher devices reporting power data.\n\n    Args:\n        power_consumption: the current power consumption in watts.\n        electric_current: the current power consumption in amps.\n\n    \"\"\"\n\n    power_consumption: int\n    electric_current: float\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherPowerPlug","title":"<code>SwitcherPowerPlug</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SwitcherPowerBase</code>, <code>SwitcherBase</code></p> <p>Implementation of the Switcher Power Plug device.</p> <p>Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@final\n@dataclass\nclass SwitcherPowerPlug(SwitcherPowerBase, SwitcherBase):\n\"\"\"Implementation of the Switcher Power Plug device.\n\n    Please Note the order of the inherited classes to understand the order of the\n    instantiation parameters and the super call.\n    \"\"\"\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Post initialization validate device type category as POWER_PLUG.\"\"\"\n        if self.device_type.category != DeviceCategory.POWER_PLUG:\n            raise ValueError(\"only power plugs are allowed\")\n        super().__post_init__()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherPowerPlug.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post initialization validate device type category as POWER_PLUG.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization validate device type category as POWER_PLUG.\"\"\"\n    if self.device_type.category != DeviceCategory.POWER_PLUG:\n        raise ValueError(\"only power plugs are allowed\")\n    super().__post_init__()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherShutter","title":"<code>SwitcherShutter</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SwitcherShutterBase</code>, <code>SwitcherBase</code></p> <p>Implementation of the Switcher Shutter device.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@final\n@dataclass\nclass SwitcherShutter(SwitcherShutterBase, SwitcherBase):\n\"\"\"Implementation of the Switcher Shutter device.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Post initialization validate device type category as SHUTTER.\"\"\"\n        if self.device_type.category != DeviceCategory.SHUTTER:\n            raise ValueError(\"only shutters are allowed\")\n        return super().__post_init__()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherShutter.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post initialization validate device type category as SHUTTER.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization validate device type category as SHUTTER.\"\"\"\n    if self.device_type.category != DeviceCategory.SHUTTER:\n        raise ValueError(\"only shutters are allowed\")\n    return super().__post_init__()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherShutterBase","title":"<code>SwitcherShutterBase</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Abstraction for all switcher devices controlling shutter.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int</code> <p>the current position of the shutter (integer percentage).</p> required <code>direction</code> <code>ShutterDirection</code> <p>the current direction of the shutter.</p> required Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@dataclass\nclass SwitcherShutterBase(ABC):\n\"\"\"Abstraction for all switcher devices controlling shutter.\n\n    Args:\n        position: the current position of the shutter (integer percentage).\n        direction: the current direction of the shutter.\n    \"\"\"\n\n    position: int\n    direction: ShutterDirection\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherThermostat","title":"<code>SwitcherThermostat</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SwitcherThermostatBase</code>, <code>SwitcherBase</code></p> <p>Implementation of the Switcher Thermostat device.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@final\n@dataclass\nclass SwitcherThermostat(SwitcherThermostatBase, SwitcherBase):\n\"\"\"Implementation of the Switcher Thermostat device.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Post initialization validate device type category as THERMOSTAT.\"\"\"\n        if self.device_type.category != DeviceCategory.THERMOSTAT:\n            raise ValueError(\"only thermostats are allowed\")\n        self.remote = None\n        return super().__post_init__()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherThermostat.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post initialization validate device type category as THERMOSTAT.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization validate device type category as THERMOSTAT.\"\"\"\n    if self.device_type.category != DeviceCategory.THERMOSTAT:\n        raise ValueError(\"only thermostats are allowed\")\n    self.remote = None\n    return super().__post_init__()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherThermostatBase","title":"<code>SwitcherThermostatBase</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Abstraction for switcher thermostat devices.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ThermostatMode</code> <p>the mode of the thermostat.</p> required <code>temperature</code> <code>float</code> <p>the current temperature in celsius.</p> required <code>target_temperature</code> <code>int</code> <p>the current target temperature in celsius.</p> required <code>fan_level</code> <code>ThermostatFanLevel</code> <p>the current fan level in celsius.</p> required <code>swing</code> <code>ThermostatSwing</code> <p>the current swing state.</p> required <code>remote_id</code> <code>str</code> <p>the id of the remote used to control this thermostat</p> required Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@dataclass\nclass SwitcherThermostatBase(ABC):\n\"\"\"Abstraction for switcher thermostat devices.\n\n    Args:\n        mode: the mode of the thermostat.\n        temperature: the current temperature in celsius.\n        target_temperature: the current target temperature in celsius.\n        fan_level: the current fan level in celsius.\n        swing: the current swing state.\n        remote_id: the id of the remote used to control this thermostat\n    \"\"\"\n\n    mode: ThermostatMode\n    temperature: float\n    target_temperature: int\n    fan_level: ThermostatFanLevel\n    swing: ThermostatSwing\n    remote_id: str\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherTimedBase","title":"<code>SwitcherTimedBase</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Abstraction for all switcher devices supporting timed operations.</p> <p>Parameters:</p> Name Type Description Default <code>remaining_time</code> <code>str</code> <p>remaining time to current run.</p> required <code>auto_shutdown</code> <code>str</code> <p>configured value for auto shutdown.</p> required Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@dataclass\nclass SwitcherTimedBase(ABC):\n\"\"\"Abstraction for all switcher devices supporting timed operations.\n\n    Args:\n        remaining_time: remaining time to current run.\n        auto_shutdown: configured value for auto shutdown.\n\n    \"\"\"\n\n    remaining_time: str\n    auto_shutdown: str\n\n    @property\n    def auto_off_set(self) -&gt; str:\n\"\"\"Fix for backward compatibility issues with home assistant.\"\"\"\n        return self.auto_shutdown\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherTimedBase.auto_off_set","title":"<code>auto_off_set: str</code>  <code>property</code>","text":"<p>Fix for backward compatibility issues with home assistant.</p>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherWaterHeater","title":"<code>SwitcherWaterHeater</code>  <code>dataclass</code>","text":"<p>         Bases: <code>SwitcherTimedBase</code>, <code>SwitcherPowerBase</code>, <code>SwitcherBase</code></p> <p>Implementation of the Switcher Water Heater device.</p> <p>Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>@final\n@dataclass\nclass SwitcherWaterHeater(SwitcherTimedBase, SwitcherPowerBase, SwitcherBase):\n\"\"\"Implementation of the Switcher Water Heater device.\n\n    Please Note the order of the inherited classes to understand the order of the\n    instantiation parameters and the super call.\n    \"\"\"\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Post initialization validate device type category as WATER_HEATER.\"\"\"\n        if self.device_type.category != DeviceCategory.WATER_HEATER:\n            raise ValueError(\"only water heaters are allowed\")\n        super().__post_init__()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.SwitcherWaterHeater.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post initialization validate device type category as WATER_HEATER.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization validate device type category as WATER_HEATER.\"\"\"\n    if self.device_type.category != DeviceCategory.WATER_HEATER:\n        raise ValueError(\"only water heaters are allowed\")\n    super().__post_init__()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.ThermostatFanLevel","title":"<code>ThermostatFanLevel</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum class representing the thermostat device's fan level.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>class ThermostatFanLevel(Enum):\n\"\"\"Enum class representing the thermostat device's fan level.\"\"\"\n\n    LOW = \"1\", \"low\"\n    MEDIUM = \"2\", \"medium\"\n    HIGH = \"3\", \"high\"\n    AUTO = \"0\", \"auto\"\n\n    def __new__(cls, value: str, display: str) -&gt; \"ThermostatFanLevel\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n        new_enum = object.__new__(cls)\n        new_enum._value = value  # type: ignore\n        new_enum._display = display  # type: ignore\n        return new_enum\n\n    @property\n    def display(self) -&gt; str:\n\"\"\"Return the display name of the fan level.\"\"\"\n        return self._display  # type: ignore\n\n    @property\n    def value(self) -&gt; str:\n\"\"\"Return the value of the fan level.\"\"\"\n        return self._value  # type: ignore\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.ThermostatFanLevel.display","title":"<code>display: str</code>  <code>property</code>","text":"<p>Return the display name of the fan level.</p>"},{"location":"codedocs/#src.aioswitcher.device.ThermostatFanLevel.value","title":"<code>value: str</code>  <code>property</code>","text":"<p>Return the value of the fan level.</p>"},{"location":"codedocs/#src.aioswitcher.device.ThermostatFanLevel.__new__","title":"<code>__new__(value, display)</code>","text":"<p>Override the default enum constructor and include extra properties.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>def __new__(cls, value: str, display: str) -&gt; \"ThermostatFanLevel\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n    new_enum = object.__new__(cls)\n    new_enum._value = value  # type: ignore\n    new_enum._display = display  # type: ignore\n    return new_enum\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.ThermostatMode","title":"<code>ThermostatMode</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum class representing the thermostat device's position.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>class ThermostatMode(Enum):\n\"\"\"Enum class representing the thermostat device's position.\"\"\"\n\n    AUTO = \"01\", \"auto\"\n    DRY = \"02\", \"dry\"\n    FAN = \"03\", \"fan\"\n    COOL = \"04\", \"cool\"\n    HEAT = \"05\", \"heat\"\n\n    def __new__(cls, value: str, display: str) -&gt; \"ThermostatMode\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n        new_enum = object.__new__(cls)\n        new_enum._value = value  # type: ignore\n        new_enum._display = display  # type: ignore\n        return new_enum\n\n    @property\n    def display(self) -&gt; str:\n\"\"\"Return the display name of the mode.\"\"\"\n        return self._display  # type: ignore\n\n    @property\n    def value(self) -&gt; str:\n\"\"\"Return the value of the mode.\"\"\"\n        return self._value  # type: ignore\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.ThermostatMode.display","title":"<code>display: str</code>  <code>property</code>","text":"<p>Return the display name of the mode.</p>"},{"location":"codedocs/#src.aioswitcher.device.ThermostatMode.value","title":"<code>value: str</code>  <code>property</code>","text":"<p>Return the value of the mode.</p>"},{"location":"codedocs/#src.aioswitcher.device.ThermostatMode.__new__","title":"<code>__new__(value, display)</code>","text":"<p>Override the default enum constructor and include extra properties.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>def __new__(cls, value: str, display: str) -&gt; \"ThermostatMode\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n    new_enum = object.__new__(cls)\n    new_enum._value = value  # type: ignore\n    new_enum._display = display  # type: ignore\n    return new_enum\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.ThermostatSwing","title":"<code>ThermostatSwing</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum class representing the thermostat device's swing state.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>class ThermostatSwing(Enum):\n\"\"\"Enum class representing the thermostat device's swing state.\"\"\"\n\n    OFF = \"0\", \"off\"\n    ON = \"1\", \"on\"\n\n    def __new__(cls, value: str, display: str) -&gt; \"ThermostatSwing\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n        new_enum = object.__new__(cls)\n        new_enum._value = value  # type: ignore\n        new_enum._display = display  # type: ignore\n        return new_enum\n\n    @property\n    def display(self) -&gt; str:\n\"\"\"Return the display name of the swing.\"\"\"\n        return self._display  # type: ignore\n\n    @property\n    def value(self) -&gt; str:\n\"\"\"Return the value of the swing.\"\"\"\n        return self._value  # type: ignore\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.ThermostatSwing.display","title":"<code>display: str</code>  <code>property</code>","text":"<p>Return the display name of the swing.</p>"},{"location":"codedocs/#src.aioswitcher.device.ThermostatSwing.value","title":"<code>value: str</code>  <code>property</code>","text":"<p>Return the value of the swing.</p>"},{"location":"codedocs/#src.aioswitcher.device.ThermostatSwing.__new__","title":"<code>__new__(value, display)</code>","text":"<p>Override the default enum constructor and include extra properties.</p> Source code in <code>src/aioswitcher/device/__init__.py</code> <pre><code>def __new__(cls, value: str, display: str) -&gt; \"ThermostatSwing\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n    new_enum = object.__new__(cls)\n    new_enum._value = value  # type: ignore\n    new_enum._display = display  # type: ignore\n    return new_enum\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.tools.current_timestamp_to_hexadecimal","title":"<code>current_timestamp_to_hexadecimal()</code>","text":"<p>Generate hexadecimal representation of the current timestamp.</p> Return <p>Hexadecimal representation of the current unix time retrieved by <code>time.time</code>.</p> Source code in <code>src/aioswitcher/device/tools.py</code> <pre><code>def current_timestamp_to_hexadecimal() -&gt; str:\n\"\"\"Generate hexadecimal representation of the current timestamp.\n\n    Return:\n        Hexadecimal representation of the current unix time retrieved by ``time.time``.\n\n    \"\"\"\n    round_timestamp = int(round(time.time()))\n    binary_timestamp = pack(\"&lt;I\", round_timestamp)\n    hex_timestamp = hexlify(binary_timestamp)\n    return hex_timestamp.decode()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.tools.minutes_to_hexadecimal_seconds","title":"<code>minutes_to_hexadecimal_seconds(minutes)</code>","text":"<p>Encode minutes to an hexadecimal packed as little endian unsigned int.</p> <p>Parameters:</p> Name Type Description Default <code>minutes</code> <code>int</code> <p>minutes to encode.</p> required Return <p>Hexadecimal representation of the minutes argument.</p> Source code in <code>src/aioswitcher/device/tools.py</code> <pre><code>def minutes_to_hexadecimal_seconds(minutes: int) -&gt; str:\n\"\"\"Encode minutes to an hexadecimal packed as little endian unsigned int.\n\n    Args:\n        minutes: minutes to encode.\n\n    Return:\n        Hexadecimal representation of the minutes argument.\n\n    \"\"\"\n    return hexlify(pack(\"&lt;I\", minutes * 60)).decode()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.tools.seconds_to_iso_time","title":"<code>seconds_to_iso_time(all_seconds)</code>","text":"<p>Convert seconds to iso time.</p> <p>Parameters:</p> Name Type Description Default <code>all_seconds</code> <code>int</code> <p>the total number of seconds to convert.</p> required Return <p>A string representing the converted iso time in %H:%M:%S format. e.g. \"02:24:37\".</p> Source code in <code>src/aioswitcher/device/tools.py</code> <pre><code>def seconds_to_iso_time(all_seconds: int) -&gt; str:\n\"\"\"Convert seconds to iso time.\n\n    Args:\n        all_seconds: the total number of seconds to convert.\n\n    Return:\n        A string representing the converted iso time in %H:%M:%S format.\n        e.g. \"02:24:37\".\n\n    \"\"\"\n    minutes, seconds = divmod(int(all_seconds), 60)\n    hours, minutes = divmod(minutes, 60)\n\n    return datetime.time(hour=hours, minute=minutes, second=seconds).isoformat()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.tools.set_message_length","title":"<code>set_message_length(message)</code>","text":"<p>Set the message length.</p> Source code in <code>src/aioswitcher/device/tools.py</code> <pre><code>def set_message_length(message: str) -&gt; str:\n\"\"\"Set the message length.\"\"\"\n    length = \"{:x}\".format(len(unhexlify(message + \"00000000\"))).ljust(4, \"0\")\n    return \"fef0\" + str(length) + message[8:]\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.tools.sign_packet_with_crc_key","title":"<code>sign_packet_with_crc_key(hex_packet)</code>","text":"<p>Sign the packets with the designated crc key.</p> <p>Parameters:</p> Name Type Description Default <code>hex_packet</code> <code>str</code> <p>packet to sign.</p> required Return <p>The calculated and signed packet.</p> Source code in <code>src/aioswitcher/device/tools.py</code> <pre><code>def sign_packet_with_crc_key(hex_packet: str) -&gt; str:\n\"\"\"Sign the packets with the designated crc key.\n\n    Args:\n        hex_packet: packet to sign.\n\n    Return:\n        The calculated and signed packet.\n\n    \"\"\"\n    binary_packet = unhexlify(hex_packet)\n    binary_packet_crc = pack(\"&gt;I\", crc_hqx(binary_packet, 0x1021))\n    hex_packet_crc = hexlify(binary_packet_crc).decode()\n    hex_packet_crc_sliced = hex_packet_crc[6:8] + hex_packet_crc[4:6]\n\n    binary_key = unhexlify(hex_packet_crc_sliced + \"30\" * 32)\n    binary_key_crc = pack(\"&gt;I\", crc_hqx(binary_key, 0x1021))\n    hex_key_crc = hexlify(binary_key_crc).decode()\n    hex_key_crc_sliced = hex_key_crc[6:8] + hex_key_crc[4:6]\n\n    return hex_packet + hex_packet_crc_sliced + hex_key_crc_sliced\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.tools.string_to_hexadecimale_device_name","title":"<code>string_to_hexadecimale_device_name(name)</code>","text":"<p>Encode string device name to an appropriate hexadecimal value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the desired name for encoding.</p> required Return <p>Hexadecimal representation of the name argument.</p> Source code in <code>src/aioswitcher/device/tools.py</code> <pre><code>def string_to_hexadecimale_device_name(name: str) -&gt; str:\n\"\"\"Encode string device name to an appropriate hexadecimal value.\n\n    Args:\n        name: the desired name for encoding.\n\n    Return:\n        Hexadecimal representation of the name argument.\n\n    \"\"\"\n    length = len(name)\n    if 1 &lt; length &lt; 33:\n        hex_name = hexlify(name.encode())\n        zeros_pad = (\"00\" * (32 - length)).encode()\n        return (hex_name + zeros_pad).decode()\n    raise ValueError(\"name length can vary from 2 to 32\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.tools.timedelta_to_hexadecimal_seconds","title":"<code>timedelta_to_hexadecimal_seconds(full_time)</code>","text":"<p>Encode timedelta as seconds to an hexadecimal packed as little endian unsigned.</p> <p>Parameters:</p> Name Type Description Default <code>full_time</code> <code>datetime.timedelta</code> <p>timedelta time between 1 and 24 hours, seconds are ignored.</p> required Return <p>Hexadecimal representation of the seconds built fom the full_time argument.</p> Source code in <code>src/aioswitcher/device/tools.py</code> <pre><code>def timedelta_to_hexadecimal_seconds(full_time: datetime.timedelta) -&gt; str:\n\"\"\"Encode timedelta as seconds to an hexadecimal packed as little endian unsigned.\n\n    Args:\n        full_time: timedelta time between 1 and 24 hours, seconds are ignored.\n\n    Return:\n        Hexadecimal representation of the seconds built fom the full_time argument.\n\n    \"\"\"\n    minutes = full_time.total_seconds() / 60\n    hours, minutes = divmod(minutes, 60)\n    seconds = int(hours) * 3600 + int(minutes) * 60\n\n    if 3599 &lt; seconds &lt; 86341:\n        return hexlify(pack(\"&lt;I\", int(seconds))).decode()\n\n    raise ValueError(\"can only handle 1 to 24 hours\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.device.tools.watts_to_amps","title":"<code>watts_to_amps(watts)</code>","text":"<p>Convert power consumption to watts to electric current in amps.</p> Source code in <code>src/aioswitcher/device/tools.py</code> <pre><code>def watts_to_amps(watts: int) -&gt; float:\n\"\"\"Convert power consumption to watts to electric current in amps.\"\"\"\n    return round((watts / float(220)), 1)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.Days","title":"<code>Days</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum class representing the day entity.</p> Source code in <code>src/aioswitcher/schedule/__init__.py</code> <pre><code>@unique\nclass Days(Enum):\n\"\"\"Enum class representing the day entity.\"\"\"\n\n    MONDAY = (\"Monday\", 0x02, 2, 0)\n    TUESDAY = (\"Tuesday\", 0x04, 4, 1)\n    WEDNESDAY = (\"Wednesday\", 0x08, 8, 2)\n    THURSDAY = (\"Thursday\", 0x10, 16, 3)\n    FRIDAY = (\"Friday\", 0x20, 32, 4)\n    SATURDAY = (\"Saturday\", 0x40, 64, 5)\n    SUNDAY = (\"Sunday\", 0x80, 128, 6)\n\n    def __new__(cls, value: str, hex_rep: int, bit_rep: int, weekday: int) -&gt; \"Days\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n        new_enum = object.__new__(cls)\n        new_enum._value_ = value\n        new_enum._hex_rep = hex_rep  # type: ignore\n        new_enum._bit_rep = bit_rep  # type: ignore\n        new_enum._weekday = weekday  # type: ignore\n        return new_enum\n\n    @property\n    def bit_rep(self) -&gt; int:\n\"\"\"Return the bit representation of the day.\"\"\"\n        return self._bit_rep  # type: ignore\n\n    @property\n    def hex_rep(self) -&gt; int:\n\"\"\"Return the hexadecimal representation of the day.\"\"\"\n        return self._hex_rep  # type: ignore\n\n    @property\n    def weekday(self) -&gt; int:\n\"\"\"Return the weekday of the day.\"\"\"\n        return self._weekday  # type: ignore\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.Days.bit_rep","title":"<code>bit_rep: int</code>  <code>property</code>","text":"<p>Return the bit representation of the day.</p>"},{"location":"codedocs/#src.aioswitcher.schedule.Days.hex_rep","title":"<code>hex_rep: int</code>  <code>property</code>","text":"<p>Return the hexadecimal representation of the day.</p>"},{"location":"codedocs/#src.aioswitcher.schedule.Days.weekday","title":"<code>weekday: int</code>  <code>property</code>","text":"<p>Return the weekday of the day.</p>"},{"location":"codedocs/#src.aioswitcher.schedule.Days.__new__","title":"<code>__new__(value, hex_rep, bit_rep, weekday)</code>","text":"<p>Override the default enum constructor and include extra properties.</p> Source code in <code>src/aioswitcher/schedule/__init__.py</code> <pre><code>def __new__(cls, value: str, hex_rep: int, bit_rep: int, weekday: int) -&gt; \"Days\":\n\"\"\"Override the default enum constructor and include extra properties.\"\"\"\n    new_enum = object.__new__(cls)\n    new_enum._value_ = value\n    new_enum._hex_rep = hex_rep  # type: ignore\n    new_enum._bit_rep = bit_rep  # type: ignore\n    new_enum._weekday = weekday  # type: ignore\n    return new_enum\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.ScheduleState","title":"<code>ScheduleState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum representing the status of the schedule.</p> Source code in <code>src/aioswitcher/schedule/__init__.py</code> <pre><code>@unique\nclass ScheduleState(Enum):\n\"\"\"Enum representing the status of the schedule.\"\"\"\n\n    ENABLED = \"01\"\n    DISABLED = \"00\"\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.ScheduleParser","title":"<code>ScheduleParser</code>  <code>dataclass</code>","text":"<p>Schedule parsing tool.</p> Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>@final\n@dataclass(frozen=True)\nclass ScheduleParser:\n\"\"\"Schedule parsing tool.\"\"\"\n\n    schedule: bytes\n\n    def get_id(self) -&gt; str:\n\"\"\"Return the id of the schedule.\"\"\"\n        return str(int(self.schedule[0:2], 16))\n\n    def is_enabled(self) -&gt; bool:\n\"\"\"Return true if enbaled.\"\"\"\n        return int(self.schedule[2:4], 16) == 1\n\n    def is_recurring(self) -&gt; bool:\n\"\"\"Return true if a recurring schedule.\"\"\"\n        return self.schedule[4:6] != b\"00\"\n\n    def get_days(self) -&gt; Set[Days]:\n\"\"\"Retun a set of the scheduled Days.\"\"\"\n        return (\n            tools.bit_summary_to_days(int(self.schedule[4:6], 16))\n            if self.is_recurring()\n            else set()\n        )\n\n    def get_state(self) -&gt; ScheduleState:\n\"\"\"Return the current state of the device.\n\n        Not sure if this needs to be included in the schedule object.\n        \"\"\"\n        return ScheduleState(self.schedule[6:8].decode())\n\n    def get_start_time(self) -&gt; str:\n\"\"\"Return the schedule start time in %H:%M format.\"\"\"\n        return tools.hexadecimale_timestamp_to_localtime(self.schedule[8:16])\n\n    def get_end_time(self) -&gt; str:\n\"\"\"Return the schedule end time in %H:%M format.\"\"\"\n        return tools.hexadecimale_timestamp_to_localtime(self.schedule[16:24])\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.ScheduleParser.get_days","title":"<code>get_days()</code>","text":"<p>Retun a set of the scheduled Days.</p> Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>def get_days(self) -&gt; Set[Days]:\n\"\"\"Retun a set of the scheduled Days.\"\"\"\n    return (\n        tools.bit_summary_to_days(int(self.schedule[4:6], 16))\n        if self.is_recurring()\n        else set()\n    )\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.ScheduleParser.get_end_time","title":"<code>get_end_time()</code>","text":"<p>Return the schedule end time in %H:%M format.</p> Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>def get_end_time(self) -&gt; str:\n\"\"\"Return the schedule end time in %H:%M format.\"\"\"\n    return tools.hexadecimale_timestamp_to_localtime(self.schedule[16:24])\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.ScheduleParser.get_id","title":"<code>get_id()</code>","text":"<p>Return the id of the schedule.</p> Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>def get_id(self) -&gt; str:\n\"\"\"Return the id of the schedule.\"\"\"\n    return str(int(self.schedule[0:2], 16))\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.ScheduleParser.get_start_time","title":"<code>get_start_time()</code>","text":"<p>Return the schedule start time in %H:%M format.</p> Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>def get_start_time(self) -&gt; str:\n\"\"\"Return the schedule start time in %H:%M format.\"\"\"\n    return tools.hexadecimale_timestamp_to_localtime(self.schedule[8:16])\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.ScheduleParser.get_state","title":"<code>get_state()</code>","text":"<p>Return the current state of the device.</p> <p>Not sure if this needs to be included in the schedule object.</p> Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>def get_state(self) -&gt; ScheduleState:\n\"\"\"Return the current state of the device.\n\n    Not sure if this needs to be included in the schedule object.\n    \"\"\"\n    return ScheduleState(self.schedule[6:8].decode())\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.ScheduleParser.is_enabled","title":"<code>is_enabled()</code>","text":"<p>Return true if enbaled.</p> Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>def is_enabled(self) -&gt; bool:\n\"\"\"Return true if enbaled.\"\"\"\n    return int(self.schedule[2:4], 16) == 1\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.ScheduleParser.is_recurring","title":"<code>is_recurring()</code>","text":"<p>Return true if a recurring schedule.</p> Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>def is_recurring(self) -&gt; bool:\n\"\"\"Return true if a recurring schedule.\"\"\"\n    return self.schedule[4:6] != b\"00\"\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.SwitcherSchedule","title":"<code>SwitcherSchedule</code>  <code>dataclass</code>","text":"<p>representation of the Switcher schedule slot.</p> <p>Parameters:</p> Name Type Description Default <code>schedule_id</code> <code>str</code> <p>the id of the schedule</p> required <code>recurring</code> <code>bool</code> <p>is a recurring schedule</p> required <code>days</code> <code>Set[Days]</code> <p>a set of schedule days, or empty set for non recurring schedules</p> required <code>start_time</code> <code>str</code> <p>the start time of the schedule</p> required <code>end_time</code> <code>str</code> <p>the end time of the schedule</p> required Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>@final\n@dataclass\nclass SwitcherSchedule:\n\"\"\"representation of the Switcher schedule slot.\n\n    Args:\n        schedule_id: the id of the schedule\n        recurring: is a recurring schedule\n        days: a set of schedule days, or empty set for non recurring schedules\n        start_time: the start time of the schedule\n        end_time: the end time of the schedule\n\n    \"\"\"\n\n    schedule_id: str\n    recurring: bool\n    days: Set[Days]\n    start_time: str\n    end_time: str\n    duration: str = field(init=False)\n    display: str = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Post initialization, set duration and display.\"\"\"\n        self.duration = tools.calc_duration(self.start_time, self.end_time)\n        self.display = tools.pretty_next_run(self.start_time, self.days)\n\n    def __hash__(self) -&gt; int:\n\"\"\"For usage with set, implementation of the __hash__ magic method.\"\"\"\n        return hash(self.schedule_id)\n\n    def __eq__(self, obj: object) -&gt; bool:\n\"\"\"For usage with set, implementation of the __eq__ magic method.\"\"\"\n        if isinstance(obj, SwitcherSchedule):\n            return self.schedule_id == obj.schedule_id\n        return False\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.SwitcherSchedule.__eq__","title":"<code>__eq__(obj)</code>","text":"<p>For usage with set, implementation of the eq magic method.</p> Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>def __eq__(self, obj: object) -&gt; bool:\n\"\"\"For usage with set, implementation of the __eq__ magic method.\"\"\"\n    if isinstance(obj, SwitcherSchedule):\n        return self.schedule_id == obj.schedule_id\n    return False\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.SwitcherSchedule.__hash__","title":"<code>__hash__()</code>","text":"<p>For usage with set, implementation of the hash magic method.</p> Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"For usage with set, implementation of the __hash__ magic method.\"\"\"\n    return hash(self.schedule_id)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.SwitcherSchedule.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post initialization, set duration and display.</p> Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization, set duration and display.\"\"\"\n    self.duration = tools.calc_duration(self.start_time, self.end_time)\n    self.display = tools.pretty_next_run(self.start_time, self.days)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.parser.get_schedules","title":"<code>get_schedules(message)</code>","text":"<p>Use to create a list of schedule from a response message from the device.</p> Source code in <code>src/aioswitcher/schedule/parser.py</code> <pre><code>def get_schedules(message: bytes) -&gt; Set[SwitcherSchedule]:\n\"\"\"Use to create a list of schedule from a response message from the device.\"\"\"\n    hex_data = hexlify(message)[90:-8].decode()\n    hex_data_split = wrap(hex_data, 32)\n    ret_set = set()\n    for schedule in hex_data_split:\n        parser = ScheduleParser(schedule.encode())\n        ret_set.add(\n            SwitcherSchedule(\n                parser.get_id(),\n                parser.is_recurring(),\n                parser.get_days(),\n                parser.get_start_time(),\n                parser.get_end_time(),\n            )\n        )\n    return ret_set\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.tools.bit_summary_to_days","title":"<code>bit_summary_to_days(sum_weekdays_bit)</code>","text":"<p>Decode a weekdays bit summary to a set of weekdays.</p> <p>Parameters:</p> Name Type Description Default <code>sum_weekdays_bit</code> <code>int</code> <p>the sum of all weekdays</p> required Return <p>Set of Weekday members decoded from the summary value.</p> Todo <p>Should an existing remainder in the sum value throw an error? E.g. 3 will result in a set of MONDAY and the remainder will be 1.</p> Source code in <code>src/aioswitcher/schedule/tools.py</code> <pre><code>def bit_summary_to_days(sum_weekdays_bit: int) -&gt; Set[Days]:\n\"\"\"Decode a weekdays bit summary to a set of weekdays.\n\n    Args:\n        sum_weekdays_bit: the sum of all weekdays\n\n    Return:\n        Set of Weekday members decoded from the summary value.\n\n    Todo:\n        Should an existing remainder in the sum value throw an error?\n        E.g. 3 will result in a set of MONDAY and the remainder will be 1.\n\n    \"\"\"\n    if 1 &lt; sum_weekdays_bit &lt; 255:\n        return_weekdays = set()\n        weekdays_by_hex = map(lambda w: (w.hex_rep, w), Days)\n        for weekday_hex in weekdays_by_hex:\n            if weekday_hex[0] &amp; sum_weekdays_bit != 0:\n                return_weekdays.add(weekday_hex[1])\n        return return_weekdays\n    raise ValueError(\"weekdays bit sum should be between 2 and 254\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.tools.calc_duration","title":"<code>calc_duration(start_time, end_time)</code>","text":"<p>Use to calculate the delta between two time values formated as %H:%M.</p> Source code in <code>src/aioswitcher/schedule/tools.py</code> <pre><code>def calc_duration(start_time: str, end_time: str) -&gt; str:\n\"\"\"Use to calculate the delta between two time values formated as %H:%M.\"\"\"\n    start_datetime = datetime.strptime(start_time, \"%H:%M\")\n    end_datetime = datetime.strptime(end_time, \"%H:%M\")\n    if end_datetime &gt; start_datetime:\n        return str(end_datetime - start_datetime)\n    raise ValueError(\"end_time should be greater the start_time\")\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.tools.hexadecimale_timestamp_to_localtime","title":"<code>hexadecimale_timestamp_to_localtime(hex_timestamp)</code>","text":"<p>Decode an hexadecimale timestamp to localtime with the format %H:%M.</p> <p>Parameters:</p> Name Type Description Default <code>hex_timestamp</code> <code>bytes</code> <p>the hexadecimale timestamp.</p> required Return <p>Localtime string with %H:%M format. e.g. \"20:30\".</p> Source code in <code>src/aioswitcher/schedule/tools.py</code> <pre><code>def hexadecimale_timestamp_to_localtime(hex_timestamp: bytes) -&gt; str:\n\"\"\"Decode an hexadecimale timestamp to localtime with the format %H:%M.\n\n    Args:\n        hex_timestamp: the hexadecimale timestamp.\n\n    Return:\n        Localtime string with %H:%M format. e.g. \"20:30\".\n    \"\"\"\n    hex_time = (\n        hex_timestamp[6:8]\n        + hex_timestamp[4:6]\n        + hex_timestamp[2:4]\n        + hex_timestamp[0:2]\n    )\n    int_time = int(hex_time, 16)\n    local_time = time.localtime(int_time)\n    return time.strftime(\"%H:%M\", local_time)\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.tools.pretty_next_run","title":"<code>pretty_next_run(start_time, days=set())</code>","text":"<p>Create a literal for displaying the next run time.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>str</code> <p>the start of the schedule in \"%H:%M\" format, e.g. \"17:00\".</p> required <code>days</code> <code>Set[Days]</code> <p>for recurring schedules, a list of days when none, will be today.</p> <code>set()</code> <p>Returns:</p> Type Description <code>str</code> <p>A pretty string describing the next due run.</p> <code>str</code> <p>e.g. \"Due next Sunday at 17:00\".</p> Source code in <code>src/aioswitcher/schedule/tools.py</code> <pre><code>def pretty_next_run(start_time: str, days: Set[Days] = set()) -&gt; str:\n\"\"\"Create a literal for displaying the next run time.\n\n    Args:\n        start_time: the start of the schedule in \"%H:%M\" format, e.g. \"17:00\".\n        days: for recurring schedules, a list of days when none, will be today.\n\n    Returns:\n        A pretty string describing the next due run.\n        e.g. \"Due next Sunday at 17:00\".\n\n    \"\"\"\n    if not days:\n        return f\"Due today at {start_time}\"\n\n    current_datetime = datetime.utcnow()\n    current_weekday = current_datetime.weekday()\n\n    current_time = datetime.strptime(\n        current_datetime.time().strftime(\"%H:%M\"), \"%H:%M\"\n    ).time()\n    schedule_time = datetime.strptime(start_time, \"%H:%M\").time()\n\n    execution_days = [d.weekday for d in days]\n    # if scheduled for later on today, return \"due today\"\n    if current_weekday in execution_days and current_time &lt; schedule_time:\n        return f\"Due today at {start_time}\"\n\n    execution_days.sort()\n    if current_weekday &gt; execution_days[-1]:\n        next_exc_day = execution_days[0]\n    else:\n        next_exc_day = list(filter(lambda d: d &gt;= current_weekday, execution_days))[0]\n\n    # if next excution day is tomorrow for the current day, or this is the week end\n    # (today is sunday and tomorrow is monday)  return \"due tomorrow\"\n    if next_exc_day - 1 == current_weekday or (\n        next_exc_day == Days.MONDAY.weekday and current_weekday == Days.SUNDAY.weekday\n    ):\n        return f\"Due tomorrow at {start_time}\"\n\n    # if here, then the scuedle is due some other day this week, return \"due at...\"\n    weekdays = dict(map(lambda d: (d.weekday, d), Days))\n    return f\"Due next {weekdays[next_exc_day].value} at {start_time}\"\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.tools.time_to_hexadecimal_timestamp","title":"<code>time_to_hexadecimal_timestamp(time_value)</code>","text":"<p>Convert hours and minutes to a timestamp with the current date and encode.</p> <p>Parameters:</p> Name Type Description Default <code>time_value</code> <code>str</code> <p>time to convert. e.g. \"21:00\".</p> required Return <p>Hexadecimal representation of the timestamp.</p> Source code in <code>src/aioswitcher/schedule/tools.py</code> <pre><code>def time_to_hexadecimal_timestamp(time_value: str) -&gt; str:\n\"\"\"Convert hours and minutes to a timestamp with the current date and encode.\n\n    Args:\n        time_value: time to convert. e.g. \"21:00\".\n\n    Return:\n        Hexadecimal representation of the timestamp.\n\n    \"\"\"\n    tsplit = time_value.split(\":\")\n    str_timedate = time.strftime(\"%d/%m/%Y\") + \" \" + tsplit[0] + \":\" + tsplit[1]\n    struct_timedate = time.strptime(str_timedate, \"%d/%m/%Y %H:%M\")\n    timestamp = time.mktime(struct_timedate)\n    binary_timestamp = pack(\"&lt;I\", int(timestamp))\n\n    return hexlify(binary_timestamp).decode()\n</code></pre>"},{"location":"codedocs/#src.aioswitcher.schedule.tools.weekdays_to_hexadecimal","title":"<code>weekdays_to_hexadecimal(days)</code>","text":"<p>Sum the requested weekdays bit representation and return as hexadecimal value.</p> <p>Parameters:</p> Name Type Description Default <code>days</code> <code>Union[Days, Set[Days]]</code> <p>the requested Weekday members.</p> required Return <p>Hexadecimale representation of the sum of all requested days.</p> Source code in <code>src/aioswitcher/schedule/tools.py</code> <pre><code>def weekdays_to_hexadecimal(days: Union[Days, Set[Days]]) -&gt; str:\n\"\"\"Sum the requested weekdays bit representation and return as hexadecimal value.\n\n    Args:\n        days: the requested Weekday members.\n\n    Return:\n        Hexadecimale representation of the sum of all requested days.\n\n    \"\"\"\n    if days:\n        if type(days) is Days:\n            return \"{:02x}\".format(days.bit_rep)\n        elif type(days) is set or len(days) == len(set(days)):  # type: ignore\n            map_to_bits = map(lambda w: w.bit_rep, days)  # type: ignore\n            return \"{:02x}\".format(int(sum(map_to_bits)))\n    raise ValueError(\"no days requested\")\n</code></pre>"},{"location":"install/","title":"Install","text":"<pre><code>pip install aioswitcher\n</code></pre>"},{"location":"scripts/","title":"Command line scripts","text":""},{"location":"scripts/#scriptsdiscover_devicespy","title":"scripts/discover_devices.py","text":"<pre><code>usage: discover_devices.py [-h] [-t {1,2,all}] [delay]\n\nDiscover and print info of Switcher devices\n\npositional arguments:\n  delay                 number of seconds to run, defaults to 60\n\noptions:\n  -h, --help            show this help message and exit\n-t {1,2,all}, --type {1,2,all}\nset protocol type: ['1', '2', 'all']\n\nExecuting this script will print a serialized version of the discovered Switcher\ndevices broadcasting on the local network for 60 seconds.\nYou can change the delay by passing an int argument: discover_devices.py 30\n\nSwitcher devices uses two protocol types:\n    Protocol type 1 (UDP port 20002 or port 10002), used by: Switcher Mini, Switcher Power Plug, Switcher Touch, Switcher V2 (esp), Switcher V2 (qualcomm), Switcher V4\n    Protocol type 2 (UDP port 20003 or port 10003), used by: Switcher Breeze, Switcher Runner, Switcher Runner Mini\nYou can change the scanned protocol type by passing an int argument: discover_devices.py -t 1\n\nNote:\n    WILL PRINT PRIVATE INFO SUCH AS DEVICE ID AND MAC.\n\nExample output:\n    Switcher devices broadcast a status message every approximately 4 seconds. This\n    script listens for these messages and prints a serialized version of the to the\n    standard output, for example (note the ``device_id`` and ``mac_address`` properties)::\n    ```\n{   'auto_shutdown': '03:00:00',\n            'device_id': 'aaaaaa',\n            'device_state': &lt;DeviceState.OFF: ('0000', 'off')&gt;,\n            'device_type': &lt;DeviceType.V2_ESP: ('Switcher V2 (esp)', 'a7', &lt;DeviceCategory.WATER_HEATER: 1&gt;)&gt;,\n            'electric_current': 0.0,\n            'ip_address': '192.168.1.33',\n            'last_data_update': datetime.datetime(2021, 6, 13, 11, 11, 44, 883003),\n            'mac_address': '12:A1:A2:1A:BC:1A',\n            'name': 'My Switcher Boiler',\n            'power_consumption': 0,\n            'remaining_time': '00:00:00'}\n```\nPrint all protocol types devices for 30 seconds:\n    python discover_devices.py 30 -t all\n\nPrint only protocol type 1 devices:\n    python discover_devices.py -t 1\n\nPrint only protocol type 2 devices:\n    python discover_devices.py -t 2\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy","title":"script/control_device.py","text":"<pre><code>usage: control_device.py [-h]\n{control_thermostat,create_schedule,delete_schedule,get_schedules,get_state,get_thermostat_state,set_auto_shutdown,set_name,set_shutter_position,stop_shutter,turn_off,turn_on}\n...\n\nControl your Switcher device\n\noptions:\n  -h, --help            show this help message and exit\n\nsubcommands:\n  supported actions\n\n  {control_thermostat,create_schedule,delete_schedule,get_schedules,get_state,get_thermostat_state,set_auto_shutdown,set_name,set_shutter_position,stop_shutter,turn_off,turn_on}\ncontrol_thermostat  control a breeze device\n    create_schedule     create a new schedule\n    delete_schedule     delete a device schedule\n    get_schedules       retrieve a device schedules\n    get_state           get the current state of a device\n    get_thermostat_state\n                        get the current state a thermostat (breeze) device\n    set_auto_shutdown   set the auto shutdown property (1h-24h)\nset_name            set the name of the device\n    set_shutter_position\n                        set shutter position\n    stop_shutter        stop shutter\n    turn_off            turn off the device\n    turn_on             turn on the device\n\nexample usage:\n\npython control_device.py get_state -d ab1c2d -i \"111.222.11.22\"\n\npython control_device.py turn_on -d ab1c2d -i \"111.222.11.22\"\n\npython control_device.py turn_on -d ab1c2d -i \"111.222.11.22\" -t 15\n\npython control_device.py turn_off -d ab1c2d -i \"111.222.11.22\"\n\npython control_device.py set_name -d ab1c2d -i \"111.222.11.22\" -n \"My Boiler\"\n\npython control_device.py set_auto_shutdown -d ab1c2d -i \"111.222.11.22\" -r 2 -m 30\n\npython control_device.py get_schedules -d ab1c2d -i \"111.222.11.22\"\n\npython control_device.py delete_schedule -d ab1c2d -i \"111.222.11.22\" -s 3\n\npython control_device.py create_schedule -d ab1c2d -i \"111.222.11.22\" -n \"14:00\" -f \"14:30\"\n\npython control_device.py create_schedule -d ab1c2d -i \"111.222.11.22\" -n \"17:30\" -f \"18:30\" -w Sunday Monday Friday\n\npython control_device.py stop_shutter -d f2239a -i \"192.168.50.98\"\n\npython control_device.py set_shutter_position -d f2239a -i \"192.168.50.98\"-p 50\n\npython control_device.py get_thermostat_state -d 3a20b7 -i \"192.168.50.77\"\n\npython control_device.py control_thermostat -d 3a20b7 -i \"192.168.50.77\" -r ELEC7001 -s on\n\npython control_device.py control_thermostat -d 3a20b7 -i \"192.168.50.77\" -r ELEC7001 -m cool -f high -t 24\n\npython control_device.py control_thermostat -d 3a20b7 -i \"192.168.50.77\" -r ELEC7001 -m cool -f high -t 24 -u\n\npython control_device.py control_thermostat -d 3a20b7 -i \"192.168.50.77\" -r ELEC7001 -m dry\n\npython control_device.py control_thermostat -d 3a20b7 -i \"192.168.50.77\" -r ELEC7001 -s off\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy-control_thermostat","title":"script/control_device.py control_thermostat","text":"<pre><code>usage: control_device.py control_thermostat [-h] [-v] -d DEVICE_ID -i\n                                            IP_ADDRESS -r REMOTE_ID\n                                            [-s {on,off}]\n[-m {auto,dry,fan,cool,heat}]\n[-f {low,medium,high,auto}]\n[-w {off,on}] [-t TEMPERATURE]\n[-u]\n\noptions:\n  -h, --help            show this help message and exit\n-v, --verbose         include the raw message\n  -d DEVICE_ID, --device-id DEVICE_ID\n                        the identification of the device\n  -i IP_ADDRESS, --ip-address IP_ADDRESS\n                        the ip address assigned to the device\n  -r REMOTE_ID, --remote-id REMOTE_ID\n                        remote id of your device\n  -s {on,off}, --state {on,off}\nthermostat state\n  -m {auto,dry,fan,cool,heat}, --mode {auto,dry,fan,cool,heat}\nthermostat mode\n  -f {low,medium,high,auto}, --fan-level {low,medium,high,auto}\nthermostat fan level\n  -w {off,on}, --swing {off,on}\nthermostat swing\n  -t TEMPERATURE, --temperature TEMPERATURE\n                        thermostat temperature, a positive integer\n  -u, --update          update state without control\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy-create_schedule","title":"script/control_device.py create_schedule","text":"<pre><code>usage: control_device.py create_schedule [-h] [-v] -d DEVICE_ID -i IP_ADDRESS\n                                         -n START_TIME -f END_TIME\n                                         [-w [{Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday} ...]]\n\noptions:\n  -h, --help            show this help message and exit\n-v, --verbose         include the raw message\n  -d DEVICE_ID, --device-id DEVICE_ID\n                        the identification of the device\n  -i IP_ADDRESS, --ip-address IP_ADDRESS\n                        the ip address assigned to the device\n  -n START_TIME, --start-time START_TIME\n                        the on time for the schedule, e.g. 13:00\n  -f END_TIME, --end-time END_TIME\n                        the off time for the schedule, e.g. 13:30\n  -w [{Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday} ...], --weekdays [{Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday} ...]\ndays for recurring schedules\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy-delete_schedule","title":"script/control_device.py delete_schedule","text":"<pre><code>usage: control_device.py delete_schedule [-h] [-v] -d DEVICE_ID -i IP_ADDRESS\n                                         -s SCHEDULE_ID\n\noptions:\n  -h, --help            show this help message and exit\n-v, --verbose         include the raw message\n  -d DEVICE_ID, --device-id DEVICE_ID\n                        the identification of the device\n  -i IP_ADDRESS, --ip-address IP_ADDRESS\n                        the ip address assigned to the device\n  -s SCHEDULE_ID, --schedule-id SCHEDULE_ID\n                        the id of the schedule for deletion\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy-get_schedules","title":"script/control_device.py get_schedules","text":"<pre><code>usage: control_device.py get_schedules [-h] [-v] -d DEVICE_ID -i IP_ADDRESS\n\noptions:\n  -h, --help            show this help message and exit\n-v, --verbose         include the raw message\n  -d DEVICE_ID, --device-id DEVICE_ID\n                        the identification of the device\n  -i IP_ADDRESS, --ip-address IP_ADDRESS\n                        the ip address assigned to the device\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy-get_state","title":"script/control_device.py get_state","text":"<pre><code>usage: control_device.py get_state [-h] [-v] -d DEVICE_ID -i IP_ADDRESS\n\noptions:\n  -h, --help            show this help message and exit\n-v, --verbose         include the raw message\n  -d DEVICE_ID, --device-id DEVICE_ID\n                        the identification of the device\n  -i IP_ADDRESS, --ip-address IP_ADDRESS\n                        the ip address assigned to the device\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy-get_thermostat_state","title":"script/control_device.py get_thermostat_state","text":"<pre><code>usage: control_device.py get_thermostat_state [-h] [-v] -d DEVICE_ID -i\n                                              IP_ADDRESS\n\noptions:\n  -h, --help            show this help message and exit\n-v, --verbose         include the raw message\n  -d DEVICE_ID, --device-id DEVICE_ID\n                        the identification of the device\n  -i IP_ADDRESS, --ip-address IP_ADDRESS\n                        the ip address assigned to the device\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy-set_auto_shutdown","title":"script/control_device.py set_auto_shutdown","text":"<pre><code>usage: control_device.py set_auto_shutdown [-h] [-v] -d DEVICE_ID -i\n                                           IP_ADDRESS -r HOURS [-m [MINUTES]]\n\noptions:\n  -h, --help            show this help message and exit\n-v, --verbose         include the raw message\n  -d DEVICE_ID, --device-id DEVICE_ID\n                        the identification of the device\n  -i IP_ADDRESS, --ip-address IP_ADDRESS\n                        the ip address assigned to the device\n  -r HOURS, --hours HOURS\n                        number hours for the auto shutdown\n  -m [MINUTES], --minutes [MINUTES]\nnumber hours for the auto shutdown\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy-set_name","title":"script/control_device.py set_name","text":"<pre><code>usage: control_device.py set_name [-h] [-v] -d DEVICE_ID -i IP_ADDRESS -n NAME\n\noptions:\n  -h, --help            show this help message and exit\n-v, --verbose         include the raw message\n  -d DEVICE_ID, --device-id DEVICE_ID\n                        the identification of the device\n  -i IP_ADDRESS, --ip-address IP_ADDRESS\n                        the ip address assigned to the device\n  -n NAME, --name NAME  new name for the device\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy-set_shutter_position","title":"script/control_device.py set_shutter_position","text":"<pre><code>usage: control_device.py set_shutter_position [-h] [-v] -d DEVICE_ID -i\n                                              IP_ADDRESS -p POSITION\n\noptions:\n  -h, --help            show this help message and exit\n-v, --verbose         include the raw message\n  -d DEVICE_ID, --device-id DEVICE_ID\n                        the identification of the device\n  -i IP_ADDRESS, --ip-address IP_ADDRESS\n                        the ip address assigned to the device\n  -p POSITION, --position POSITION\n                        Shutter position percentage\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy-stop_shutter","title":"script/control_device.py stop_shutter","text":"<pre><code>usage: control_device.py stop_shutter [-h] [-v] -d DEVICE_ID -i IP_ADDRESS\n\noptions:\n  -h, --help            show this help message and exit\n-v, --verbose         include the raw message\n  -d DEVICE_ID, --device-id DEVICE_ID\n                        the identification of the device\n  -i IP_ADDRESS, --ip-address IP_ADDRESS\n                        the ip address assigned to the device\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy-turn_off","title":"script/control_device.py turn_off","text":"<pre><code>usage: control_device.py turn_off [-h] [-v] -d DEVICE_ID -i IP_ADDRESS\n\noptions:\n  -h, --help            show this help message and exit\n-v, --verbose         include the raw message\n  -d DEVICE_ID, --device-id DEVICE_ID\n                        the identification of the device\n  -i IP_ADDRESS, --ip-address IP_ADDRESS\n                        the ip address assigned to the device\n</code></pre>"},{"location":"scripts/#scriptcontrol_devicepy-turn_on","title":"script/control_device.py turn_on","text":"<pre><code>usage: control_device.py turn_on [-h] [-v] -d DEVICE_ID -i IP_ADDRESS\n                                 [-t [TIMER]]\n\noptions:\n  -h, --help            show this help message and exit\n-v, --verbose         include the raw message\n  -d DEVICE_ID, --device-id DEVICE_ID\n                        the identification of the device\n  -i IP_ADDRESS, --ip-address IP_ADDRESS\n                        the ip address assigned to the device\n  -t [TIMER], --timer [TIMER]\nset minutes timer for turn on operation\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#bridge","title":"Bridge","text":"<p>We can use the Bridge implementation to discover devices and their state. The following code will print all discovered devices for 60 seconds.</p> <pre><code>async def print_devices(delay):\n    def on_device_found_callback(device):\n        print(asdict(device)) # (1)\n\n    async with SwitcherBridge(on_device_found_callback):\n        await asyncio.sleep(delay)\n\nasyncio.run(print_devices(60))\n</code></pre> <ol> <li>the callback device will be an implementation of SwitcherBase,     i.e. SwitcherPowerPlug,     SwitcherWaterHeater,     SwitcherThermostat, and     SwitcherShutter.</li> </ol> <p>Note</p> <p>A Switcher device will broadcast a state message to the bridge approximately every 4 seconds.</p>"},{"location":"usage/#api","title":"API","text":""},{"location":"usage/#type1-api-switcher-plug-v2-touch-v4","title":"Type1 API (Switcher Plug, V2, Touch, V4)","text":"<p>We can use the Type1 API to gain the following capabilities:</p> <ul> <li>Get the current state</li> <li>Turn on and off</li> <li>Set the name</li> <li>Configure auto shutdown</li> <li>Retrieve the schedules</li> <li>Create and Delete schedules</li> </ul> <pre><code>async def control_device(device_ip, device_id) :\n    # for connecting to a device we need its id and ip address\n    async with SwitcherType1Api(device_ip, device_id) as api:\n        # get the device current state (1)\n        await api.get_state()\n        # turn the device on for 15 minutes (2)\n        await api.control_device(Command.ON, 15)\n        # turn the device off (3)\n        await api.control_device(Command.OFF)\n        # set the device name to 'my new name' (4)\n        await api.set_device_name(\"my new name\")\n        # configure the device for 02:30 auto shutdown (5)\n        await api.set_auto_shutdown(timedelta(hours=2, minutes=30))\n        # get the schedules from the device (6)\n        await api.get_schedules()\n        # delete and existing schedule with id 1 (7)\n        await api.delete_schedule(\"1\")\n        # create a new recurring schedule for 13:00-14:30\n        # executing on sunday and friday (8)\n        await api.create_schedule(\"13:00\", \"14:30\", {Days.SUNDAY, Days.FRIDAY})\n\nasyncio.run(\n    control_device(\"111.222.11.22\", \"ab1c2d\")\n)\n</code></pre> <ol> <li>SwitcherStateResponse</li> <li>SwitcherBaseResponse</li> <li>SwitcherBaseResponse</li> <li>SwitcherBaseResponse</li> <li>SwitcherBaseResponse</li> <li>SwitcherGetSchedulesResponse</li> <li>SwitcherBaseResponse</li> <li>SwitcherBaseResponse</li> </ol>"},{"location":"usage/#type2-api-switcher-breeze-and-runner","title":"Type2 API (Switcher Breeze and Runner)","text":"<p>We can use the Type2 API to gain the following capabilities on Switcher Breeze and Runner:</p> <ul> <li>Get the current state</li> <li>Control Runner position</li> <li>Control Breeze (State, Mode, Fan Level, Target Temperature, Vertical Swing)</li> </ul> <pre><code>async def control_runner(device_ip, device_id) :\n    # for connecting to a device we need its id and ip address\n    async with SwitcherType2Api(device_ip, device_id) as api:\n        # get the device current state (1)\n        await api.get_shutter_state()\n        # open the shutter to 30% (2)\n        await api.set_position(30)\n        # stop the shutter if currently rolling (3)\n        await api.stop()\n\nasyncio.run(\n    control_runner(\"111.222.11.22\", \"ab1c2d\")\n)\n</code></pre> <ol> <li>SwitcherShutterStateResponse</li> <li>SwitcherBaseResponse</li> <li>SwitcherShutterStateResponse</li> </ol> <pre><code>async def control_breeze(device_ip, device_id, remote_manager, remote_id) :\n    # for connecting to a device we need its id and ip address\n    async with SwitcherType2Api(device_ip, device_id) as api:\n        # get the device current state (1)\n        await api.get_breeze_state()\n        # initialize the Breeze RemoteManager and get the remote (2)\n        remote = remote_manager.get_remote(remote_id)\n        # prepare a control command that turns on the Breeze\n        # set to 24 degree (Celsius) cooling with vertical swing\n        # send command to the device (3)\n        await api.control_breeze_device(\n            remote,\n            DeviceState.ON,\n            ThermostatMode.COOL,\n            24,\n            ThermostatFanLevel.MEDIUM,\n            ThermostatSwing.ON,\n        )\n\n# create the remote manager outside the context for re-using (4)\nremote_manager = SwitcherBreezeRemoteManager()\nasyncio.run(\n    control_breeze(\"111.222.11.22\", \"ab1c2d\", remote_manager, \"DLK65863\")\n)\n</code></pre> <ol> <li>SwitcherThermostatStateResponse</li> <li>SwitcherBreezeRemote</li> <li>SwitcherBaseResponse</li> <li>SwitcherBreezeRemoteManager</li> </ol> <p>Info</p> <p>You can find the supported device types stated in this enum members.</p>"}]}