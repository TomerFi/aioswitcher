{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"aioswitcher documentation \u2693\ufe0e Install \u2693\ufe0e pip install aioswitcher Usage \u2693\ufe0e Bridge \u2693\ufe0e We can use the Bridge implementation to discover devices and their state. The following code will print all discovered devices for 60 seconds. async def print_devices ( delay ): def on_device_found_callback ( device ): print ( asdict ( device )) async with SwitcherBridge ( on_device_found_callback ): await asyncio . sleep ( delay ) asyncio . get_event_loop () . run_until_complete ( print_devices ( 60 )) Note A Switcher device will broadcast every 4 seconds. Discovered devices can either be a Power Plug or a Power Plug API \u2693\ufe0e Type1 API (Switcher Plug, V2, Touch, V4) \u2693\ufe0e We can use the Type1 API to gain the following capabilities: Get the current state Turn on and off Set the name Configure auto shutdown Retrieve the schedules Create and Delete schedules async def control_device ( device_ip , device_id ) : # for connecting to a device we need its id and ip address async with SwitcherType1Api ( device_ip , device_id ) as api : # get the device current state await api . get_state () # turn the device on for 15 await api . control_device ( Command . ON , 15 ) # turn the device off await api . control_device ( Command . OFF ) # set the device name await api . set_device_name ( \"my new name\" ) # configure the device for 02:30 auto shutdown await api . set_auto_shutdown ( timedelta ( hours = 2 , minutes = 30 )) # get the schedules from the device await api . get_schedules () # delete and existing schedule with id 1 await api . delete_schedule ( \"1\" ) # create a new recurring schedule for 13:00-14:30 executing on sunday and friday await api . create_schedule ( \"13:00\" , \"14:30\" , { Days . SUNDAY , Days . FRIDAY }) asyncio . get_event_loop () . run_until_complete ( control_device ( \"111.222.11.22\" , \"ab1c2d\" )) Type2 API (Switcher Breeze and Runner) \u2693\ufe0e We can use the Type2 API to gain the following capabilities on Switcher Breeze and Runner: Get the current state Control Runner position Control Breeze (State, Mode, Fan Level, Target Temperature, Vertical Swing) async def control_runner_device ( device_ip , device_id ) : # for connecting to a device we need its id and ip address async with SwitcherType2Api ( device_ip , device_id ) as api : # get the device current state state : SwitcherShutterStateResponse = await api . get_shutter_state () # state.position (int) holds the current position of the shutter # state.direction (ShutterDirection) holds the current direction # open the shutter to 30% await api . set_position ( 30 ) # stop the shutter if currently rolling await api . stop () asyncio . get_event_loop () . run_until_complete ( control_runner_device ( \"192.168.50.98\" , \"f2239a\" )) async def control_breeze_device ( device_ip , device_id ) : # for connecting to a device we need its id and ip address async with SwitcherType2Api ( device_ip , device_id ) as api : # get the device current state response : SwitcherThermostatStateResponse = await api . get_breeze_state () # Control Breeze Device # initialize the Breeze RemoteManager rm = BreezeRemoteManager () # get the remote structure (downloaded from the internet) # alternatively, you can get supply local directory path to the BreezeRemoteManager # and the BreezeRemoteManager will save and cache downloaded remotes into the directory async with ClientSession () as session : remote : BreezeRemote = await rm . get_remote ( response . remote_id , api , session ) # prepare a control command that turns on the Breeze # (24 degree (Celsius), cooling with vertical swing and keep the current Fan Level) command : SwitcherBreezeCommand = remote . get_command ( DeviceState . ON , ThermostatMode . COOL , 24 , resp . fan_level , ThermostatSwing . ON , response . state ) # send command to the device await api . control_breeze_device ( command ) asyncio . get_event_loop () . run_until_complete ( control_breeze_device ( \"192.168.50.77\" , \"3a20b7\" )) Note All requests return a response, you can use the asdict __utility function to get familiarize with the various responses. You can visit the API response messages section and review the various response objects. Note that if a request doesn't have a specific response extending the base response, then the base response is the yielding response. Supported Devices \u2693\ufe0e Info You can find the supported device types stated as this enum members. Command line scripts \u2693\ufe0e Discover Devices \u2693\ufe0e scripts/discover_devices.py \u2693\ufe0e usage: discover_devices.py [ -h ] [ delay ] Discover and print info of Switcher devices positional arguments: delay number of seconds to run, defaults to 60 options: -h, --help show this help message and exit script/control_device.py \u2693\ufe0e usage: control_device.py [ -h ] [ -v ] -d DEVICE_ID -i IP_ADDRESS { get_state,turn_on,turn_off,set_name,set_auto_shutdown,get_schedules,delete_schedule, create_schedule,stop_shutter,set_shutter_position,control_thermostat } ... Control your Switcher device options: -h, --help show this help message and exit -v, --verbose include the raw message -d DEVICE_ID, --device-id DEVICE_ID the identification of the device -i IP_ADDRESS, --ip-address IP_ADDRESS the ip address assigned to the device subcommands: supported actions { get_state,turn_on,turn_off,set_name,set_auto_shutdown,get_schedules,delete_schedule,create_schedule,stop_shutter, set_shutter_position,control_thermostat } get_state get the current state of a device turn_on turn on the device turn_off turn off the device set_name set the name of the device set_auto_shutdown set the auto shutdown property ( 1h-24h ) get_schedules retrive a device schedules delete_schedule delete a device schedule create_schedule create a new schedule stop_shutter stop shutter set_shutter_position set shutter position control_thermostat create a new schedule example usage: python control_device.py -d ab1c2d -i \"111.222.11.22\" get_state python control_device.py -d ab1c2d -i \"111.222.11.22\" turn_on python control_device.py -d ab1c2d -i \"111.222.11.22\" turn_on -t 15 python control_device.py -d ab1c2d -i \"111.222.11.22\" turn_off python control_device.py -d ab1c2d -i \"111.222.11.22\" set_name -n \"My Boiler\" python control_device.py -d ab1c2d -i \"111.222.11.22\" set_auto_shutdown -r 2 -m 30 python control_device.py -d ab1c2d -i \"111.222.11.22\" get_schedules python control_device.py -d ab1c2d -i \"111.222.11.22\" delete_schedule -s 3 python control_device.py -d ab1c2d -i \"111.222.11.22\" create_schedule -n \"14:00\" -f \"14:30\" python control_device.py -d ab1c2d -i \"111.222.11.22\" create_schedule -n \"17:30\" -f \"18:30\" -w Sunday Monday Friday python control_device.py -d f2239a -i \"192.168.50.98\" stop_shutter python control_device.py -d f2239a -i \"192.168.50.98\" set_shutter_position -p 50 python control_device.py -d 3a20b7 -i \"192.168.50.77\" control_thermostat -m dry python control_device.py -d 3a20b7 -i \"192.168.50.77\" control_thermostat -s off script/control_device.py create_schedule \u2693\ufe0e usage: control_device.py create_schedule [ -h ] -n START_TIME -f END_TIME [ -w [{ Monday,Tuesday,Wednesday,Thursday,Friday, Saturday,Sunday } ... ]] options: -h, --help show this help message and exit -n START_TIME, --start-time START_TIME the on time for the schedule, e.g. 13 :00 -f END_TIME, --end-time END_TIME the off time for the schedule, e.g. 13 :30 -w [{ Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday } ... ] , --weekdays [{ Monday,Tuesday,Wednesday,Thursday, Friday,Saturday,Sunday } ... ] days for recurring schedules, possible values: [ 'Monday' , 'Tuesday' , 'Wednesday' , 'Thursday' , 'Friday' , 'Saturday' , 'Sunday' ] script/control_device.py delete_schedule \u2693\ufe0e usage: control_device.py delete_schedule [ -h ] -s SCHEDULE_ID options: -h, --help show this help message and exit -s SCHEDULE_ID, --schedule-id SCHEDULE_ID the id of the schedule for deletion script/control_device.py get_schedules \u2693\ufe0e usage: control_device.py get_schedules [ -h ] options: -h, --help show this help message and exit script/control_device.py get_state \u2693\ufe0e usage: control_device.py get_state [ -h ] options: -h, --help show this help message and exit script/control_device.py set_auto_shutdown \u2693\ufe0e usage: control_device.py set_auto_shutdown [ -h ] -r HOURS [ -m [ MINUTES ]] options: -h, --help show this help message and exit -r HOURS, --hours HOURS number hours for the auto shutdown -m [ MINUTES ] , --minutes [ MINUTES ] number hours for the auto shutdown script/control_device.py set_name \u2693\ufe0e usage: control_device.py set_name [ -h ] -n NAME options: -h, --help show this help message and exit -n NAME, --name NAME new name for the device script/control_device.py turn_off \u2693\ufe0e usage: control_device.py turn_off [ -h ] options: -h, --help show this help message and exit script/control_device.py turn_on \u2693\ufe0e usage: control_device.py turn_on [ -h ] [ -t [ TIMER ]] options: -h, --help show this help message and exit -t [ TIMER ] , --timer [ TIMER ] set minutes timer for turn on operation script/control_device.py set_shutter_position \u2693\ufe0e usage: control_device.py set_shutter_position [ -h ] -p POSITION options: -h, --help show this help message and exit -p POSITION, --position POSITION Shutter position percentage script/control_device.py stop_shutter \u2693\ufe0e usage: control_device.py stop_shutter [ -h ] options: -h, --help show this help message and exit script/control_device.py control_thermostat \u2693\ufe0e usage: control_device.py control_thermostat [ -h ] [ -s { on,off }] [ -m { auto,dry,fan,cool,heat }] [ -f { low,medium,high,auto }] [ -w { off,on }] [ -t TEMPERATURE ] options: -h, --help show this help message and exit -s { on,off } , --state { on,off } thermostat state, possible values -m { auto,dry,fan,cool,heat } , --mode { auto,dry,fan,cool,heat } thermostat mode -f { low,medium,high,auto } , --fan-level { low,medium,high,auto } thermostat fan level -w { off,on } , --swing { off,on } thermostat swing -t TEMPERATURE, --temperature TEMPERATURE thermostat temperature Code documentation \u2693\ufe0e aioswitcher.api \u2693\ufe0e Command \u2693\ufe0e Bases: Enum Enum for turning the device on or off. Source code in src/aioswitcher/api/__init__.py 87 88 89 90 91 92 @unique class Command ( Enum ): \"\"\"Enum for turning the device on or off.\"\"\" ON = \"1\" OFF = \"0\" SwitcherApi \u2693\ufe0e Switcher TCP based API. Parameters: Name Type Description Default ip_address str the ip address assigned to the device. required device_id str the id of the desired device. required port int the port of the device, default is 9957. 9957 Source code in src/aioswitcher/api/__init__.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 class SwitcherApi : \"\"\"Switcher TCP based API. Args: ip_address: the ip address assigned to the device. device_id: the id of the desired device. port: the port of the device, default is 9957. \"\"\" def __init__ ( self , ip_address : str , device_id : str , port : int = 9957 ) -> None : \"\"\"Initialize the Switcher TCP connection API.\"\"\" self . _ip_address = ip_address self . _device_id = device_id self . _port = port self . _connected = False async def __aenter__ ( self ) -> \"SwitcherApi\" : \"\"\"Enter SwitcherApi asynchronous context manager. Returns: This instance of ``aioswitcher.api.SwitcherApi``. \"\"\" await self . connect () return self async def __aexit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc_value : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : \"\"\"Exit SwitcherApi asynchronous context manager.\"\"\" await self . disconnect () async def connect ( self ) -> None : \"\"\"Connect to asynchronous socket and get reader and writer object.\"\"\" logger . info ( \"connecting to the switcher device\" ) self . _reader , self . _writer = await open_connection ( host = self . _ip_address , port = self . _port , family = AF_INET , ) self . _connected = True logger . info ( \"switcher device connected\" ) async def disconnect ( self ) -> None : \"\"\"Disconnect from asynchronous socket.\"\"\" if hasattr ( self , \"_writer\" ) and self . _writer : logger . info ( \"disconnecting from the switcher device\" ) self . _writer . close () await self . _writer . wait_closed () else : logger . info ( \"switcher device not connected\" ) self . _connected = False @property def connected ( self ) -> bool : \"\"\"Return true if api is connected.\"\"\" return self . _connected async def _login ( self , device_type : DeviceType = None ) -> Tuple [ str , SwitcherLoginResponse ]: \"\"\"Use for sending the login packet to the device. Returns: A tuple of the hex timestamp and an instance of ``SwitcherLoginResponse``. Note: This is a private function used by other functions, do not call this function directly. \"\"\" timestamp = current_timestamp_to_hexadecimal () if ( device_type and device_type == DeviceType . BREEZE or device_type == DeviceType . RUNNER or device_type == DeviceType . RUNNER_MINI ): packet = packets . LOGIN2_PACKET_TYPE2 . format ( timestamp , self . _device_id ) else : packet = packets . LOGIN_PACKET_TYPE1 . format ( timestamp ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a login packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return timestamp , SwitcherLoginResponse ( response ) async def get_state ( self ) -> SwitcherStateResponse : \"\"\"Use for sending the get state packet to the device. Returns: An instance of ``SwitcherStateResponse``. \"\"\" timestamp , login_resp = await self . _login () if login_resp . successful : packet = packets . GET_STATE_PACKET_TYPE1 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) async def get_breeze_state ( self ) -> SwitcherThermostatStateResponse : \"\"\"Use for sending the get state packet to the Breeze device. Returns: An instance of ``SwitcherThermostatStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherThermostatStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get breeze state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) async def get_shutter_state ( self ) -> SwitcherShutterStateResponse : \"\"\"Use for sending the get state packet to the Runner device. Returns: An instance of ``SwitcherShutterStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherShutterStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get shutter state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) async def control_device ( self , command : Command , minutes : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the device. Args: command: use the ``aioswitcher.api.Command`` enum. minutes: if turning-on optionally incorporate a timer. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () timer = ( minutes_to_hexadecimal_seconds ( minutes ) if minutes > 0 else packets . NO_TIMER_REQUESTED ) packet = packets . SEND_CONTROL_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . value , timer , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def control_breeze_device ( self , command : SwitcherBreezeCommand , ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the Breeze device. Args: command: use the ``aioswitcher.api.SwitcherBreezeCommand`` class. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send Breeze command\" ) timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if not login_resp . successful : logger . error ( \"Failed to log into device id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . BREEZE_COMMAND_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . length , command . command , ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def set_auto_shutdown ( self , full_time : timedelta ) -> SwitcherBaseResponse : \"\"\"Use for sending the set auto-off packet to the device. Args: full_time: timedelta value containing the configuration value for auto-shutdown. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () auto_shutdown = timedelta_to_hexadecimal_seconds ( full_time ) packet = packets . SET_AUTO_OFF_SET_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , auto_shutdown , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set auto shutdown packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def set_device_name ( self , name : str ) -> SwitcherBaseResponse : \"\"\"Use for sending the set name packet to the device. Args: name: string name with the length of 2 >= x >= 32. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () device_name = string_to_hexadecimale_device_name ( name ) packet = packets . UPDATE_DEVICE_NAME_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , device_name , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set name packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def get_schedules ( self ) -> SwitcherGetSchedulesResponse : \"\"\"Use for retrieval of the schedules from the device. Returns: An instance of ``SwitcherGetSchedulesResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . GET_SCHEDULES_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get schedules packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherGetSchedulesResponse ( response ) async def delete_schedule ( self , schedule_id : str ) -> SwitcherBaseResponse : \"\"\"Use for deleting a schedule from the device. Use ``get_schedules`` to retrieve the schedule instance. Args: schedule_id: the identification of the schedule for deletion. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . DELETE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , schedule_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a delete schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def create_schedule ( self , start_time : str , end_time : str , days : Set [ Days ] = set () ) -> SwitcherBaseResponse : \"\"\"Use for creating a new schedule in the next empty schedule slot. Args: start_time: a string start time in %H:%M format. e.g. 13:00. end_time: a string start time in %H:%M format. e.g. 13:00. days: for recurring schedules, add ``Days``. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () start_time_hex = time_to_hexadecimal_timestamp ( start_time ) end_time_hex = time_to_hexadecimal_timestamp ( end_time ) weekdays = ( weekdays_to_hexadecimal ( days ) if len ( days ) > 0 else packets . NON_RECURRING_SCHEDULE ) new_schedule = packets . SCHEDULE_CREATE_DATA_FORMAT . format ( weekdays , start_time_hex , end_time_hex ) packet = packets . CREATE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , new_schedule , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a create schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def set_position ( self , position : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for setting the shutter position of the Runner and Runner Mini devices. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" hex_pos = \"{0:0 {1} x}\" . format ( position , 2 ) logger . debug ( \"about to send set position command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_SET_POSITION . format ( login_resp . session_id , timestamp , self . _device_id , hex_pos ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def stop ( self ) -> SwitcherBaseResponse : \"\"\"Use for stopping the shutter. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send stop shutter command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_STOP_COMMAND . format ( login_resp . session_id , timestamp , self . _device_id ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a stop control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) connect () async \u2693\ufe0e Connect to asynchronous socket and get reader and writer object. Source code in src/aioswitcher/api/__init__.py 146 147 148 149 150 151 152 153 154 155 156 async def connect ( self ) -> None : \"\"\"Connect to asynchronous socket and get reader and writer object.\"\"\" logger . info ( \"connecting to the switcher device\" ) self . _reader , self . _writer = await open_connection ( host = self . _ip_address , port = self . _port , family = AF_INET , ) self . _connected = True logger . info ( \"switcher device connected\" ) connected () property \u2693\ufe0e Return true if api is connected. Source code in src/aioswitcher/api/__init__.py 168 169 170 171 @property def connected ( self ) -> bool : \"\"\"Return true if api is connected.\"\"\" return self . _connected control_breeze_device ( command ) async \u2693\ufe0e Use for sending the control packet to the Breeze device. Parameters: Name Type Description Default command SwitcherBreezeCommand use the aioswitcher.api.SwitcherBreezeCommand class. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 async def control_breeze_device ( self , command : SwitcherBreezeCommand , ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the Breeze device. Args: command: use the ``aioswitcher.api.SwitcherBreezeCommand`` class. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send Breeze command\" ) timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if not login_resp . successful : logger . error ( \"Failed to log into device id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . BREEZE_COMMAND_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . length , command . command , ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) control_device ( command , minutes = 0 ) async \u2693\ufe0e Use for sending the control packet to the device. Parameters: Name Type Description Default command Command use the aioswitcher.api.Command enum. required minutes int if turning-on optionally incorporate a timer. 0 Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 async def control_device ( self , command : Command , minutes : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the device. Args: command: use the ``aioswitcher.api.Command`` enum. minutes: if turning-on optionally incorporate a timer. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () timer = ( minutes_to_hexadecimal_seconds ( minutes ) if minutes > 0 else packets . NO_TIMER_REQUESTED ) packet = packets . SEND_CONTROL_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . value , timer , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) create_schedule ( start_time , end_time , days = set ()) async \u2693\ufe0e Use for creating a new schedule in the next empty schedule slot. Parameters: Name Type Description Default start_time str a string start time in %H:%M format. e.g. 13:00. required end_time str a string start time in %H:%M format. e.g. 13:00. required days Set [ Days ] for recurring schedules, add Days . set() Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 async def create_schedule ( self , start_time : str , end_time : str , days : Set [ Days ] = set () ) -> SwitcherBaseResponse : \"\"\"Use for creating a new schedule in the next empty schedule slot. Args: start_time: a string start time in %H:%M format. e.g. 13:00. end_time: a string start time in %H:%M format. e.g. 13:00. days: for recurring schedules, add ``Days``. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () start_time_hex = time_to_hexadecimal_timestamp ( start_time ) end_time_hex = time_to_hexadecimal_timestamp ( end_time ) weekdays = ( weekdays_to_hexadecimal ( days ) if len ( days ) > 0 else packets . NON_RECURRING_SCHEDULE ) new_schedule = packets . SCHEDULE_CREATE_DATA_FORMAT . format ( weekdays , start_time_hex , end_time_hex ) packet = packets . CREATE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , new_schedule , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a create schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) delete_schedule ( schedule_id ) async \u2693\ufe0e Use for deleting a schedule from the device. Use get_schedules to retrieve the schedule instance. Parameters: Name Type Description Default schedule_id str the identification of the schedule for deletion. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 async def delete_schedule ( self , schedule_id : str ) -> SwitcherBaseResponse : \"\"\"Use for deleting a schedule from the device. Use ``get_schedules`` to retrieve the schedule instance. Args: schedule_id: the identification of the schedule for deletion. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . DELETE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , schedule_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a delete schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) disconnect () async \u2693\ufe0e Disconnect from asynchronous socket. Source code in src/aioswitcher/api/__init__.py 158 159 160 161 162 163 164 165 166 async def disconnect ( self ) -> None : \"\"\"Disconnect from asynchronous socket.\"\"\" if hasattr ( self , \"_writer\" ) and self . _writer : logger . info ( \"disconnecting from the switcher device\" ) self . _writer . close () await self . _writer . wait_closed () else : logger . info ( \"switcher device not connected\" ) self . _connected = False get_breeze_state () async \u2693\ufe0e Use for sending the get state packet to the Breeze device. Returns: Type Description SwitcherThermostatStateResponse An instance of SwitcherThermostatStateResponse . Source code in src/aioswitcher/api/__init__.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 async def get_breeze_state ( self ) -> SwitcherThermostatStateResponse : \"\"\"Use for sending the get state packet to the Breeze device. Returns: An instance of ``SwitcherThermostatStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherThermostatStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get breeze state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) get_schedules () async \u2693\ufe0e Use for retrieval of the schedules from the device. Returns: Type Description SwitcherGetSchedulesResponse An instance of SwitcherGetSchedulesResponse . Source code in src/aioswitcher/api/__init__.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 async def get_schedules ( self ) -> SwitcherGetSchedulesResponse : \"\"\"Use for retrieval of the schedules from the device. Returns: An instance of ``SwitcherGetSchedulesResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . GET_SCHEDULES_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get schedules packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherGetSchedulesResponse ( response ) get_shutter_state () async \u2693\ufe0e Use for sending the get state packet to the Runner device. Returns: Type Description SwitcherShutterStateResponse An instance of SwitcherShutterStateResponse . Source code in src/aioswitcher/api/__init__.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 async def get_shutter_state ( self ) -> SwitcherShutterStateResponse : \"\"\"Use for sending the get state packet to the Runner device. Returns: An instance of ``SwitcherShutterStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherShutterStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get shutter state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) get_state () async \u2693\ufe0e Use for sending the get state packet to the device. Returns: Type Description SwitcherStateResponse An instance of SwitcherStateResponse . Source code in src/aioswitcher/api/__init__.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 async def get_state ( self ) -> SwitcherStateResponse : \"\"\"Use for sending the get state packet to the device. Returns: An instance of ``SwitcherStateResponse``. \"\"\" timestamp , login_resp = await self . _login () if login_resp . successful : packet = packets . GET_STATE_PACKET_TYPE1 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) set_auto_shutdown ( full_time ) async \u2693\ufe0e Use for sending the set auto-off packet to the device. Parameters: Name Type Description Default full_time timedelta timedelta value containing the configuration value for auto-shutdown. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 async def set_auto_shutdown ( self , full_time : timedelta ) -> SwitcherBaseResponse : \"\"\"Use for sending the set auto-off packet to the device. Args: full_time: timedelta value containing the configuration value for auto-shutdown. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () auto_shutdown = timedelta_to_hexadecimal_seconds ( full_time ) packet = packets . SET_AUTO_OFF_SET_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , auto_shutdown , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set auto shutdown packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) set_device_name ( name ) async \u2693\ufe0e Use for sending the set name packet to the device. Parameters: Name Type Description Default name str string name with the length of 2 >= x >= 32. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 async def set_device_name ( self , name : str ) -> SwitcherBaseResponse : \"\"\"Use for sending the set name packet to the device. Args: name: string name with the length of 2 >= x >= 32. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () device_name = string_to_hexadecimale_device_name ( name ) packet = packets . UPDATE_DEVICE_NAME_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , device_name , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set name packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) set_position ( position = 0 ) async \u2693\ufe0e Use for setting the shutter position of the Runner and Runner Mini devices. Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 async def set_position ( self , position : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for setting the shutter position of the Runner and Runner Mini devices. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" hex_pos = \"{0:0 {1} x}\" . format ( position , 2 ) logger . debug ( \"about to send set position command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_SET_POSITION . format ( login_resp . session_id , timestamp , self . _device_id , hex_pos ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) stop () async \u2693\ufe0e Use for stopping the shutter. Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 async def stop ( self ) -> SwitcherBaseResponse : \"\"\"Use for stopping the shutter. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send stop shutter command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_STOP_COMMAND . format ( login_resp . session_id , timestamp , self . _device_id ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a stop control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) aioswitcher.api.messages \u2693\ufe0e SwitcherBaseResponse \u2693\ufe0e Representation of the switcher base response message. Applicable for all messages that do no require post initialization. e.g. not applicable for SwitcherLoginResponse, SwitcherStateResponse, SwitcherGetScheduleResponse. Parameters: Name Type Description Default unparsed_response bytes the raw response from the device. required Source code in src/aioswitcher/api/messages.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 @dataclass class SwitcherBaseResponse : \"\"\"Representation of the switcher base response message. Applicable for all messages that do no require post initialization. e.g. not applicable for SwitcherLoginResponse, SwitcherStateResponse, SwitcherGetScheduleResponse. Args: unparsed_response: the raw response from the device. \"\"\" unparsed_response : bytes @property def successful ( self ) -> bool : \"\"\"Return true if the response is not empty. Partially indicating the request was successful. \"\"\" return self . unparsed_response is not None and len ( self . unparsed_response ) > 0 successful () property \u2693\ufe0e Return true if the response is not empty. Partially indicating the request was successful. Source code in src/aioswitcher/api/messages.py 160 161 162 163 164 165 166 @property def successful ( self ) -> bool : \"\"\"Return true if the response is not empty. Partially indicating the request was successful. \"\"\" return self . unparsed_response is not None and len ( self . unparsed_response ) > 0 SwitcherLoginResponse \u2693\ufe0e Bases: SwitcherBaseResponse Representations of the switcher login response message. Source code in src/aioswitcher/api/messages.py 169 170 171 172 173 174 175 176 177 178 179 180 181 @final @dataclass class SwitcherLoginResponse ( SwitcherBaseResponse ): \"\"\"Representations of the switcher login response message.\"\"\" session_id : str = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization of the response.\"\"\" try : self . session_id = hexlify ( self . unparsed_response )[ 16 : 24 ] . decode () except Exception as exc : raise ValueError ( \"failed to parse login response message\" ) from exc SwitcherStateResponse \u2693\ufe0e Bases: SwitcherBaseResponse Representation of the switcher state response message. Source code in src/aioswitcher/api/messages.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 @final @dataclass class SwitcherStateResponse ( SwitcherBaseResponse ): \"\"\"Representation of the switcher state response message.\"\"\" state : DeviceState = field ( init = False ) time_left : str = field ( init = False ) time_on : str = field ( init = False ) auto_shutdown : str = field ( init = False ) power_consumption : int = field ( init = False ) electric_current : float = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization of the message.\"\"\" parser = StateMessageParser ( self . unparsed_response ) self . state = parser . get_state () self . time_left = parser . get_time_left () self . time_on = parser . get_time_on () self . auto_shutdown = parser . get_auto_shutdown () self . power_consumption = parser . get_power_consumption () self . electric_current = watts_to_amps ( self . power_consumption ) SwitcherGetSchedulesResponse \u2693\ufe0e Bases: SwitcherBaseResponse Representation of the switcher get schedule message. Source code in src/aioswitcher/api/messages.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 @final @dataclass class SwitcherGetSchedulesResponse ( SwitcherBaseResponse ): \"\"\"Representation of the switcher get schedule message.\"\"\" schedules : Set [ SwitcherSchedule ] = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization of the message.\"\"\" self . schedules = get_schedules ( self . unparsed_response ) @property def found_schedules ( self ) -> bool : \"\"\"Return true if found schedules in the response.\"\"\" return len ( self . schedules ) > 0 found_schedules () property \u2693\ufe0e Return true if found schedules in the response. Source code in src/aioswitcher/api/messages.py 219 220 221 222 @property def found_schedules ( self ) -> bool : \"\"\"Return true if found schedules in the response.\"\"\" return len ( self . schedules ) > 0 aioswitcher.bridge \u2693\ufe0e SwitcherBridge \u2693\ufe0e Use for running a UDP client for bridging Switcher devices broadcast messages. Parameters: Name Type Description Default on_device Callable [[ SwitcherBase ], Any ] a callable to which every new SwitcherBase device found will be send. required broadcast_ports list [ int ] broadcast ports list, default for type 1 devices is 20002, default for type 2 devices is 20003 [SWITCHER_UDP_PORT_TYPE1, SWITCHER_UDP_PORT_TYPE2] Source code in src/aioswitcher/bridge.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @final class SwitcherBridge : \"\"\"Use for running a UDP client for bridging Switcher devices broadcast messages. Args: on_device: a callable to which every new SwitcherBase device found will be send. broadcast_ports: broadcast ports list, default for type 1 devices is 20002, default for type 2 devices is 20003 \"\"\" def __init__ ( self , on_device : Callable [[ SwitcherBase ], Any ], broadcast_ports : list [ int ] = [ SWITCHER_UDP_PORT_TYPE1 , SWITCHER_UDP_PORT_TYPE2 ], ) -> None : \"\"\"Initialize the switcher bridge.\"\"\" self . _on_device = on_device self . _broadcast_ports = broadcast_ports self . _is_running = False self . _transports = {} # type: Dict[int, Optional[BaseTransport]] async def __aenter__ ( self ) -> \"SwitcherBridge\" : \"\"\"Enter SwitcherBridge asynchronous context manager.\"\"\" await self . start () return self async def __aexit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc_value : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : \"\"\"Exit the SwitcherBridge asynchronous context manager.\"\"\" await self . stop () async def start ( self ) -> None : \"\"\"Create an asynchronous listener and start the bridge.\"\"\" for broadcast_port in self . _broadcast_ports : logger . info ( \"starting the udp bridge on port %s \" , broadcast_port ) protocol_factory = UdpClientProtocol ( partial ( _parse_device_from_datagram , self . _on_device ) ) transport , protocol = await get_running_loop () . create_datagram_endpoint ( lambda : protocol_factory , local_addr = ( \"0.0.0.0\" , broadcast_port ), # nosec family = AF_INET , ) self . _transports [ broadcast_port ] = transport logger . debug ( \"udp bridge on port %s started\" , broadcast_port ) self . _is_running = True async def stop ( self ) -> None : \"\"\"Stop the asynchronous bridge.\"\"\" for broadcast_port in self . _broadcast_ports : transport = self . _transports . get ( broadcast_port ) if transport and not transport . is_closing (): logger . info ( \"stopping the udp bridge on port %s \" , broadcast_port ) transport . close () else : logger . info ( \"udp bridge on port %s not started\" , broadcast_port ) self . _is_running = False @property def is_running ( self ) -> bool : \"\"\"bool: Return true if bridge is running.\"\"\" return self . _is_running is_running () property \u2693\ufe0e bool: Return true if bridge is running. Source code in src/aioswitcher/bridge.py 228 229 230 231 @property def is_running ( self ) -> bool : \"\"\"bool: Return true if bridge is running.\"\"\" return self . _is_running start () async \u2693\ufe0e Create an asynchronous listener and start the bridge. Source code in src/aioswitcher/bridge.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 async def start ( self ) -> None : \"\"\"Create an asynchronous listener and start the bridge.\"\"\" for broadcast_port in self . _broadcast_ports : logger . info ( \"starting the udp bridge on port %s \" , broadcast_port ) protocol_factory = UdpClientProtocol ( partial ( _parse_device_from_datagram , self . _on_device ) ) transport , protocol = await get_running_loop () . create_datagram_endpoint ( lambda : protocol_factory , local_addr = ( \"0.0.0.0\" , broadcast_port ), # nosec family = AF_INET , ) self . _transports [ broadcast_port ] = transport logger . debug ( \"udp bridge on port %s started\" , broadcast_port ) self . _is_running = True stop () async \u2693\ufe0e Stop the asynchronous bridge. Source code in src/aioswitcher/bridge.py 215 216 217 218 219 220 221 222 223 224 225 226 async def stop ( self ) -> None : \"\"\"Stop the asynchronous bridge.\"\"\" for broadcast_port in self . _broadcast_ports : transport = self . _transports . get ( broadcast_port ) if transport and not transport . is_closing (): logger . info ( \"stopping the udp bridge on port %s \" , broadcast_port ) transport . close () else : logger . info ( \"udp bridge on port %s not started\" , broadcast_port ) self . _is_running = False aioswitcher.device \u2693\ufe0e DeviceCategory \u2693\ufe0e Bases: Enum Enum for relaying the device category. Source code in src/aioswitcher/device/__init__.py 24 25 26 27 28 29 30 31 @unique class DeviceCategory ( Enum ): \"\"\"Enum for relaying the device category.\"\"\" WATER_HEATER = auto () POWER_PLUG = auto () THERMOSTAT = auto () SHUTTER = auto () DeviceType \u2693\ufe0e Bases: Enum Enum for relaying the type of the switcher devices. Source code in src/aioswitcher/device/__init__.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @unique class DeviceType ( Enum ): \"\"\"Enum for relaying the type of the switcher devices.\"\"\" MINI = \"Switcher Mini\" , \"030f\" , 1 , DeviceCategory . WATER_HEATER POWER_PLUG = \"Switcher Power Plug\" , \"01a8\" , 1 , DeviceCategory . POWER_PLUG TOUCH = \"Switcher Touch\" , \"030b\" , 1 , DeviceCategory . WATER_HEATER V2_ESP = \"Switcher V2 (esp)\" , \"01a7\" , 1 , DeviceCategory . WATER_HEATER V2_QCA = \"Switcher V2 (qualcomm)\" , \"01a1\" , 1 , DeviceCategory . WATER_HEATER V4 = \"Switcher V4\" , \"0317\" , 1 , DeviceCategory . WATER_HEATER BREEZE = \"Switcher Breeze\" , \"0e01\" , 2 , DeviceCategory . THERMOSTAT RUNNER = \"Switcher Runner\" , \"0c01\" , 2 , DeviceCategory . SHUTTER RUNNER_MINI = \"Switcher Runner Mini\" , \"0c02\" , 2 , DeviceCategory . SHUTTER def __new__ ( cls , value : str , hex_rep : str , protocol_type : int , category : DeviceCategory ) -> \"DeviceType\" : \"\"\"Override the default enum constructor and include extra properties.\"\"\" new_enum = object . __new__ ( cls ) new_enum . _value = value # type: ignore new_enum . _hex_rep = hex_rep # type: ignore new_enum . _protocol_type = protocol_type # type: ignore new_enum . _category = category # type: ignore return new_enum @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore @property def hex_rep ( self ) -> str : \"\"\"Return the hexadecimal representation of the device type.\"\"\" return self . _hex_rep # type: ignore @property def protocol_type ( self ) -> int : \"\"\"Return the protocol type of the device.\"\"\" return self . _protocol_type # type: ignore @property def category ( self ) -> DeviceCategory : \"\"\"Return the category of the device type.\"\"\" return self . _category # type: ignore category () property \u2693\ufe0e Return the category of the device type. Source code in src/aioswitcher/device/__init__.py 74 75 76 77 @property def category ( self ) -> DeviceCategory : \"\"\"Return the category of the device type.\"\"\" return self . _category # type: ignore hex_rep () property \u2693\ufe0e Return the hexadecimal representation of the device type. Source code in src/aioswitcher/device/__init__.py 64 65 66 67 @property def hex_rep ( self ) -> str : \"\"\"Return the hexadecimal representation of the device type.\"\"\" return self . _hex_rep # type: ignore protocol_type () property \u2693\ufe0e Return the protocol type of the device. Source code in src/aioswitcher/device/__init__.py 69 70 71 72 @property def protocol_type ( self ) -> int : \"\"\"Return the protocol type of the device.\"\"\" return self . _protocol_type # type: ignore value () property \u2693\ufe0e Return the value of the state. Source code in src/aioswitcher/device/__init__.py 59 60 61 62 @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore DeviceState \u2693\ufe0e Bases: Enum Enum class representing the device's state. Source code in src/aioswitcher/device/__init__.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @unique class DeviceState ( Enum ): \"\"\"Enum class representing the device's state.\"\"\" ON = \"01\" , \"on\" OFF = \"00\" , \"off\" def __new__ ( cls , value : str , display : str ) -> \"DeviceState\" : \"\"\"Override the default enum constructor and include extra properties.\"\"\" new_enum = object . __new__ ( cls ) new_enum . _value = value # type: ignore new_enum . _display = display # type: ignore return new_enum @property def display ( self ) -> str : \"\"\"Return the display name of the state.\"\"\" return self . _display # type: ignore @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore display () property \u2693\ufe0e Return the display name of the state. Source code in src/aioswitcher/device/__init__.py 94 95 96 97 @property def display ( self ) -> str : \"\"\"Return the display name of the state.\"\"\" return self . _display # type: ignore value () property \u2693\ufe0e Return the value of the state. Source code in src/aioswitcher/device/__init__.py 99 100 101 102 @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore SwitcherPowerPlug \u2693\ufe0e Bases: SwitcherPowerBase , SwitcherBase Implementation of the Switcher Power Plug device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. Source code in src/aioswitcher/device/__init__.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 @final @dataclass class SwitcherPowerPlug ( SwitcherPowerBase , SwitcherBase ): \"\"\"Implementation of the Switcher Power Plug device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. \"\"\" def __post_init__ ( self ) -> None : \"\"\"Post initialization validate device type category as POWER_PLUG.\"\"\" if self . device_type . category != DeviceCategory . POWER_PLUG : raise ValueError ( \"only power plugs are allowed\" ) super () . __post_init__ () SwitcherWaterHeater \u2693\ufe0e Bases: SwitcherTimedBase , SwitcherPowerBase , SwitcherBase Implementation of the Switcher Water Heater device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. Source code in src/aioswitcher/device/__init__.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 @final @dataclass class SwitcherWaterHeater ( SwitcherTimedBase , SwitcherPowerBase , SwitcherBase ): \"\"\"Implementation of the Switcher Water Heater device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. \"\"\" def __post_init__ ( self ) -> None : \"\"\"Post initialization validate device type category as WATER_HEATER.\"\"\" if self . device_type . category != DeviceCategory . WATER_HEATER : raise ValueError ( \"only water heaters are allowed\" ) super () . __post_init__ () aioswitcher.schedule \u2693\ufe0e Bases: Enum Enum class representing the day entity. Source code in src/aioswitcher/schedule/__init__.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @unique class Days ( Enum ): \"\"\"Enum class representing the day entity.\"\"\" MONDAY = ( \"Monday\" , 0x02 , 2 , 0 ) TUESDAY = ( \"Tuesday\" , 0x04 , 4 , 1 ) WEDNESDAY = ( \"Wednesday\" , 0x08 , 8 , 2 ) THURSDAY = ( \"Thursday\" , 0x10 , 16 , 3 ) FRIDAY = ( \"Friday\" , 0x20 , 32 , 4 ) SATURDAY = ( \"Saturday\" , 0x40 , 64 , 5 ) SUNDAY = ( \"Sunday\" , 0x80 , 128 , 6 ) def __new__ ( cls , value : str , hex_rep : int , bit_rep : int , weekday : int ) -> \"Days\" : \"\"\"Override the default enum constructor and include extra properties.\"\"\" new_enum = object . __new__ ( cls ) new_enum . _value_ = value new_enum . _hex_rep = hex_rep # type: ignore new_enum . _bit_rep = bit_rep # type: ignore new_enum . _weekday = weekday # type: ignore return new_enum @property def bit_rep ( self ) -> int : \"\"\"Return the bit representation of the day.\"\"\" return self . _bit_rep # type: ignore @property def hex_rep ( self ) -> int : \"\"\"Return the hexadecimal representation of the day.\"\"\" return self . _hex_rep # type: ignore @property def weekday ( self ) -> int : \"\"\"Return the weekday of the day.\"\"\" return self . _weekday # type: ignore bit_rep () property \u2693\ufe0e Return the bit representation of the day. Source code in src/aioswitcher/schedule/__init__.py 49 50 51 52 @property def bit_rep ( self ) -> int : \"\"\"Return the bit representation of the day.\"\"\" return self . _bit_rep # type: ignore hex_rep () property \u2693\ufe0e Return the hexadecimal representation of the day. Source code in src/aioswitcher/schedule/__init__.py 54 55 56 57 @property def hex_rep ( self ) -> int : \"\"\"Return the hexadecimal representation of the day.\"\"\" return self . _hex_rep # type: ignore weekday () property \u2693\ufe0e Return the weekday of the day. Source code in src/aioswitcher/schedule/__init__.py 59 60 61 62 @property def weekday ( self ) -> int : \"\"\"Return the weekday of the day.\"\"\" return self . _weekday # type: ignore representation of the Switcher schedule slot. Parameters: Name Type Description Default schedule_id str the id of the schedule required recurring bool is a recurring schedule required days Set [ Days ] a set of schedule days, or empty set for non recurring schedules required start_time str the start time of the schedule required end_time str the end time of the schedule required Source code in src/aioswitcher/schedule/parser.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @final @dataclass class SwitcherSchedule : \"\"\"representation of the Switcher schedule slot. Args: schedule_id: the id of the schedule recurring: is a recurring schedule days: a set of schedule days, or empty set for non recurring schedules start_time: the start time of the schedule end_time: the end time of the schedule \"\"\" schedule_id : str recurring : bool days : Set [ Days ] start_time : str end_time : str duration : str = field ( init = False ) display : str = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization, set duration and display.\"\"\" self . duration = tools . calc_duration ( self . start_time , self . end_time ) self . display = tools . pretty_next_run ( self . start_time , self . days ) def __hash__ ( self ) -> int : \"\"\"For usage with set, implementation of the __hash__ magic method.\"\"\" return hash ( self . schedule_id ) def __eq__ ( self , obj : object ) -> bool : \"\"\"For usage with set, implementation of the __eq__ magic method.\"\"\" if isinstance ( obj , SwitcherSchedule ): return self . schedule_id == obj . schedule_id return False","title":"Home"},{"location":"#aioswitcher-documentation","text":"","title":"aioswitcher documentation"},{"location":"#install","text":"pip install aioswitcher","title":"Install"},{"location":"#usage","text":"","title":"Usage"},{"location":"#bridge","text":"We can use the Bridge implementation to discover devices and their state. The following code will print all discovered devices for 60 seconds. async def print_devices ( delay ): def on_device_found_callback ( device ): print ( asdict ( device )) async with SwitcherBridge ( on_device_found_callback ): await asyncio . sleep ( delay ) asyncio . get_event_loop () . run_until_complete ( print_devices ( 60 )) Note A Switcher device will broadcast every 4 seconds. Discovered devices can either be a Power Plug or a Power Plug","title":"Bridge"},{"location":"#api","text":"","title":"API"},{"location":"#type1-api-switcher-plug-v2-touch-v4","text":"We can use the Type1 API to gain the following capabilities: Get the current state Turn on and off Set the name Configure auto shutdown Retrieve the schedules Create and Delete schedules async def control_device ( device_ip , device_id ) : # for connecting to a device we need its id and ip address async with SwitcherType1Api ( device_ip , device_id ) as api : # get the device current state await api . get_state () # turn the device on for 15 await api . control_device ( Command . ON , 15 ) # turn the device off await api . control_device ( Command . OFF ) # set the device name await api . set_device_name ( \"my new name\" ) # configure the device for 02:30 auto shutdown await api . set_auto_shutdown ( timedelta ( hours = 2 , minutes = 30 )) # get the schedules from the device await api . get_schedules () # delete and existing schedule with id 1 await api . delete_schedule ( \"1\" ) # create a new recurring schedule for 13:00-14:30 executing on sunday and friday await api . create_schedule ( \"13:00\" , \"14:30\" , { Days . SUNDAY , Days . FRIDAY }) asyncio . get_event_loop () . run_until_complete ( control_device ( \"111.222.11.22\" , \"ab1c2d\" ))","title":"Type1 API (Switcher Plug, V2, Touch, V4)"},{"location":"#type2-api-switcher-breeze-and-runner","text":"We can use the Type2 API to gain the following capabilities on Switcher Breeze and Runner: Get the current state Control Runner position Control Breeze (State, Mode, Fan Level, Target Temperature, Vertical Swing) async def control_runner_device ( device_ip , device_id ) : # for connecting to a device we need its id and ip address async with SwitcherType2Api ( device_ip , device_id ) as api : # get the device current state state : SwitcherShutterStateResponse = await api . get_shutter_state () # state.position (int) holds the current position of the shutter # state.direction (ShutterDirection) holds the current direction # open the shutter to 30% await api . set_position ( 30 ) # stop the shutter if currently rolling await api . stop () asyncio . get_event_loop () . run_until_complete ( control_runner_device ( \"192.168.50.98\" , \"f2239a\" )) async def control_breeze_device ( device_ip , device_id ) : # for connecting to a device we need its id and ip address async with SwitcherType2Api ( device_ip , device_id ) as api : # get the device current state response : SwitcherThermostatStateResponse = await api . get_breeze_state () # Control Breeze Device # initialize the Breeze RemoteManager rm = BreezeRemoteManager () # get the remote structure (downloaded from the internet) # alternatively, you can get supply local directory path to the BreezeRemoteManager # and the BreezeRemoteManager will save and cache downloaded remotes into the directory async with ClientSession () as session : remote : BreezeRemote = await rm . get_remote ( response . remote_id , api , session ) # prepare a control command that turns on the Breeze # (24 degree (Celsius), cooling with vertical swing and keep the current Fan Level) command : SwitcherBreezeCommand = remote . get_command ( DeviceState . ON , ThermostatMode . COOL , 24 , resp . fan_level , ThermostatSwing . ON , response . state ) # send command to the device await api . control_breeze_device ( command ) asyncio . get_event_loop () . run_until_complete ( control_breeze_device ( \"192.168.50.77\" , \"3a20b7\" )) Note All requests return a response, you can use the asdict __utility function to get familiarize with the various responses. You can visit the API response messages section and review the various response objects. Note that if a request doesn't have a specific response extending the base response, then the base response is the yielding response.","title":"Type2 API (Switcher Breeze and Runner)"},{"location":"#supported-devices","text":"Info You can find the supported device types stated as this enum members.","title":"Supported Devices"},{"location":"#command-line-scripts","text":"","title":"Command line scripts"},{"location":"#discover-devices","text":"","title":"Discover Devices"},{"location":"#scriptsdiscover_devicespy","text":"usage: discover_devices.py [ -h ] [ delay ] Discover and print info of Switcher devices positional arguments: delay number of seconds to run, defaults to 60 options: -h, --help show this help message and exit","title":"scripts/discover_devices.py"},{"location":"#scriptcontrol_devicepy","text":"usage: control_device.py [ -h ] [ -v ] -d DEVICE_ID -i IP_ADDRESS { get_state,turn_on,turn_off,set_name,set_auto_shutdown,get_schedules,delete_schedule, create_schedule,stop_shutter,set_shutter_position,control_thermostat } ... Control your Switcher device options: -h, --help show this help message and exit -v, --verbose include the raw message -d DEVICE_ID, --device-id DEVICE_ID the identification of the device -i IP_ADDRESS, --ip-address IP_ADDRESS the ip address assigned to the device subcommands: supported actions { get_state,turn_on,turn_off,set_name,set_auto_shutdown,get_schedules,delete_schedule,create_schedule,stop_shutter, set_shutter_position,control_thermostat } get_state get the current state of a device turn_on turn on the device turn_off turn off the device set_name set the name of the device set_auto_shutdown set the auto shutdown property ( 1h-24h ) get_schedules retrive a device schedules delete_schedule delete a device schedule create_schedule create a new schedule stop_shutter stop shutter set_shutter_position set shutter position control_thermostat create a new schedule example usage: python control_device.py -d ab1c2d -i \"111.222.11.22\" get_state python control_device.py -d ab1c2d -i \"111.222.11.22\" turn_on python control_device.py -d ab1c2d -i \"111.222.11.22\" turn_on -t 15 python control_device.py -d ab1c2d -i \"111.222.11.22\" turn_off python control_device.py -d ab1c2d -i \"111.222.11.22\" set_name -n \"My Boiler\" python control_device.py -d ab1c2d -i \"111.222.11.22\" set_auto_shutdown -r 2 -m 30 python control_device.py -d ab1c2d -i \"111.222.11.22\" get_schedules python control_device.py -d ab1c2d -i \"111.222.11.22\" delete_schedule -s 3 python control_device.py -d ab1c2d -i \"111.222.11.22\" create_schedule -n \"14:00\" -f \"14:30\" python control_device.py -d ab1c2d -i \"111.222.11.22\" create_schedule -n \"17:30\" -f \"18:30\" -w Sunday Monday Friday python control_device.py -d f2239a -i \"192.168.50.98\" stop_shutter python control_device.py -d f2239a -i \"192.168.50.98\" set_shutter_position -p 50 python control_device.py -d 3a20b7 -i \"192.168.50.77\" control_thermostat -m dry python control_device.py -d 3a20b7 -i \"192.168.50.77\" control_thermostat -s off","title":"script/control_device.py"},{"location":"#scriptcontrol_devicepy-create_schedule","text":"usage: control_device.py create_schedule [ -h ] -n START_TIME -f END_TIME [ -w [{ Monday,Tuesday,Wednesday,Thursday,Friday, Saturday,Sunday } ... ]] options: -h, --help show this help message and exit -n START_TIME, --start-time START_TIME the on time for the schedule, e.g. 13 :00 -f END_TIME, --end-time END_TIME the off time for the schedule, e.g. 13 :30 -w [{ Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday } ... ] , --weekdays [{ Monday,Tuesday,Wednesday,Thursday, Friday,Saturday,Sunday } ... ] days for recurring schedules, possible values: [ 'Monday' , 'Tuesday' , 'Wednesday' , 'Thursday' , 'Friday' , 'Saturday' , 'Sunday' ]","title":"script/control_device.py create_schedule"},{"location":"#scriptcontrol_devicepy-delete_schedule","text":"usage: control_device.py delete_schedule [ -h ] -s SCHEDULE_ID options: -h, --help show this help message and exit -s SCHEDULE_ID, --schedule-id SCHEDULE_ID the id of the schedule for deletion","title":"script/control_device.py delete_schedule"},{"location":"#scriptcontrol_devicepy-get_schedules","text":"usage: control_device.py get_schedules [ -h ] options: -h, --help show this help message and exit","title":"script/control_device.py get_schedules"},{"location":"#scriptcontrol_devicepy-get_state","text":"usage: control_device.py get_state [ -h ] options: -h, --help show this help message and exit","title":"script/control_device.py get_state"},{"location":"#scriptcontrol_devicepy-set_auto_shutdown","text":"usage: control_device.py set_auto_shutdown [ -h ] -r HOURS [ -m [ MINUTES ]] options: -h, --help show this help message and exit -r HOURS, --hours HOURS number hours for the auto shutdown -m [ MINUTES ] , --minutes [ MINUTES ] number hours for the auto shutdown","title":"script/control_device.py set_auto_shutdown"},{"location":"#scriptcontrol_devicepy-set_name","text":"usage: control_device.py set_name [ -h ] -n NAME options: -h, --help show this help message and exit -n NAME, --name NAME new name for the device","title":"script/control_device.py set_name"},{"location":"#scriptcontrol_devicepy-turn_off","text":"usage: control_device.py turn_off [ -h ] options: -h, --help show this help message and exit","title":"script/control_device.py turn_off"},{"location":"#scriptcontrol_devicepy-turn_on","text":"usage: control_device.py turn_on [ -h ] [ -t [ TIMER ]] options: -h, --help show this help message and exit -t [ TIMER ] , --timer [ TIMER ] set minutes timer for turn on operation","title":"script/control_device.py turn_on"},{"location":"#scriptcontrol_devicepy-set_shutter_position","text":"usage: control_device.py set_shutter_position [ -h ] -p POSITION options: -h, --help show this help message and exit -p POSITION, --position POSITION Shutter position percentage","title":"script/control_device.py set_shutter_position"},{"location":"#scriptcontrol_devicepy-stop_shutter","text":"usage: control_device.py stop_shutter [ -h ] options: -h, --help show this help message and exit","title":"script/control_device.py stop_shutter"},{"location":"#scriptcontrol_devicepy-control_thermostat","text":"usage: control_device.py control_thermostat [ -h ] [ -s { on,off }] [ -m { auto,dry,fan,cool,heat }] [ -f { low,medium,high,auto }] [ -w { off,on }] [ -t TEMPERATURE ] options: -h, --help show this help message and exit -s { on,off } , --state { on,off } thermostat state, possible values -m { auto,dry,fan,cool,heat } , --mode { auto,dry,fan,cool,heat } thermostat mode -f { low,medium,high,auto } , --fan-level { low,medium,high,auto } thermostat fan level -w { off,on } , --swing { off,on } thermostat swing -t TEMPERATURE, --temperature TEMPERATURE thermostat temperature","title":"script/control_device.py control_thermostat"},{"location":"#code-documentation","text":"","title":"Code documentation"},{"location":"#aioswitcherapi","text":"","title":"aioswitcher.api"},{"location":"#command","text":"Bases: Enum Enum for turning the device on or off. Source code in src/aioswitcher/api/__init__.py 87 88 89 90 91 92 @unique class Command ( Enum ): \"\"\"Enum for turning the device on or off.\"\"\" ON = \"1\" OFF = \"0\"","title":"Command"},{"location":"#switcherapi","text":"Switcher TCP based API. Parameters: Name Type Description Default ip_address str the ip address assigned to the device. required device_id str the id of the desired device. required port int the port of the device, default is 9957. 9957 Source code in src/aioswitcher/api/__init__.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 class SwitcherApi : \"\"\"Switcher TCP based API. Args: ip_address: the ip address assigned to the device. device_id: the id of the desired device. port: the port of the device, default is 9957. \"\"\" def __init__ ( self , ip_address : str , device_id : str , port : int = 9957 ) -> None : \"\"\"Initialize the Switcher TCP connection API.\"\"\" self . _ip_address = ip_address self . _device_id = device_id self . _port = port self . _connected = False async def __aenter__ ( self ) -> \"SwitcherApi\" : \"\"\"Enter SwitcherApi asynchronous context manager. Returns: This instance of ``aioswitcher.api.SwitcherApi``. \"\"\" await self . connect () return self async def __aexit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc_value : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : \"\"\"Exit SwitcherApi asynchronous context manager.\"\"\" await self . disconnect () async def connect ( self ) -> None : \"\"\"Connect to asynchronous socket and get reader and writer object.\"\"\" logger . info ( \"connecting to the switcher device\" ) self . _reader , self . _writer = await open_connection ( host = self . _ip_address , port = self . _port , family = AF_INET , ) self . _connected = True logger . info ( \"switcher device connected\" ) async def disconnect ( self ) -> None : \"\"\"Disconnect from asynchronous socket.\"\"\" if hasattr ( self , \"_writer\" ) and self . _writer : logger . info ( \"disconnecting from the switcher device\" ) self . _writer . close () await self . _writer . wait_closed () else : logger . info ( \"switcher device not connected\" ) self . _connected = False @property def connected ( self ) -> bool : \"\"\"Return true if api is connected.\"\"\" return self . _connected async def _login ( self , device_type : DeviceType = None ) -> Tuple [ str , SwitcherLoginResponse ]: \"\"\"Use for sending the login packet to the device. Returns: A tuple of the hex timestamp and an instance of ``SwitcherLoginResponse``. Note: This is a private function used by other functions, do not call this function directly. \"\"\" timestamp = current_timestamp_to_hexadecimal () if ( device_type and device_type == DeviceType . BREEZE or device_type == DeviceType . RUNNER or device_type == DeviceType . RUNNER_MINI ): packet = packets . LOGIN2_PACKET_TYPE2 . format ( timestamp , self . _device_id ) else : packet = packets . LOGIN_PACKET_TYPE1 . format ( timestamp ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a login packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return timestamp , SwitcherLoginResponse ( response ) async def get_state ( self ) -> SwitcherStateResponse : \"\"\"Use for sending the get state packet to the device. Returns: An instance of ``SwitcherStateResponse``. \"\"\" timestamp , login_resp = await self . _login () if login_resp . successful : packet = packets . GET_STATE_PACKET_TYPE1 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) async def get_breeze_state ( self ) -> SwitcherThermostatStateResponse : \"\"\"Use for sending the get state packet to the Breeze device. Returns: An instance of ``SwitcherThermostatStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherThermostatStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get breeze state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) async def get_shutter_state ( self ) -> SwitcherShutterStateResponse : \"\"\"Use for sending the get state packet to the Runner device. Returns: An instance of ``SwitcherShutterStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherShutterStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get shutter state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) async def control_device ( self , command : Command , minutes : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the device. Args: command: use the ``aioswitcher.api.Command`` enum. minutes: if turning-on optionally incorporate a timer. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () timer = ( minutes_to_hexadecimal_seconds ( minutes ) if minutes > 0 else packets . NO_TIMER_REQUESTED ) packet = packets . SEND_CONTROL_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . value , timer , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def control_breeze_device ( self , command : SwitcherBreezeCommand , ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the Breeze device. Args: command: use the ``aioswitcher.api.SwitcherBreezeCommand`` class. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send Breeze command\" ) timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if not login_resp . successful : logger . error ( \"Failed to log into device id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . BREEZE_COMMAND_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . length , command . command , ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def set_auto_shutdown ( self , full_time : timedelta ) -> SwitcherBaseResponse : \"\"\"Use for sending the set auto-off packet to the device. Args: full_time: timedelta value containing the configuration value for auto-shutdown. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () auto_shutdown = timedelta_to_hexadecimal_seconds ( full_time ) packet = packets . SET_AUTO_OFF_SET_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , auto_shutdown , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set auto shutdown packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def set_device_name ( self , name : str ) -> SwitcherBaseResponse : \"\"\"Use for sending the set name packet to the device. Args: name: string name with the length of 2 >= x >= 32. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () device_name = string_to_hexadecimale_device_name ( name ) packet = packets . UPDATE_DEVICE_NAME_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , device_name , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set name packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def get_schedules ( self ) -> SwitcherGetSchedulesResponse : \"\"\"Use for retrieval of the schedules from the device. Returns: An instance of ``SwitcherGetSchedulesResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . GET_SCHEDULES_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get schedules packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherGetSchedulesResponse ( response ) async def delete_schedule ( self , schedule_id : str ) -> SwitcherBaseResponse : \"\"\"Use for deleting a schedule from the device. Use ``get_schedules`` to retrieve the schedule instance. Args: schedule_id: the identification of the schedule for deletion. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . DELETE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , schedule_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a delete schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def create_schedule ( self , start_time : str , end_time : str , days : Set [ Days ] = set () ) -> SwitcherBaseResponse : \"\"\"Use for creating a new schedule in the next empty schedule slot. Args: start_time: a string start time in %H:%M format. e.g. 13:00. end_time: a string start time in %H:%M format. e.g. 13:00. days: for recurring schedules, add ``Days``. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () start_time_hex = time_to_hexadecimal_timestamp ( start_time ) end_time_hex = time_to_hexadecimal_timestamp ( end_time ) weekdays = ( weekdays_to_hexadecimal ( days ) if len ( days ) > 0 else packets . NON_RECURRING_SCHEDULE ) new_schedule = packets . SCHEDULE_CREATE_DATA_FORMAT . format ( weekdays , start_time_hex , end_time_hex ) packet = packets . CREATE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , new_schedule , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a create schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def set_position ( self , position : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for setting the shutter position of the Runner and Runner Mini devices. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" hex_pos = \"{0:0 {1} x}\" . format ( position , 2 ) logger . debug ( \"about to send set position command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_SET_POSITION . format ( login_resp . session_id , timestamp , self . _device_id , hex_pos ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def stop ( self ) -> SwitcherBaseResponse : \"\"\"Use for stopping the shutter. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send stop shutter command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_STOP_COMMAND . format ( login_resp . session_id , timestamp , self . _device_id ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a stop control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"SwitcherApi"},{"location":"#src.aioswitcher.api.SwitcherApi.connect","text":"Connect to asynchronous socket and get reader and writer object. Source code in src/aioswitcher/api/__init__.py 146 147 148 149 150 151 152 153 154 155 156 async def connect ( self ) -> None : \"\"\"Connect to asynchronous socket and get reader and writer object.\"\"\" logger . info ( \"connecting to the switcher device\" ) self . _reader , self . _writer = await open_connection ( host = self . _ip_address , port = self . _port , family = AF_INET , ) self . _connected = True logger . info ( \"switcher device connected\" )","title":"connect()"},{"location":"#src.aioswitcher.api.SwitcherApi.connected","text":"Return true if api is connected. Source code in src/aioswitcher/api/__init__.py 168 169 170 171 @property def connected ( self ) -> bool : \"\"\"Return true if api is connected.\"\"\" return self . _connected","title":"connected()"},{"location":"#src.aioswitcher.api.SwitcherApi.control_breeze_device","text":"Use for sending the control packet to the Breeze device. Parameters: Name Type Description Default command SwitcherBreezeCommand use the aioswitcher.api.SwitcherBreezeCommand class. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 async def control_breeze_device ( self , command : SwitcherBreezeCommand , ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the Breeze device. Args: command: use the ``aioswitcher.api.SwitcherBreezeCommand`` class. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send Breeze command\" ) timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if not login_resp . successful : logger . error ( \"Failed to log into device id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . BREEZE_COMMAND_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . length , command . command , ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"control_breeze_device()"},{"location":"#src.aioswitcher.api.SwitcherApi.control_device","text":"Use for sending the control packet to the device. Parameters: Name Type Description Default command Command use the aioswitcher.api.Command enum. required minutes int if turning-on optionally incorporate a timer. 0 Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 async def control_device ( self , command : Command , minutes : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the device. Args: command: use the ``aioswitcher.api.Command`` enum. minutes: if turning-on optionally incorporate a timer. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () timer = ( minutes_to_hexadecimal_seconds ( minutes ) if minutes > 0 else packets . NO_TIMER_REQUESTED ) packet = packets . SEND_CONTROL_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . value , timer , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"control_device()"},{"location":"#src.aioswitcher.api.SwitcherApi.create_schedule","text":"Use for creating a new schedule in the next empty schedule slot. Parameters: Name Type Description Default start_time str a string start time in %H:%M format. e.g. 13:00. required end_time str a string start time in %H:%M format. e.g. 13:00. required days Set [ Days ] for recurring schedules, add Days . set() Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 async def create_schedule ( self , start_time : str , end_time : str , days : Set [ Days ] = set () ) -> SwitcherBaseResponse : \"\"\"Use for creating a new schedule in the next empty schedule slot. Args: start_time: a string start time in %H:%M format. e.g. 13:00. end_time: a string start time in %H:%M format. e.g. 13:00. days: for recurring schedules, add ``Days``. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () start_time_hex = time_to_hexadecimal_timestamp ( start_time ) end_time_hex = time_to_hexadecimal_timestamp ( end_time ) weekdays = ( weekdays_to_hexadecimal ( days ) if len ( days ) > 0 else packets . NON_RECURRING_SCHEDULE ) new_schedule = packets . SCHEDULE_CREATE_DATA_FORMAT . format ( weekdays , start_time_hex , end_time_hex ) packet = packets . CREATE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , new_schedule , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a create schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"create_schedule()"},{"location":"#src.aioswitcher.api.SwitcherApi.delete_schedule","text":"Use for deleting a schedule from the device. Use get_schedules to retrieve the schedule instance. Parameters: Name Type Description Default schedule_id str the identification of the schedule for deletion. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 async def delete_schedule ( self , schedule_id : str ) -> SwitcherBaseResponse : \"\"\"Use for deleting a schedule from the device. Use ``get_schedules`` to retrieve the schedule instance. Args: schedule_id: the identification of the schedule for deletion. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . DELETE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , schedule_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a delete schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"delete_schedule()"},{"location":"#src.aioswitcher.api.SwitcherApi.disconnect","text":"Disconnect from asynchronous socket. Source code in src/aioswitcher/api/__init__.py 158 159 160 161 162 163 164 165 166 async def disconnect ( self ) -> None : \"\"\"Disconnect from asynchronous socket.\"\"\" if hasattr ( self , \"_writer\" ) and self . _writer : logger . info ( \"disconnecting from the switcher device\" ) self . _writer . close () await self . _writer . wait_closed () else : logger . info ( \"switcher device not connected\" ) self . _connected = False","title":"disconnect()"},{"location":"#src.aioswitcher.api.SwitcherApi.get_breeze_state","text":"Use for sending the get state packet to the Breeze device. Returns: Type Description SwitcherThermostatStateResponse An instance of SwitcherThermostatStateResponse . Source code in src/aioswitcher/api/__init__.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 async def get_breeze_state ( self ) -> SwitcherThermostatStateResponse : \"\"\"Use for sending the get state packet to the Breeze device. Returns: An instance of ``SwitcherThermostatStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherThermostatStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get breeze state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" )","title":"get_breeze_state()"},{"location":"#src.aioswitcher.api.SwitcherApi.get_schedules","text":"Use for retrieval of the schedules from the device. Returns: Type Description SwitcherGetSchedulesResponse An instance of SwitcherGetSchedulesResponse . Source code in src/aioswitcher/api/__init__.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 async def get_schedules ( self ) -> SwitcherGetSchedulesResponse : \"\"\"Use for retrieval of the schedules from the device. Returns: An instance of ``SwitcherGetSchedulesResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . GET_SCHEDULES_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get schedules packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherGetSchedulesResponse ( response )","title":"get_schedules()"},{"location":"#src.aioswitcher.api.SwitcherApi.get_shutter_state","text":"Use for sending the get state packet to the Runner device. Returns: Type Description SwitcherShutterStateResponse An instance of SwitcherShutterStateResponse . Source code in src/aioswitcher/api/__init__.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 async def get_shutter_state ( self ) -> SwitcherShutterStateResponse : \"\"\"Use for sending the get state packet to the Runner device. Returns: An instance of ``SwitcherShutterStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherShutterStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get shutter state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" )","title":"get_shutter_state()"},{"location":"#src.aioswitcher.api.SwitcherApi.get_state","text":"Use for sending the get state packet to the device. Returns: Type Description SwitcherStateResponse An instance of SwitcherStateResponse . Source code in src/aioswitcher/api/__init__.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 async def get_state ( self ) -> SwitcherStateResponse : \"\"\"Use for sending the get state packet to the device. Returns: An instance of ``SwitcherStateResponse``. \"\"\" timestamp , login_resp = await self . _login () if login_resp . successful : packet = packets . GET_STATE_PACKET_TYPE1 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" )","title":"get_state()"},{"location":"#src.aioswitcher.api.SwitcherApi.set_auto_shutdown","text":"Use for sending the set auto-off packet to the device. Parameters: Name Type Description Default full_time timedelta timedelta value containing the configuration value for auto-shutdown. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 async def set_auto_shutdown ( self , full_time : timedelta ) -> SwitcherBaseResponse : \"\"\"Use for sending the set auto-off packet to the device. Args: full_time: timedelta value containing the configuration value for auto-shutdown. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () auto_shutdown = timedelta_to_hexadecimal_seconds ( full_time ) packet = packets . SET_AUTO_OFF_SET_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , auto_shutdown , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set auto shutdown packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"set_auto_shutdown()"},{"location":"#src.aioswitcher.api.SwitcherApi.set_device_name","text":"Use for sending the set name packet to the device. Parameters: Name Type Description Default name str string name with the length of 2 >= x >= 32. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 async def set_device_name ( self , name : str ) -> SwitcherBaseResponse : \"\"\"Use for sending the set name packet to the device. Args: name: string name with the length of 2 >= x >= 32. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () device_name = string_to_hexadecimale_device_name ( name ) packet = packets . UPDATE_DEVICE_NAME_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , device_name , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set name packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"set_device_name()"},{"location":"#src.aioswitcher.api.SwitcherApi.set_position","text":"Use for setting the shutter position of the Runner and Runner Mini devices. Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 async def set_position ( self , position : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for setting the shutter position of the Runner and Runner Mini devices. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" hex_pos = \"{0:0 {1} x}\" . format ( position , 2 ) logger . debug ( \"about to send set position command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_SET_POSITION . format ( login_resp . session_id , timestamp , self . _device_id , hex_pos ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"set_position()"},{"location":"#src.aioswitcher.api.SwitcherApi.stop","text":"Use for stopping the shutter. Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 async def stop ( self ) -> SwitcherBaseResponse : \"\"\"Use for stopping the shutter. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send stop shutter command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_STOP_COMMAND . format ( login_resp . session_id , timestamp , self . _device_id ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a stop control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"stop()"},{"location":"#aioswitcherapimessages","text":"","title":"aioswitcher.api.messages"},{"location":"#switcherbaseresponse","text":"Representation of the switcher base response message. Applicable for all messages that do no require post initialization. e.g. not applicable for SwitcherLoginResponse, SwitcherStateResponse, SwitcherGetScheduleResponse. Parameters: Name Type Description Default unparsed_response bytes the raw response from the device. required Source code in src/aioswitcher/api/messages.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 @dataclass class SwitcherBaseResponse : \"\"\"Representation of the switcher base response message. Applicable for all messages that do no require post initialization. e.g. not applicable for SwitcherLoginResponse, SwitcherStateResponse, SwitcherGetScheduleResponse. Args: unparsed_response: the raw response from the device. \"\"\" unparsed_response : bytes @property def successful ( self ) -> bool : \"\"\"Return true if the response is not empty. Partially indicating the request was successful. \"\"\" return self . unparsed_response is not None and len ( self . unparsed_response ) > 0","title":"SwitcherBaseResponse"},{"location":"#src.aioswitcher.api.messages.SwitcherBaseResponse.successful","text":"Return true if the response is not empty. Partially indicating the request was successful. Source code in src/aioswitcher/api/messages.py 160 161 162 163 164 165 166 @property def successful ( self ) -> bool : \"\"\"Return true if the response is not empty. Partially indicating the request was successful. \"\"\" return self . unparsed_response is not None and len ( self . unparsed_response ) > 0","title":"successful()"},{"location":"#switcherloginresponse","text":"Bases: SwitcherBaseResponse Representations of the switcher login response message. Source code in src/aioswitcher/api/messages.py 169 170 171 172 173 174 175 176 177 178 179 180 181 @final @dataclass class SwitcherLoginResponse ( SwitcherBaseResponse ): \"\"\"Representations of the switcher login response message.\"\"\" session_id : str = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization of the response.\"\"\" try : self . session_id = hexlify ( self . unparsed_response )[ 16 : 24 ] . decode () except Exception as exc : raise ValueError ( \"failed to parse login response message\" ) from exc","title":"SwitcherLoginResponse"},{"location":"#switcherstateresponse","text":"Bases: SwitcherBaseResponse Representation of the switcher state response message. Source code in src/aioswitcher/api/messages.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 @final @dataclass class SwitcherStateResponse ( SwitcherBaseResponse ): \"\"\"Representation of the switcher state response message.\"\"\" state : DeviceState = field ( init = False ) time_left : str = field ( init = False ) time_on : str = field ( init = False ) auto_shutdown : str = field ( init = False ) power_consumption : int = field ( init = False ) electric_current : float = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization of the message.\"\"\" parser = StateMessageParser ( self . unparsed_response ) self . state = parser . get_state () self . time_left = parser . get_time_left () self . time_on = parser . get_time_on () self . auto_shutdown = parser . get_auto_shutdown () self . power_consumption = parser . get_power_consumption () self . electric_current = watts_to_amps ( self . power_consumption )","title":"SwitcherStateResponse"},{"location":"#switchergetschedulesresponse","text":"Bases: SwitcherBaseResponse Representation of the switcher get schedule message. Source code in src/aioswitcher/api/messages.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 @final @dataclass class SwitcherGetSchedulesResponse ( SwitcherBaseResponse ): \"\"\"Representation of the switcher get schedule message.\"\"\" schedules : Set [ SwitcherSchedule ] = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization of the message.\"\"\" self . schedules = get_schedules ( self . unparsed_response ) @property def found_schedules ( self ) -> bool : \"\"\"Return true if found schedules in the response.\"\"\" return len ( self . schedules ) > 0","title":"SwitcherGetSchedulesResponse"},{"location":"#src.aioswitcher.api.messages.SwitcherGetSchedulesResponse.found_schedules","text":"Return true if found schedules in the response. Source code in src/aioswitcher/api/messages.py 219 220 221 222 @property def found_schedules ( self ) -> bool : \"\"\"Return true if found schedules in the response.\"\"\" return len ( self . schedules ) > 0","title":"found_schedules()"},{"location":"#aioswitcherbridge","text":"","title":"aioswitcher.bridge"},{"location":"#switcherbridge","text":"Use for running a UDP client for bridging Switcher devices broadcast messages. Parameters: Name Type Description Default on_device Callable [[ SwitcherBase ], Any ] a callable to which every new SwitcherBase device found will be send. required broadcast_ports list [ int ] broadcast ports list, default for type 1 devices is 20002, default for type 2 devices is 20003 [SWITCHER_UDP_PORT_TYPE1, SWITCHER_UDP_PORT_TYPE2] Source code in src/aioswitcher/bridge.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @final class SwitcherBridge : \"\"\"Use for running a UDP client for bridging Switcher devices broadcast messages. Args: on_device: a callable to which every new SwitcherBase device found will be send. broadcast_ports: broadcast ports list, default for type 1 devices is 20002, default for type 2 devices is 20003 \"\"\" def __init__ ( self , on_device : Callable [[ SwitcherBase ], Any ], broadcast_ports : list [ int ] = [ SWITCHER_UDP_PORT_TYPE1 , SWITCHER_UDP_PORT_TYPE2 ], ) -> None : \"\"\"Initialize the switcher bridge.\"\"\" self . _on_device = on_device self . _broadcast_ports = broadcast_ports self . _is_running = False self . _transports = {} # type: Dict[int, Optional[BaseTransport]] async def __aenter__ ( self ) -> \"SwitcherBridge\" : \"\"\"Enter SwitcherBridge asynchronous context manager.\"\"\" await self . start () return self async def __aexit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc_value : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : \"\"\"Exit the SwitcherBridge asynchronous context manager.\"\"\" await self . stop () async def start ( self ) -> None : \"\"\"Create an asynchronous listener and start the bridge.\"\"\" for broadcast_port in self . _broadcast_ports : logger . info ( \"starting the udp bridge on port %s \" , broadcast_port ) protocol_factory = UdpClientProtocol ( partial ( _parse_device_from_datagram , self . _on_device ) ) transport , protocol = await get_running_loop () . create_datagram_endpoint ( lambda : protocol_factory , local_addr = ( \"0.0.0.0\" , broadcast_port ), # nosec family = AF_INET , ) self . _transports [ broadcast_port ] = transport logger . debug ( \"udp bridge on port %s started\" , broadcast_port ) self . _is_running = True async def stop ( self ) -> None : \"\"\"Stop the asynchronous bridge.\"\"\" for broadcast_port in self . _broadcast_ports : transport = self . _transports . get ( broadcast_port ) if transport and not transport . is_closing (): logger . info ( \"stopping the udp bridge on port %s \" , broadcast_port ) transport . close () else : logger . info ( \"udp bridge on port %s not started\" , broadcast_port ) self . _is_running = False @property def is_running ( self ) -> bool : \"\"\"bool: Return true if bridge is running.\"\"\" return self . _is_running","title":"SwitcherBridge"},{"location":"#src.aioswitcher.bridge.SwitcherBridge.is_running","text":"bool: Return true if bridge is running. Source code in src/aioswitcher/bridge.py 228 229 230 231 @property def is_running ( self ) -> bool : \"\"\"bool: Return true if bridge is running.\"\"\" return self . _is_running","title":"is_running()"},{"location":"#src.aioswitcher.bridge.SwitcherBridge.start","text":"Create an asynchronous listener and start the bridge. Source code in src/aioswitcher/bridge.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 async def start ( self ) -> None : \"\"\"Create an asynchronous listener and start the bridge.\"\"\" for broadcast_port in self . _broadcast_ports : logger . info ( \"starting the udp bridge on port %s \" , broadcast_port ) protocol_factory = UdpClientProtocol ( partial ( _parse_device_from_datagram , self . _on_device ) ) transport , protocol = await get_running_loop () . create_datagram_endpoint ( lambda : protocol_factory , local_addr = ( \"0.0.0.0\" , broadcast_port ), # nosec family = AF_INET , ) self . _transports [ broadcast_port ] = transport logger . debug ( \"udp bridge on port %s started\" , broadcast_port ) self . _is_running = True","title":"start()"},{"location":"#src.aioswitcher.bridge.SwitcherBridge.stop","text":"Stop the asynchronous bridge. Source code in src/aioswitcher/bridge.py 215 216 217 218 219 220 221 222 223 224 225 226 async def stop ( self ) -> None : \"\"\"Stop the asynchronous bridge.\"\"\" for broadcast_port in self . _broadcast_ports : transport = self . _transports . get ( broadcast_port ) if transport and not transport . is_closing (): logger . info ( \"stopping the udp bridge on port %s \" , broadcast_port ) transport . close () else : logger . info ( \"udp bridge on port %s not started\" , broadcast_port ) self . _is_running = False","title":"stop()"},{"location":"#aioswitcherdevice","text":"","title":"aioswitcher.device"},{"location":"#devicecategory","text":"Bases: Enum Enum for relaying the device category. Source code in src/aioswitcher/device/__init__.py 24 25 26 27 28 29 30 31 @unique class DeviceCategory ( Enum ): \"\"\"Enum for relaying the device category.\"\"\" WATER_HEATER = auto () POWER_PLUG = auto () THERMOSTAT = auto () SHUTTER = auto ()","title":"DeviceCategory"},{"location":"#devicetype","text":"Bases: Enum Enum for relaying the type of the switcher devices. Source code in src/aioswitcher/device/__init__.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @unique class DeviceType ( Enum ): \"\"\"Enum for relaying the type of the switcher devices.\"\"\" MINI = \"Switcher Mini\" , \"030f\" , 1 , DeviceCategory . WATER_HEATER POWER_PLUG = \"Switcher Power Plug\" , \"01a8\" , 1 , DeviceCategory . POWER_PLUG TOUCH = \"Switcher Touch\" , \"030b\" , 1 , DeviceCategory . WATER_HEATER V2_ESP = \"Switcher V2 (esp)\" , \"01a7\" , 1 , DeviceCategory . WATER_HEATER V2_QCA = \"Switcher V2 (qualcomm)\" , \"01a1\" , 1 , DeviceCategory . WATER_HEATER V4 = \"Switcher V4\" , \"0317\" , 1 , DeviceCategory . WATER_HEATER BREEZE = \"Switcher Breeze\" , \"0e01\" , 2 , DeviceCategory . THERMOSTAT RUNNER = \"Switcher Runner\" , \"0c01\" , 2 , DeviceCategory . SHUTTER RUNNER_MINI = \"Switcher Runner Mini\" , \"0c02\" , 2 , DeviceCategory . SHUTTER def __new__ ( cls , value : str , hex_rep : str , protocol_type : int , category : DeviceCategory ) -> \"DeviceType\" : \"\"\"Override the default enum constructor and include extra properties.\"\"\" new_enum = object . __new__ ( cls ) new_enum . _value = value # type: ignore new_enum . _hex_rep = hex_rep # type: ignore new_enum . _protocol_type = protocol_type # type: ignore new_enum . _category = category # type: ignore return new_enum @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore @property def hex_rep ( self ) -> str : \"\"\"Return the hexadecimal representation of the device type.\"\"\" return self . _hex_rep # type: ignore @property def protocol_type ( self ) -> int : \"\"\"Return the protocol type of the device.\"\"\" return self . _protocol_type # type: ignore @property def category ( self ) -> DeviceCategory : \"\"\"Return the category of the device type.\"\"\" return self . _category # type: ignore","title":"DeviceType"},{"location":"#src.aioswitcher.device.DeviceType.category","text":"Return the category of the device type. Source code in src/aioswitcher/device/__init__.py 74 75 76 77 @property def category ( self ) -> DeviceCategory : \"\"\"Return the category of the device type.\"\"\" return self . _category # type: ignore","title":"category()"},{"location":"#src.aioswitcher.device.DeviceType.hex_rep","text":"Return the hexadecimal representation of the device type. Source code in src/aioswitcher/device/__init__.py 64 65 66 67 @property def hex_rep ( self ) -> str : \"\"\"Return the hexadecimal representation of the device type.\"\"\" return self . _hex_rep # type: ignore","title":"hex_rep()"},{"location":"#src.aioswitcher.device.DeviceType.protocol_type","text":"Return the protocol type of the device. Source code in src/aioswitcher/device/__init__.py 69 70 71 72 @property def protocol_type ( self ) -> int : \"\"\"Return the protocol type of the device.\"\"\" return self . _protocol_type # type: ignore","title":"protocol_type()"},{"location":"#src.aioswitcher.device.DeviceType.value","text":"Return the value of the state. Source code in src/aioswitcher/device/__init__.py 59 60 61 62 @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore","title":"value()"},{"location":"#devicestate","text":"Bases: Enum Enum class representing the device's state. Source code in src/aioswitcher/device/__init__.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @unique class DeviceState ( Enum ): \"\"\"Enum class representing the device's state.\"\"\" ON = \"01\" , \"on\" OFF = \"00\" , \"off\" def __new__ ( cls , value : str , display : str ) -> \"DeviceState\" : \"\"\"Override the default enum constructor and include extra properties.\"\"\" new_enum = object . __new__ ( cls ) new_enum . _value = value # type: ignore new_enum . _display = display # type: ignore return new_enum @property def display ( self ) -> str : \"\"\"Return the display name of the state.\"\"\" return self . _display # type: ignore @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore","title":"DeviceState"},{"location":"#src.aioswitcher.device.DeviceState.display","text":"Return the display name of the state. Source code in src/aioswitcher/device/__init__.py 94 95 96 97 @property def display ( self ) -> str : \"\"\"Return the display name of the state.\"\"\" return self . _display # type: ignore","title":"display()"},{"location":"#src.aioswitcher.device.DeviceState.value","text":"Return the value of the state. Source code in src/aioswitcher/device/__init__.py 99 100 101 102 @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore","title":"value()"},{"location":"#switcherpowerplug","text":"Bases: SwitcherPowerBase , SwitcherBase Implementation of the Switcher Power Plug device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. Source code in src/aioswitcher/device/__init__.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 @final @dataclass class SwitcherPowerPlug ( SwitcherPowerBase , SwitcherBase ): \"\"\"Implementation of the Switcher Power Plug device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. \"\"\" def __post_init__ ( self ) -> None : \"\"\"Post initialization validate device type category as POWER_PLUG.\"\"\" if self . device_type . category != DeviceCategory . POWER_PLUG : raise ValueError ( \"only power plugs are allowed\" ) super () . __post_init__ ()","title":"SwitcherPowerPlug"},{"location":"#switcherwaterheater","text":"Bases: SwitcherTimedBase , SwitcherPowerBase , SwitcherBase Implementation of the Switcher Water Heater device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. Source code in src/aioswitcher/device/__init__.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 @final @dataclass class SwitcherWaterHeater ( SwitcherTimedBase , SwitcherPowerBase , SwitcherBase ): \"\"\"Implementation of the Switcher Water Heater device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. \"\"\" def __post_init__ ( self ) -> None : \"\"\"Post initialization validate device type category as WATER_HEATER.\"\"\" if self . device_type . category != DeviceCategory . WATER_HEATER : raise ValueError ( \"only water heaters are allowed\" ) super () . __post_init__ ()","title":"SwitcherWaterHeater"},{"location":"#aioswitcherschedule","text":"Bases: Enum Enum class representing the day entity. Source code in src/aioswitcher/schedule/__init__.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @unique class Days ( Enum ): \"\"\"Enum class representing the day entity.\"\"\" MONDAY = ( \"Monday\" , 0x02 , 2 , 0 ) TUESDAY = ( \"Tuesday\" , 0x04 , 4 , 1 ) WEDNESDAY = ( \"Wednesday\" , 0x08 , 8 , 2 ) THURSDAY = ( \"Thursday\" , 0x10 , 16 , 3 ) FRIDAY = ( \"Friday\" , 0x20 , 32 , 4 ) SATURDAY = ( \"Saturday\" , 0x40 , 64 , 5 ) SUNDAY = ( \"Sunday\" , 0x80 , 128 , 6 ) def __new__ ( cls , value : str , hex_rep : int , bit_rep : int , weekday : int ) -> \"Days\" : \"\"\"Override the default enum constructor and include extra properties.\"\"\" new_enum = object . __new__ ( cls ) new_enum . _value_ = value new_enum . _hex_rep = hex_rep # type: ignore new_enum . _bit_rep = bit_rep # type: ignore new_enum . _weekday = weekday # type: ignore return new_enum @property def bit_rep ( self ) -> int : \"\"\"Return the bit representation of the day.\"\"\" return self . _bit_rep # type: ignore @property def hex_rep ( self ) -> int : \"\"\"Return the hexadecimal representation of the day.\"\"\" return self . _hex_rep # type: ignore @property def weekday ( self ) -> int : \"\"\"Return the weekday of the day.\"\"\" return self . _weekday # type: ignore","title":"aioswitcher.schedule"},{"location":"#src.aioswitcher.schedule.Days.bit_rep","text":"Return the bit representation of the day. Source code in src/aioswitcher/schedule/__init__.py 49 50 51 52 @property def bit_rep ( self ) -> int : \"\"\"Return the bit representation of the day.\"\"\" return self . _bit_rep # type: ignore","title":"bit_rep()"},{"location":"#src.aioswitcher.schedule.Days.hex_rep","text":"Return the hexadecimal representation of the day. Source code in src/aioswitcher/schedule/__init__.py 54 55 56 57 @property def hex_rep ( self ) -> int : \"\"\"Return the hexadecimal representation of the day.\"\"\" return self . _hex_rep # type: ignore","title":"hex_rep()"},{"location":"#src.aioswitcher.schedule.Days.weekday","text":"Return the weekday of the day. Source code in src/aioswitcher/schedule/__init__.py 59 60 61 62 @property def weekday ( self ) -> int : \"\"\"Return the weekday of the day.\"\"\" return self . _weekday # type: ignore representation of the Switcher schedule slot. Parameters: Name Type Description Default schedule_id str the id of the schedule required recurring bool is a recurring schedule required days Set [ Days ] a set of schedule days, or empty set for non recurring schedules required start_time str the start time of the schedule required end_time str the end time of the schedule required Source code in src/aioswitcher/schedule/parser.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @final @dataclass class SwitcherSchedule : \"\"\"representation of the Switcher schedule slot. Args: schedule_id: the id of the schedule recurring: is a recurring schedule days: a set of schedule days, or empty set for non recurring schedules start_time: the start time of the schedule end_time: the end time of the schedule \"\"\" schedule_id : str recurring : bool days : Set [ Days ] start_time : str end_time : str duration : str = field ( init = False ) display : str = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization, set duration and display.\"\"\" self . duration = tools . calc_duration ( self . start_time , self . end_time ) self . display = tools . pretty_next_run ( self . start_time , self . days ) def __hash__ ( self ) -> int : \"\"\"For usage with set, implementation of the __hash__ magic method.\"\"\" return hash ( self . schedule_id ) def __eq__ ( self , obj : object ) -> bool : \"\"\"For usage with set, implementation of the __eq__ magic method.\"\"\" if isinstance ( obj , SwitcherSchedule ): return self . schedule_id == obj . schedule_id return False","title":"weekday()"},{"location":"codedocs/","text":"Code documentation \u2693\ufe0e aioswitcher.api \u2693\ufe0e Command \u2693\ufe0e Bases: Enum Enum for turning the device on or off. Source code in src/aioswitcher/api/__init__.py 87 88 89 90 91 92 @unique class Command ( Enum ): \"\"\"Enum for turning the device on or off.\"\"\" ON = \"1\" OFF = \"0\" SwitcherApi \u2693\ufe0e Switcher TCP based API. Parameters: Name Type Description Default ip_address str the ip address assigned to the device. required device_id str the id of the desired device. required port int the port of the device, default is 9957. 9957 Source code in src/aioswitcher/api/__init__.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 class SwitcherApi : \"\"\"Switcher TCP based API. Args: ip_address: the ip address assigned to the device. device_id: the id of the desired device. port: the port of the device, default is 9957. \"\"\" def __init__ ( self , ip_address : str , device_id : str , port : int = 9957 ) -> None : \"\"\"Initialize the Switcher TCP connection API.\"\"\" self . _ip_address = ip_address self . _device_id = device_id self . _port = port self . _connected = False async def __aenter__ ( self ) -> \"SwitcherApi\" : \"\"\"Enter SwitcherApi asynchronous context manager. Returns: This instance of ``aioswitcher.api.SwitcherApi``. \"\"\" await self . connect () return self async def __aexit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc_value : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : \"\"\"Exit SwitcherApi asynchronous context manager.\"\"\" await self . disconnect () async def connect ( self ) -> None : \"\"\"Connect to asynchronous socket and get reader and writer object.\"\"\" logger . info ( \"connecting to the switcher device\" ) self . _reader , self . _writer = await open_connection ( host = self . _ip_address , port = self . _port , family = AF_INET , ) self . _connected = True logger . info ( \"switcher device connected\" ) async def disconnect ( self ) -> None : \"\"\"Disconnect from asynchronous socket.\"\"\" if hasattr ( self , \"_writer\" ) and self . _writer : logger . info ( \"disconnecting from the switcher device\" ) self . _writer . close () await self . _writer . wait_closed () else : logger . info ( \"switcher device not connected\" ) self . _connected = False @property def connected ( self ) -> bool : \"\"\"Return true if api is connected.\"\"\" return self . _connected async def _login ( self , device_type : DeviceType = None ) -> Tuple [ str , SwitcherLoginResponse ]: \"\"\"Use for sending the login packet to the device. Returns: A tuple of the hex timestamp and an instance of ``SwitcherLoginResponse``. Note: This is a private function used by other functions, do not call this function directly. \"\"\" timestamp = current_timestamp_to_hexadecimal () if ( device_type and device_type == DeviceType . BREEZE or device_type == DeviceType . RUNNER or device_type == DeviceType . RUNNER_MINI ): packet = packets . LOGIN2_PACKET_TYPE2 . format ( timestamp , self . _device_id ) else : packet = packets . LOGIN_PACKET_TYPE1 . format ( timestamp ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a login packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return timestamp , SwitcherLoginResponse ( response ) async def get_state ( self ) -> SwitcherStateResponse : \"\"\"Use for sending the get state packet to the device. Returns: An instance of ``SwitcherStateResponse``. \"\"\" timestamp , login_resp = await self . _login () if login_resp . successful : packet = packets . GET_STATE_PACKET_TYPE1 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) async def get_breeze_state ( self ) -> SwitcherThermostatStateResponse : \"\"\"Use for sending the get state packet to the Breeze device. Returns: An instance of ``SwitcherThermostatStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherThermostatStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get breeze state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) async def get_shutter_state ( self ) -> SwitcherShutterStateResponse : \"\"\"Use for sending the get state packet to the Runner device. Returns: An instance of ``SwitcherShutterStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherShutterStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get shutter state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) async def control_device ( self , command : Command , minutes : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the device. Args: command: use the ``aioswitcher.api.Command`` enum. minutes: if turning-on optionally incorporate a timer. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () timer = ( minutes_to_hexadecimal_seconds ( minutes ) if minutes > 0 else packets . NO_TIMER_REQUESTED ) packet = packets . SEND_CONTROL_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . value , timer , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def control_breeze_device ( self , command : SwitcherBreezeCommand , ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the Breeze device. Args: command: use the ``aioswitcher.api.SwitcherBreezeCommand`` class. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send Breeze command\" ) timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if not login_resp . successful : logger . error ( \"Failed to log into device id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . BREEZE_COMMAND_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . length , command . command , ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def set_auto_shutdown ( self , full_time : timedelta ) -> SwitcherBaseResponse : \"\"\"Use for sending the set auto-off packet to the device. Args: full_time: timedelta value containing the configuration value for auto-shutdown. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () auto_shutdown = timedelta_to_hexadecimal_seconds ( full_time ) packet = packets . SET_AUTO_OFF_SET_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , auto_shutdown , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set auto shutdown packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def set_device_name ( self , name : str ) -> SwitcherBaseResponse : \"\"\"Use for sending the set name packet to the device. Args: name: string name with the length of 2 >= x >= 32. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () device_name = string_to_hexadecimale_device_name ( name ) packet = packets . UPDATE_DEVICE_NAME_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , device_name , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set name packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def get_schedules ( self ) -> SwitcherGetSchedulesResponse : \"\"\"Use for retrieval of the schedules from the device. Returns: An instance of ``SwitcherGetSchedulesResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . GET_SCHEDULES_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get schedules packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherGetSchedulesResponse ( response ) async def delete_schedule ( self , schedule_id : str ) -> SwitcherBaseResponse : \"\"\"Use for deleting a schedule from the device. Use ``get_schedules`` to retrieve the schedule instance. Args: schedule_id: the identification of the schedule for deletion. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . DELETE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , schedule_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a delete schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def create_schedule ( self , start_time : str , end_time : str , days : Set [ Days ] = set () ) -> SwitcherBaseResponse : \"\"\"Use for creating a new schedule in the next empty schedule slot. Args: start_time: a string start time in %H:%M format. e.g. 13:00. end_time: a string start time in %H:%M format. e.g. 13:00. days: for recurring schedules, add ``Days``. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () start_time_hex = time_to_hexadecimal_timestamp ( start_time ) end_time_hex = time_to_hexadecimal_timestamp ( end_time ) weekdays = ( weekdays_to_hexadecimal ( days ) if len ( days ) > 0 else packets . NON_RECURRING_SCHEDULE ) new_schedule = packets . SCHEDULE_CREATE_DATA_FORMAT . format ( weekdays , start_time_hex , end_time_hex ) packet = packets . CREATE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , new_schedule , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a create schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def set_position ( self , position : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for setting the shutter position of the Runner and Runner Mini devices. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" hex_pos = \"{0:0 {1} x}\" . format ( position , 2 ) logger . debug ( \"about to send set position command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_SET_POSITION . format ( login_resp . session_id , timestamp , self . _device_id , hex_pos ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def stop ( self ) -> SwitcherBaseResponse : \"\"\"Use for stopping the shutter. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send stop shutter command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_STOP_COMMAND . format ( login_resp . session_id , timestamp , self . _device_id ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a stop control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) connect () async \u2693\ufe0e Connect to asynchronous socket and get reader and writer object. Source code in src/aioswitcher/api/__init__.py 146 147 148 149 150 151 152 153 154 155 156 async def connect ( self ) -> None : \"\"\"Connect to asynchronous socket and get reader and writer object.\"\"\" logger . info ( \"connecting to the switcher device\" ) self . _reader , self . _writer = await open_connection ( host = self . _ip_address , port = self . _port , family = AF_INET , ) self . _connected = True logger . info ( \"switcher device connected\" ) connected () property \u2693\ufe0e Return true if api is connected. Source code in src/aioswitcher/api/__init__.py 168 169 170 171 @property def connected ( self ) -> bool : \"\"\"Return true if api is connected.\"\"\" return self . _connected control_breeze_device ( command ) async \u2693\ufe0e Use for sending the control packet to the Breeze device. Parameters: Name Type Description Default command SwitcherBreezeCommand use the aioswitcher.api.SwitcherBreezeCommand class. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 async def control_breeze_device ( self , command : SwitcherBreezeCommand , ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the Breeze device. Args: command: use the ``aioswitcher.api.SwitcherBreezeCommand`` class. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send Breeze command\" ) timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if not login_resp . successful : logger . error ( \"Failed to log into device id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . BREEZE_COMMAND_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . length , command . command , ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) control_device ( command , minutes = 0 ) async \u2693\ufe0e Use for sending the control packet to the device. Parameters: Name Type Description Default command Command use the aioswitcher.api.Command enum. required minutes int if turning-on optionally incorporate a timer. 0 Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 async def control_device ( self , command : Command , minutes : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the device. Args: command: use the ``aioswitcher.api.Command`` enum. minutes: if turning-on optionally incorporate a timer. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () timer = ( minutes_to_hexadecimal_seconds ( minutes ) if minutes > 0 else packets . NO_TIMER_REQUESTED ) packet = packets . SEND_CONTROL_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . value , timer , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) create_schedule ( start_time , end_time , days = set ()) async \u2693\ufe0e Use for creating a new schedule in the next empty schedule slot. Parameters: Name Type Description Default start_time str a string start time in %H:%M format. e.g. 13:00. required end_time str a string start time in %H:%M format. e.g. 13:00. required days Set [ Days ] for recurring schedules, add Days . set() Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 async def create_schedule ( self , start_time : str , end_time : str , days : Set [ Days ] = set () ) -> SwitcherBaseResponse : \"\"\"Use for creating a new schedule in the next empty schedule slot. Args: start_time: a string start time in %H:%M format. e.g. 13:00. end_time: a string start time in %H:%M format. e.g. 13:00. days: for recurring schedules, add ``Days``. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () start_time_hex = time_to_hexadecimal_timestamp ( start_time ) end_time_hex = time_to_hexadecimal_timestamp ( end_time ) weekdays = ( weekdays_to_hexadecimal ( days ) if len ( days ) > 0 else packets . NON_RECURRING_SCHEDULE ) new_schedule = packets . SCHEDULE_CREATE_DATA_FORMAT . format ( weekdays , start_time_hex , end_time_hex ) packet = packets . CREATE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , new_schedule , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a create schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) delete_schedule ( schedule_id ) async \u2693\ufe0e Use for deleting a schedule from the device. Use get_schedules to retrieve the schedule instance. Parameters: Name Type Description Default schedule_id str the identification of the schedule for deletion. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 async def delete_schedule ( self , schedule_id : str ) -> SwitcherBaseResponse : \"\"\"Use for deleting a schedule from the device. Use ``get_schedules`` to retrieve the schedule instance. Args: schedule_id: the identification of the schedule for deletion. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . DELETE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , schedule_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a delete schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) disconnect () async \u2693\ufe0e Disconnect from asynchronous socket. Source code in src/aioswitcher/api/__init__.py 158 159 160 161 162 163 164 165 166 async def disconnect ( self ) -> None : \"\"\"Disconnect from asynchronous socket.\"\"\" if hasattr ( self , \"_writer\" ) and self . _writer : logger . info ( \"disconnecting from the switcher device\" ) self . _writer . close () await self . _writer . wait_closed () else : logger . info ( \"switcher device not connected\" ) self . _connected = False get_breeze_state () async \u2693\ufe0e Use for sending the get state packet to the Breeze device. Returns: Type Description SwitcherThermostatStateResponse An instance of SwitcherThermostatStateResponse . Source code in src/aioswitcher/api/__init__.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 async def get_breeze_state ( self ) -> SwitcherThermostatStateResponse : \"\"\"Use for sending the get state packet to the Breeze device. Returns: An instance of ``SwitcherThermostatStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherThermostatStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get breeze state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) get_schedules () async \u2693\ufe0e Use for retrieval of the schedules from the device. Returns: Type Description SwitcherGetSchedulesResponse An instance of SwitcherGetSchedulesResponse . Source code in src/aioswitcher/api/__init__.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 async def get_schedules ( self ) -> SwitcherGetSchedulesResponse : \"\"\"Use for retrieval of the schedules from the device. Returns: An instance of ``SwitcherGetSchedulesResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . GET_SCHEDULES_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get schedules packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherGetSchedulesResponse ( response ) get_shutter_state () async \u2693\ufe0e Use for sending the get state packet to the Runner device. Returns: Type Description SwitcherShutterStateResponse An instance of SwitcherShutterStateResponse . Source code in src/aioswitcher/api/__init__.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 async def get_shutter_state ( self ) -> SwitcherShutterStateResponse : \"\"\"Use for sending the get state packet to the Runner device. Returns: An instance of ``SwitcherShutterStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherShutterStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get shutter state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) get_state () async \u2693\ufe0e Use for sending the get state packet to the device. Returns: Type Description SwitcherStateResponse An instance of SwitcherStateResponse . Source code in src/aioswitcher/api/__init__.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 async def get_state ( self ) -> SwitcherStateResponse : \"\"\"Use for sending the get state packet to the device. Returns: An instance of ``SwitcherStateResponse``. \"\"\" timestamp , login_resp = await self . _login () if login_resp . successful : packet = packets . GET_STATE_PACKET_TYPE1 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) set_auto_shutdown ( full_time ) async \u2693\ufe0e Use for sending the set auto-off packet to the device. Parameters: Name Type Description Default full_time timedelta timedelta value containing the configuration value for auto-shutdown. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 async def set_auto_shutdown ( self , full_time : timedelta ) -> SwitcherBaseResponse : \"\"\"Use for sending the set auto-off packet to the device. Args: full_time: timedelta value containing the configuration value for auto-shutdown. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () auto_shutdown = timedelta_to_hexadecimal_seconds ( full_time ) packet = packets . SET_AUTO_OFF_SET_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , auto_shutdown , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set auto shutdown packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) set_device_name ( name ) async \u2693\ufe0e Use for sending the set name packet to the device. Parameters: Name Type Description Default name str string name with the length of 2 >= x >= 32. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 async def set_device_name ( self , name : str ) -> SwitcherBaseResponse : \"\"\"Use for sending the set name packet to the device. Args: name: string name with the length of 2 >= x >= 32. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () device_name = string_to_hexadecimale_device_name ( name ) packet = packets . UPDATE_DEVICE_NAME_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , device_name , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set name packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) set_position ( position = 0 ) async \u2693\ufe0e Use for setting the shutter position of the Runner and Runner Mini devices. Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 async def set_position ( self , position : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for setting the shutter position of the Runner and Runner Mini devices. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" hex_pos = \"{0:0 {1} x}\" . format ( position , 2 ) logger . debug ( \"about to send set position command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_SET_POSITION . format ( login_resp . session_id , timestamp , self . _device_id , hex_pos ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) stop () async \u2693\ufe0e Use for stopping the shutter. Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 async def stop ( self ) -> SwitcherBaseResponse : \"\"\"Use for stopping the shutter. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send stop shutter command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_STOP_COMMAND . format ( login_resp . session_id , timestamp , self . _device_id ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a stop control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) aioswitcher.api.messages \u2693\ufe0e SwitcherBaseResponse \u2693\ufe0e Representation of the switcher base response message. Applicable for all messages that do no require post initialization. e.g. not applicable for SwitcherLoginResponse, SwitcherStateResponse, SwitcherGetScheduleResponse. Parameters: Name Type Description Default unparsed_response bytes the raw response from the device. required Source code in src/aioswitcher/api/messages.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 @dataclass class SwitcherBaseResponse : \"\"\"Representation of the switcher base response message. Applicable for all messages that do no require post initialization. e.g. not applicable for SwitcherLoginResponse, SwitcherStateResponse, SwitcherGetScheduleResponse. Args: unparsed_response: the raw response from the device. \"\"\" unparsed_response : bytes @property def successful ( self ) -> bool : \"\"\"Return true if the response is not empty. Partially indicating the request was successful. \"\"\" return self . unparsed_response is not None and len ( self . unparsed_response ) > 0 successful () property \u2693\ufe0e Return true if the response is not empty. Partially indicating the request was successful. Source code in src/aioswitcher/api/messages.py 160 161 162 163 164 165 166 @property def successful ( self ) -> bool : \"\"\"Return true if the response is not empty. Partially indicating the request was successful. \"\"\" return self . unparsed_response is not None and len ( self . unparsed_response ) > 0 SwitcherLoginResponse \u2693\ufe0e Bases: SwitcherBaseResponse Representations of the switcher login response message. Source code in src/aioswitcher/api/messages.py 169 170 171 172 173 174 175 176 177 178 179 180 181 @final @dataclass class SwitcherLoginResponse ( SwitcherBaseResponse ): \"\"\"Representations of the switcher login response message.\"\"\" session_id : str = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization of the response.\"\"\" try : self . session_id = hexlify ( self . unparsed_response )[ 16 : 24 ] . decode () except Exception as exc : raise ValueError ( \"failed to parse login response message\" ) from exc SwitcherStateResponse \u2693\ufe0e Bases: SwitcherBaseResponse Representation of the switcher state response message. Source code in src/aioswitcher/api/messages.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 @final @dataclass class SwitcherStateResponse ( SwitcherBaseResponse ): \"\"\"Representation of the switcher state response message.\"\"\" state : DeviceState = field ( init = False ) time_left : str = field ( init = False ) time_on : str = field ( init = False ) auto_shutdown : str = field ( init = False ) power_consumption : int = field ( init = False ) electric_current : float = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization of the message.\"\"\" parser = StateMessageParser ( self . unparsed_response ) self . state = parser . get_state () self . time_left = parser . get_time_left () self . time_on = parser . get_time_on () self . auto_shutdown = parser . get_auto_shutdown () self . power_consumption = parser . get_power_consumption () self . electric_current = watts_to_amps ( self . power_consumption ) SwitcherGetSchedulesResponse \u2693\ufe0e Bases: SwitcherBaseResponse Representation of the switcher get schedule message. Source code in src/aioswitcher/api/messages.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 @final @dataclass class SwitcherGetSchedulesResponse ( SwitcherBaseResponse ): \"\"\"Representation of the switcher get schedule message.\"\"\" schedules : Set [ SwitcherSchedule ] = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization of the message.\"\"\" self . schedules = get_schedules ( self . unparsed_response ) @property def found_schedules ( self ) -> bool : \"\"\"Return true if found schedules in the response.\"\"\" return len ( self . schedules ) > 0 found_schedules () property \u2693\ufe0e Return true if found schedules in the response. Source code in src/aioswitcher/api/messages.py 219 220 221 222 @property def found_schedules ( self ) -> bool : \"\"\"Return true if found schedules in the response.\"\"\" return len ( self . schedules ) > 0 aioswitcher.bridge \u2693\ufe0e SwitcherBridge \u2693\ufe0e Use for running a UDP client for bridging Switcher devices broadcast messages. Parameters: Name Type Description Default on_device Callable [[ SwitcherBase ], Any ] a callable to which every new SwitcherBase device found will be send. required broadcast_ports list [ int ] broadcast ports list, default for type 1 devices is 20002, default for type 2 devices is 20003 [SWITCHER_UDP_PORT_TYPE1, SWITCHER_UDP_PORT_TYPE2] Source code in src/aioswitcher/bridge.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @final class SwitcherBridge : \"\"\"Use for running a UDP client for bridging Switcher devices broadcast messages. Args: on_device: a callable to which every new SwitcherBase device found will be send. broadcast_ports: broadcast ports list, default for type 1 devices is 20002, default for type 2 devices is 20003 \"\"\" def __init__ ( self , on_device : Callable [[ SwitcherBase ], Any ], broadcast_ports : list [ int ] = [ SWITCHER_UDP_PORT_TYPE1 , SWITCHER_UDP_PORT_TYPE2 ], ) -> None : \"\"\"Initialize the switcher bridge.\"\"\" self . _on_device = on_device self . _broadcast_ports = broadcast_ports self . _is_running = False self . _transports = {} # type: Dict[int, Optional[BaseTransport]] async def __aenter__ ( self ) -> \"SwitcherBridge\" : \"\"\"Enter SwitcherBridge asynchronous context manager.\"\"\" await self . start () return self async def __aexit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc_value : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : \"\"\"Exit the SwitcherBridge asynchronous context manager.\"\"\" await self . stop () async def start ( self ) -> None : \"\"\"Create an asynchronous listener and start the bridge.\"\"\" for broadcast_port in self . _broadcast_ports : logger . info ( \"starting the udp bridge on port %s \" , broadcast_port ) protocol_factory = UdpClientProtocol ( partial ( _parse_device_from_datagram , self . _on_device ) ) transport , protocol = await get_running_loop () . create_datagram_endpoint ( lambda : protocol_factory , local_addr = ( \"0.0.0.0\" , broadcast_port ), # nosec family = AF_INET , ) self . _transports [ broadcast_port ] = transport logger . debug ( \"udp bridge on port %s started\" , broadcast_port ) self . _is_running = True async def stop ( self ) -> None : \"\"\"Stop the asynchronous bridge.\"\"\" for broadcast_port in self . _broadcast_ports : transport = self . _transports . get ( broadcast_port ) if transport and not transport . is_closing (): logger . info ( \"stopping the udp bridge on port %s \" , broadcast_port ) transport . close () else : logger . info ( \"udp bridge on port %s not started\" , broadcast_port ) self . _is_running = False @property def is_running ( self ) -> bool : \"\"\"bool: Return true if bridge is running.\"\"\" return self . _is_running is_running () property \u2693\ufe0e bool: Return true if bridge is running. Source code in src/aioswitcher/bridge.py 228 229 230 231 @property def is_running ( self ) -> bool : \"\"\"bool: Return true if bridge is running.\"\"\" return self . _is_running start () async \u2693\ufe0e Create an asynchronous listener and start the bridge. Source code in src/aioswitcher/bridge.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 async def start ( self ) -> None : \"\"\"Create an asynchronous listener and start the bridge.\"\"\" for broadcast_port in self . _broadcast_ports : logger . info ( \"starting the udp bridge on port %s \" , broadcast_port ) protocol_factory = UdpClientProtocol ( partial ( _parse_device_from_datagram , self . _on_device ) ) transport , protocol = await get_running_loop () . create_datagram_endpoint ( lambda : protocol_factory , local_addr = ( \"0.0.0.0\" , broadcast_port ), # nosec family = AF_INET , ) self . _transports [ broadcast_port ] = transport logger . debug ( \"udp bridge on port %s started\" , broadcast_port ) self . _is_running = True stop () async \u2693\ufe0e Stop the asynchronous bridge. Source code in src/aioswitcher/bridge.py 215 216 217 218 219 220 221 222 223 224 225 226 async def stop ( self ) -> None : \"\"\"Stop the asynchronous bridge.\"\"\" for broadcast_port in self . _broadcast_ports : transport = self . _transports . get ( broadcast_port ) if transport and not transport . is_closing (): logger . info ( \"stopping the udp bridge on port %s \" , broadcast_port ) transport . close () else : logger . info ( \"udp bridge on port %s not started\" , broadcast_port ) self . _is_running = False aioswitcher.device \u2693\ufe0e DeviceCategory \u2693\ufe0e Bases: Enum Enum for relaying the device category. Source code in src/aioswitcher/device/__init__.py 24 25 26 27 28 29 30 31 @unique class DeviceCategory ( Enum ): \"\"\"Enum for relaying the device category.\"\"\" WATER_HEATER = auto () POWER_PLUG = auto () THERMOSTAT = auto () SHUTTER = auto () DeviceType \u2693\ufe0e Bases: Enum Enum for relaying the type of the switcher devices. Source code in src/aioswitcher/device/__init__.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @unique class DeviceType ( Enum ): \"\"\"Enum for relaying the type of the switcher devices.\"\"\" MINI = \"Switcher Mini\" , \"030f\" , 1 , DeviceCategory . WATER_HEATER POWER_PLUG = \"Switcher Power Plug\" , \"01a8\" , 1 , DeviceCategory . POWER_PLUG TOUCH = \"Switcher Touch\" , \"030b\" , 1 , DeviceCategory . WATER_HEATER V2_ESP = \"Switcher V2 (esp)\" , \"01a7\" , 1 , DeviceCategory . WATER_HEATER V2_QCA = \"Switcher V2 (qualcomm)\" , \"01a1\" , 1 , DeviceCategory . WATER_HEATER V4 = \"Switcher V4\" , \"0317\" , 1 , DeviceCategory . WATER_HEATER BREEZE = \"Switcher Breeze\" , \"0e01\" , 2 , DeviceCategory . THERMOSTAT RUNNER = \"Switcher Runner\" , \"0c01\" , 2 , DeviceCategory . SHUTTER RUNNER_MINI = \"Switcher Runner Mini\" , \"0c02\" , 2 , DeviceCategory . SHUTTER def __new__ ( cls , value : str , hex_rep : str , protocol_type : int , category : DeviceCategory ) -> \"DeviceType\" : \"\"\"Override the default enum constructor and include extra properties.\"\"\" new_enum = object . __new__ ( cls ) new_enum . _value = value # type: ignore new_enum . _hex_rep = hex_rep # type: ignore new_enum . _protocol_type = protocol_type # type: ignore new_enum . _category = category # type: ignore return new_enum @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore @property def hex_rep ( self ) -> str : \"\"\"Return the hexadecimal representation of the device type.\"\"\" return self . _hex_rep # type: ignore @property def protocol_type ( self ) -> int : \"\"\"Return the protocol type of the device.\"\"\" return self . _protocol_type # type: ignore @property def category ( self ) -> DeviceCategory : \"\"\"Return the category of the device type.\"\"\" return self . _category # type: ignore category () property \u2693\ufe0e Return the category of the device type. Source code in src/aioswitcher/device/__init__.py 74 75 76 77 @property def category ( self ) -> DeviceCategory : \"\"\"Return the category of the device type.\"\"\" return self . _category # type: ignore hex_rep () property \u2693\ufe0e Return the hexadecimal representation of the device type. Source code in src/aioswitcher/device/__init__.py 64 65 66 67 @property def hex_rep ( self ) -> str : \"\"\"Return the hexadecimal representation of the device type.\"\"\" return self . _hex_rep # type: ignore protocol_type () property \u2693\ufe0e Return the protocol type of the device. Source code in src/aioswitcher/device/__init__.py 69 70 71 72 @property def protocol_type ( self ) -> int : \"\"\"Return the protocol type of the device.\"\"\" return self . _protocol_type # type: ignore value () property \u2693\ufe0e Return the value of the state. Source code in src/aioswitcher/device/__init__.py 59 60 61 62 @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore DeviceState \u2693\ufe0e Bases: Enum Enum class representing the device's state. Source code in src/aioswitcher/device/__init__.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @unique class DeviceState ( Enum ): \"\"\"Enum class representing the device's state.\"\"\" ON = \"01\" , \"on\" OFF = \"00\" , \"off\" def __new__ ( cls , value : str , display : str ) -> \"DeviceState\" : \"\"\"Override the default enum constructor and include extra properties.\"\"\" new_enum = object . __new__ ( cls ) new_enum . _value = value # type: ignore new_enum . _display = display # type: ignore return new_enum @property def display ( self ) -> str : \"\"\"Return the display name of the state.\"\"\" return self . _display # type: ignore @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore display () property \u2693\ufe0e Return the display name of the state. Source code in src/aioswitcher/device/__init__.py 94 95 96 97 @property def display ( self ) -> str : \"\"\"Return the display name of the state.\"\"\" return self . _display # type: ignore value () property \u2693\ufe0e Return the value of the state. Source code in src/aioswitcher/device/__init__.py 99 100 101 102 @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore SwitcherPowerPlug \u2693\ufe0e Bases: SwitcherPowerBase , SwitcherBase Implementation of the Switcher Power Plug device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. Source code in src/aioswitcher/device/__init__.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 @final @dataclass class SwitcherPowerPlug ( SwitcherPowerBase , SwitcherBase ): \"\"\"Implementation of the Switcher Power Plug device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. \"\"\" def __post_init__ ( self ) -> None : \"\"\"Post initialization validate device type category as POWER_PLUG.\"\"\" if self . device_type . category != DeviceCategory . POWER_PLUG : raise ValueError ( \"only power plugs are allowed\" ) super () . __post_init__ () SwitcherWaterHeater \u2693\ufe0e Bases: SwitcherTimedBase , SwitcherPowerBase , SwitcherBase Implementation of the Switcher Water Heater device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. Source code in src/aioswitcher/device/__init__.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 @final @dataclass class SwitcherWaterHeater ( SwitcherTimedBase , SwitcherPowerBase , SwitcherBase ): \"\"\"Implementation of the Switcher Water Heater device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. \"\"\" def __post_init__ ( self ) -> None : \"\"\"Post initialization validate device type category as WATER_HEATER.\"\"\" if self . device_type . category != DeviceCategory . WATER_HEATER : raise ValueError ( \"only water heaters are allowed\" ) super () . __post_init__ () aioswitcher.schedule \u2693\ufe0e Bases: Enum Enum class representing the day entity. Source code in src/aioswitcher/schedule/__init__.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @unique class Days ( Enum ): \"\"\"Enum class representing the day entity.\"\"\" MONDAY = ( \"Monday\" , 0x02 , 2 , 0 ) TUESDAY = ( \"Tuesday\" , 0x04 , 4 , 1 ) WEDNESDAY = ( \"Wednesday\" , 0x08 , 8 , 2 ) THURSDAY = ( \"Thursday\" , 0x10 , 16 , 3 ) FRIDAY = ( \"Friday\" , 0x20 , 32 , 4 ) SATURDAY = ( \"Saturday\" , 0x40 , 64 , 5 ) SUNDAY = ( \"Sunday\" , 0x80 , 128 , 6 ) def __new__ ( cls , value : str , hex_rep : int , bit_rep : int , weekday : int ) -> \"Days\" : \"\"\"Override the default enum constructor and include extra properties.\"\"\" new_enum = object . __new__ ( cls ) new_enum . _value_ = value new_enum . _hex_rep = hex_rep # type: ignore new_enum . _bit_rep = bit_rep # type: ignore new_enum . _weekday = weekday # type: ignore return new_enum @property def bit_rep ( self ) -> int : \"\"\"Return the bit representation of the day.\"\"\" return self . _bit_rep # type: ignore @property def hex_rep ( self ) -> int : \"\"\"Return the hexadecimal representation of the day.\"\"\" return self . _hex_rep # type: ignore @property def weekday ( self ) -> int : \"\"\"Return the weekday of the day.\"\"\" return self . _weekday # type: ignore bit_rep () property \u2693\ufe0e Return the bit representation of the day. Source code in src/aioswitcher/schedule/__init__.py 49 50 51 52 @property def bit_rep ( self ) -> int : \"\"\"Return the bit representation of the day.\"\"\" return self . _bit_rep # type: ignore hex_rep () property \u2693\ufe0e Return the hexadecimal representation of the day. Source code in src/aioswitcher/schedule/__init__.py 54 55 56 57 @property def hex_rep ( self ) -> int : \"\"\"Return the hexadecimal representation of the day.\"\"\" return self . _hex_rep # type: ignore weekday () property \u2693\ufe0e Return the weekday of the day. Source code in src/aioswitcher/schedule/__init__.py 59 60 61 62 @property def weekday ( self ) -> int : \"\"\"Return the weekday of the day.\"\"\" return self . _weekday # type: ignore representation of the Switcher schedule slot. Parameters: Name Type Description Default schedule_id str the id of the schedule required recurring bool is a recurring schedule required days Set [ Days ] a set of schedule days, or empty set for non recurring schedules required start_time str the start time of the schedule required end_time str the end time of the schedule required Source code in src/aioswitcher/schedule/parser.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @final @dataclass class SwitcherSchedule : \"\"\"representation of the Switcher schedule slot. Args: schedule_id: the id of the schedule recurring: is a recurring schedule days: a set of schedule days, or empty set for non recurring schedules start_time: the start time of the schedule end_time: the end time of the schedule \"\"\" schedule_id : str recurring : bool days : Set [ Days ] start_time : str end_time : str duration : str = field ( init = False ) display : str = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization, set duration and display.\"\"\" self . duration = tools . calc_duration ( self . start_time , self . end_time ) self . display = tools . pretty_next_run ( self . start_time , self . days ) def __hash__ ( self ) -> int : \"\"\"For usage with set, implementation of the __hash__ magic method.\"\"\" return hash ( self . schedule_id ) def __eq__ ( self , obj : object ) -> bool : \"\"\"For usage with set, implementation of the __eq__ magic method.\"\"\" if isinstance ( obj , SwitcherSchedule ): return self . schedule_id == obj . schedule_id return False","title":"Code documentation"},{"location":"codedocs/#code-documentation","text":"","title":"Code documentation"},{"location":"codedocs/#aioswitcherapi","text":"","title":"aioswitcher.api"},{"location":"codedocs/#command","text":"Bases: Enum Enum for turning the device on or off. Source code in src/aioswitcher/api/__init__.py 87 88 89 90 91 92 @unique class Command ( Enum ): \"\"\"Enum for turning the device on or off.\"\"\" ON = \"1\" OFF = \"0\"","title":"Command"},{"location":"codedocs/#switcherapi","text":"Switcher TCP based API. Parameters: Name Type Description Default ip_address str the ip address assigned to the device. required device_id str the id of the desired device. required port int the port of the device, default is 9957. 9957 Source code in src/aioswitcher/api/__init__.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 class SwitcherApi : \"\"\"Switcher TCP based API. Args: ip_address: the ip address assigned to the device. device_id: the id of the desired device. port: the port of the device, default is 9957. \"\"\" def __init__ ( self , ip_address : str , device_id : str , port : int = 9957 ) -> None : \"\"\"Initialize the Switcher TCP connection API.\"\"\" self . _ip_address = ip_address self . _device_id = device_id self . _port = port self . _connected = False async def __aenter__ ( self ) -> \"SwitcherApi\" : \"\"\"Enter SwitcherApi asynchronous context manager. Returns: This instance of ``aioswitcher.api.SwitcherApi``. \"\"\" await self . connect () return self async def __aexit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc_value : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : \"\"\"Exit SwitcherApi asynchronous context manager.\"\"\" await self . disconnect () async def connect ( self ) -> None : \"\"\"Connect to asynchronous socket and get reader and writer object.\"\"\" logger . info ( \"connecting to the switcher device\" ) self . _reader , self . _writer = await open_connection ( host = self . _ip_address , port = self . _port , family = AF_INET , ) self . _connected = True logger . info ( \"switcher device connected\" ) async def disconnect ( self ) -> None : \"\"\"Disconnect from asynchronous socket.\"\"\" if hasattr ( self , \"_writer\" ) and self . _writer : logger . info ( \"disconnecting from the switcher device\" ) self . _writer . close () await self . _writer . wait_closed () else : logger . info ( \"switcher device not connected\" ) self . _connected = False @property def connected ( self ) -> bool : \"\"\"Return true if api is connected.\"\"\" return self . _connected async def _login ( self , device_type : DeviceType = None ) -> Tuple [ str , SwitcherLoginResponse ]: \"\"\"Use for sending the login packet to the device. Returns: A tuple of the hex timestamp and an instance of ``SwitcherLoginResponse``. Note: This is a private function used by other functions, do not call this function directly. \"\"\" timestamp = current_timestamp_to_hexadecimal () if ( device_type and device_type == DeviceType . BREEZE or device_type == DeviceType . RUNNER or device_type == DeviceType . RUNNER_MINI ): packet = packets . LOGIN2_PACKET_TYPE2 . format ( timestamp , self . _device_id ) else : packet = packets . LOGIN_PACKET_TYPE1 . format ( timestamp ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a login packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return timestamp , SwitcherLoginResponse ( response ) async def get_state ( self ) -> SwitcherStateResponse : \"\"\"Use for sending the get state packet to the device. Returns: An instance of ``SwitcherStateResponse``. \"\"\" timestamp , login_resp = await self . _login () if login_resp . successful : packet = packets . GET_STATE_PACKET_TYPE1 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) async def get_breeze_state ( self ) -> SwitcherThermostatStateResponse : \"\"\"Use for sending the get state packet to the Breeze device. Returns: An instance of ``SwitcherThermostatStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherThermostatStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get breeze state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) async def get_shutter_state ( self ) -> SwitcherShutterStateResponse : \"\"\"Use for sending the get state packet to the Runner device. Returns: An instance of ``SwitcherShutterStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherShutterStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get shutter state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" ) async def control_device ( self , command : Command , minutes : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the device. Args: command: use the ``aioswitcher.api.Command`` enum. minutes: if turning-on optionally incorporate a timer. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () timer = ( minutes_to_hexadecimal_seconds ( minutes ) if minutes > 0 else packets . NO_TIMER_REQUESTED ) packet = packets . SEND_CONTROL_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . value , timer , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def control_breeze_device ( self , command : SwitcherBreezeCommand , ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the Breeze device. Args: command: use the ``aioswitcher.api.SwitcherBreezeCommand`` class. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send Breeze command\" ) timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if not login_resp . successful : logger . error ( \"Failed to log into device id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . BREEZE_COMMAND_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . length , command . command , ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def set_auto_shutdown ( self , full_time : timedelta ) -> SwitcherBaseResponse : \"\"\"Use for sending the set auto-off packet to the device. Args: full_time: timedelta value containing the configuration value for auto-shutdown. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () auto_shutdown = timedelta_to_hexadecimal_seconds ( full_time ) packet = packets . SET_AUTO_OFF_SET_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , auto_shutdown , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set auto shutdown packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def set_device_name ( self , name : str ) -> SwitcherBaseResponse : \"\"\"Use for sending the set name packet to the device. Args: name: string name with the length of 2 >= x >= 32. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () device_name = string_to_hexadecimale_device_name ( name ) packet = packets . UPDATE_DEVICE_NAME_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , device_name , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set name packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def get_schedules ( self ) -> SwitcherGetSchedulesResponse : \"\"\"Use for retrieval of the schedules from the device. Returns: An instance of ``SwitcherGetSchedulesResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . GET_SCHEDULES_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get schedules packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherGetSchedulesResponse ( response ) async def delete_schedule ( self , schedule_id : str ) -> SwitcherBaseResponse : \"\"\"Use for deleting a schedule from the device. Use ``get_schedules`` to retrieve the schedule instance. Args: schedule_id: the identification of the schedule for deletion. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . DELETE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , schedule_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a delete schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def create_schedule ( self , start_time : str , end_time : str , days : Set [ Days ] = set () ) -> SwitcherBaseResponse : \"\"\"Use for creating a new schedule in the next empty schedule slot. Args: start_time: a string start time in %H:%M format. e.g. 13:00. end_time: a string start time in %H:%M format. e.g. 13:00. days: for recurring schedules, add ``Days``. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () start_time_hex = time_to_hexadecimal_timestamp ( start_time ) end_time_hex = time_to_hexadecimal_timestamp ( end_time ) weekdays = ( weekdays_to_hexadecimal ( days ) if len ( days ) > 0 else packets . NON_RECURRING_SCHEDULE ) new_schedule = packets . SCHEDULE_CREATE_DATA_FORMAT . format ( weekdays , start_time_hex , end_time_hex ) packet = packets . CREATE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , new_schedule , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a create schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def set_position ( self , position : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for setting the shutter position of the Runner and Runner Mini devices. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" hex_pos = \"{0:0 {1} x}\" . format ( position , 2 ) logger . debug ( \"about to send set position command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_SET_POSITION . format ( login_resp . session_id , timestamp , self . _device_id , hex_pos ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response ) async def stop ( self ) -> SwitcherBaseResponse : \"\"\"Use for stopping the shutter. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send stop shutter command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_STOP_COMMAND . format ( login_resp . session_id , timestamp , self . _device_id ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a stop control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"SwitcherApi"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.connect","text":"Connect to asynchronous socket and get reader and writer object. Source code in src/aioswitcher/api/__init__.py 146 147 148 149 150 151 152 153 154 155 156 async def connect ( self ) -> None : \"\"\"Connect to asynchronous socket and get reader and writer object.\"\"\" logger . info ( \"connecting to the switcher device\" ) self . _reader , self . _writer = await open_connection ( host = self . _ip_address , port = self . _port , family = AF_INET , ) self . _connected = True logger . info ( \"switcher device connected\" )","title":"connect()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.connected","text":"Return true if api is connected. Source code in src/aioswitcher/api/__init__.py 168 169 170 171 @property def connected ( self ) -> bool : \"\"\"Return true if api is connected.\"\"\" return self . _connected","title":"connected()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.control_breeze_device","text":"Use for sending the control packet to the Breeze device. Parameters: Name Type Description Default command SwitcherBreezeCommand use the aioswitcher.api.SwitcherBreezeCommand class. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 async def control_breeze_device ( self , command : SwitcherBreezeCommand , ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the Breeze device. Args: command: use the ``aioswitcher.api.SwitcherBreezeCommand`` class. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send Breeze command\" ) timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if not login_resp . successful : logger . error ( \"Failed to log into device id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . BREEZE_COMMAND_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . length , command . command , ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"control_breeze_device()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.control_device","text":"Use for sending the control packet to the device. Parameters: Name Type Description Default command Command use the aioswitcher.api.Command enum. required minutes int if turning-on optionally incorporate a timer. 0 Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 async def control_device ( self , command : Command , minutes : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for sending the control packet to the device. Args: command: use the ``aioswitcher.api.Command`` enum. minutes: if turning-on optionally incorporate a timer. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () timer = ( minutes_to_hexadecimal_seconds ( minutes ) if minutes > 0 else packets . NO_TIMER_REQUESTED ) packet = packets . SEND_CONTROL_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , command . value , timer , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"control_device()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.create_schedule","text":"Use for creating a new schedule in the next empty schedule slot. Parameters: Name Type Description Default start_time str a string start time in %H:%M format. e.g. 13:00. required end_time str a string start time in %H:%M format. e.g. 13:00. required days Set [ Days ] for recurring schedules, add Days . set() Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 async def create_schedule ( self , start_time : str , end_time : str , days : Set [ Days ] = set () ) -> SwitcherBaseResponse : \"\"\"Use for creating a new schedule in the next empty schedule slot. Args: start_time: a string start time in %H:%M format. e.g. 13:00. end_time: a string start time in %H:%M format. e.g. 13:00. days: for recurring schedules, add ``Days``. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () start_time_hex = time_to_hexadecimal_timestamp ( start_time ) end_time_hex = time_to_hexadecimal_timestamp ( end_time ) weekdays = ( weekdays_to_hexadecimal ( days ) if len ( days ) > 0 else packets . NON_RECURRING_SCHEDULE ) new_schedule = packets . SCHEDULE_CREATE_DATA_FORMAT . format ( weekdays , start_time_hex , end_time_hex ) packet = packets . CREATE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , new_schedule , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a create schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"create_schedule()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.delete_schedule","text":"Use for deleting a schedule from the device. Use get_schedules to retrieve the schedule instance. Parameters: Name Type Description Default schedule_id str the identification of the schedule for deletion. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 async def delete_schedule ( self , schedule_id : str ) -> SwitcherBaseResponse : \"\"\"Use for deleting a schedule from the device. Use ``get_schedules`` to retrieve the schedule instance. Args: schedule_id: the identification of the schedule for deletion. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . DELETE_SCHEDULE_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , schedule_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a delete schedule packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"delete_schedule()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.disconnect","text":"Disconnect from asynchronous socket. Source code in src/aioswitcher/api/__init__.py 158 159 160 161 162 163 164 165 166 async def disconnect ( self ) -> None : \"\"\"Disconnect from asynchronous socket.\"\"\" if hasattr ( self , \"_writer\" ) and self . _writer : logger . info ( \"disconnecting from the switcher device\" ) self . _writer . close () await self . _writer . wait_closed () else : logger . info ( \"switcher device not connected\" ) self . _connected = False","title":"disconnect()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.get_breeze_state","text":"Use for sending the get state packet to the Breeze device. Returns: Type Description SwitcherThermostatStateResponse An instance of SwitcherThermostatStateResponse . Source code in src/aioswitcher/api/__init__.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 async def get_breeze_state ( self ) -> SwitcherThermostatStateResponse : \"\"\"Use for sending the get state packet to the Breeze device. Returns: An instance of ``SwitcherThermostatStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . BREEZE ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherThermostatStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get breeze state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" )","title":"get_breeze_state()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.get_schedules","text":"Use for retrieval of the schedules from the device. Returns: Type Description SwitcherGetSchedulesResponse An instance of SwitcherGetSchedulesResponse . Source code in src/aioswitcher/api/__init__.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 async def get_schedules ( self ) -> SwitcherGetSchedulesResponse : \"\"\"Use for retrieval of the schedules from the device. Returns: An instance of ``SwitcherGetSchedulesResponse``. \"\"\" timestamp , login_resp = await self . _login () packet = packets . GET_SCHEDULES_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get schedules packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherGetSchedulesResponse ( response )","title":"get_schedules()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.get_shutter_state","text":"Use for sending the get state packet to the Runner device. Returns: Type Description SwitcherShutterStateResponse An instance of SwitcherShutterStateResponse . Source code in src/aioswitcher/api/__init__.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 async def get_shutter_state ( self ) -> SwitcherShutterStateResponse : \"\"\"Use for sending the get state packet to the Runner device. Returns: An instance of ``SwitcherShutterStateResponse``. \"\"\" timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if login_resp . successful : packet = packets . GET_STATE_PACKET2_TYPE2 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherShutterStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get shutter state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" )","title":"get_shutter_state()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.get_state","text":"Use for sending the get state packet to the device. Returns: Type Description SwitcherStateResponse An instance of SwitcherStateResponse . Source code in src/aioswitcher/api/__init__.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 async def get_state ( self ) -> SwitcherStateResponse : \"\"\"Use for sending the get state packet to the device. Returns: An instance of ``SwitcherStateResponse``. \"\"\" timestamp , login_resp = await self . _login () if login_resp . successful : packet = packets . GET_STATE_PACKET_TYPE1 . format ( login_resp . session_id , timestamp , self . _device_id ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a get state packet\" ) self . _writer . write ( unhexlify ( signed_packet )) state_resp = await self . _reader . read ( 1024 ) try : response = SwitcherStateResponse ( state_resp ) if response . successful : return response except ( KeyError , ValueError ) as ve : raise RuntimeError ( \"get state request was not successful\" ) from ve raise RuntimeError ( \"login request was not successful\" )","title":"get_state()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.set_auto_shutdown","text":"Use for sending the set auto-off packet to the device. Parameters: Name Type Description Default full_time timedelta timedelta value containing the configuration value for auto-shutdown. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 async def set_auto_shutdown ( self , full_time : timedelta ) -> SwitcherBaseResponse : \"\"\"Use for sending the set auto-off packet to the device. Args: full_time: timedelta value containing the configuration value for auto-shutdown. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () auto_shutdown = timedelta_to_hexadecimal_seconds ( full_time ) packet = packets . SET_AUTO_OFF_SET_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , auto_shutdown , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set auto shutdown packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"set_auto_shutdown()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.set_device_name","text":"Use for sending the set name packet to the device. Parameters: Name Type Description Default name str string name with the length of 2 >= x >= 32. required Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 async def set_device_name ( self , name : str ) -> SwitcherBaseResponse : \"\"\"Use for sending the set name packet to the device. Args: name: string name with the length of 2 >= x >= 32. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" timestamp , login_resp = await self . _login () device_name = string_to_hexadecimale_device_name ( name ) packet = packets . UPDATE_DEVICE_NAME_PACKET . format ( login_resp . session_id , timestamp , self . _device_id , device_name , ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a set name packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"set_device_name()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.set_position","text":"Use for setting the shutter position of the Runner and Runner Mini devices. Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 async def set_position ( self , position : int = 0 ) -> SwitcherBaseResponse : \"\"\"Use for setting the shutter position of the Runner and Runner Mini devices. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" hex_pos = \"{0:0 {1} x}\" . format ( position , 2 ) logger . debug ( \"about to send set position command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_SET_POSITION . format ( login_resp . session_id , timestamp , self . _device_id , hex_pos ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"set_position()"},{"location":"codedocs/#src.aioswitcher.api.SwitcherApi.stop","text":"Use for stopping the shutter. Returns: Type Description SwitcherBaseResponse An instance of SwitcherBaseResponse . Source code in src/aioswitcher/api/__init__.py 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 async def stop ( self ) -> SwitcherBaseResponse : \"\"\"Use for stopping the shutter. Returns: An instance of ``SwitcherBaseResponse``. \"\"\" logger . debug ( \"about to send stop shutter command\" ) timestamp , login_resp = await self . _login ( DeviceType . RUNNER ) if not login_resp . successful : logger . error ( \"Failed to log into device with id %s \" , self . _device_id ) raise RuntimeError ( \"login request was not successful\" ) logger . debug ( \"logged in session_id= %s , timestamp= %s \" , login_resp . session_id , timestamp ) packet = packets . RUNNER_STOP_COMMAND . format ( login_resp . session_id , timestamp , self . _device_id ) packet = set_message_length ( packet ) signed_packet = sign_packet_with_crc_key ( packet ) logger . debug ( \"sending a stop control packet\" ) self . _writer . write ( unhexlify ( signed_packet )) response = await self . _reader . read ( 1024 ) return SwitcherBaseResponse ( response )","title":"stop()"},{"location":"codedocs/#aioswitcherapimessages","text":"","title":"aioswitcher.api.messages"},{"location":"codedocs/#switcherbaseresponse","text":"Representation of the switcher base response message. Applicable for all messages that do no require post initialization. e.g. not applicable for SwitcherLoginResponse, SwitcherStateResponse, SwitcherGetScheduleResponse. Parameters: Name Type Description Default unparsed_response bytes the raw response from the device. required Source code in src/aioswitcher/api/messages.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 @dataclass class SwitcherBaseResponse : \"\"\"Representation of the switcher base response message. Applicable for all messages that do no require post initialization. e.g. not applicable for SwitcherLoginResponse, SwitcherStateResponse, SwitcherGetScheduleResponse. Args: unparsed_response: the raw response from the device. \"\"\" unparsed_response : bytes @property def successful ( self ) -> bool : \"\"\"Return true if the response is not empty. Partially indicating the request was successful. \"\"\" return self . unparsed_response is not None and len ( self . unparsed_response ) > 0","title":"SwitcherBaseResponse"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherBaseResponse.successful","text":"Return true if the response is not empty. Partially indicating the request was successful. Source code in src/aioswitcher/api/messages.py 160 161 162 163 164 165 166 @property def successful ( self ) -> bool : \"\"\"Return true if the response is not empty. Partially indicating the request was successful. \"\"\" return self . unparsed_response is not None and len ( self . unparsed_response ) > 0","title":"successful()"},{"location":"codedocs/#switcherloginresponse","text":"Bases: SwitcherBaseResponse Representations of the switcher login response message. Source code in src/aioswitcher/api/messages.py 169 170 171 172 173 174 175 176 177 178 179 180 181 @final @dataclass class SwitcherLoginResponse ( SwitcherBaseResponse ): \"\"\"Representations of the switcher login response message.\"\"\" session_id : str = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization of the response.\"\"\" try : self . session_id = hexlify ( self . unparsed_response )[ 16 : 24 ] . decode () except Exception as exc : raise ValueError ( \"failed to parse login response message\" ) from exc","title":"SwitcherLoginResponse"},{"location":"codedocs/#switcherstateresponse","text":"Bases: SwitcherBaseResponse Representation of the switcher state response message. Source code in src/aioswitcher/api/messages.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 @final @dataclass class SwitcherStateResponse ( SwitcherBaseResponse ): \"\"\"Representation of the switcher state response message.\"\"\" state : DeviceState = field ( init = False ) time_left : str = field ( init = False ) time_on : str = field ( init = False ) auto_shutdown : str = field ( init = False ) power_consumption : int = field ( init = False ) electric_current : float = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization of the message.\"\"\" parser = StateMessageParser ( self . unparsed_response ) self . state = parser . get_state () self . time_left = parser . get_time_left () self . time_on = parser . get_time_on () self . auto_shutdown = parser . get_auto_shutdown () self . power_consumption = parser . get_power_consumption () self . electric_current = watts_to_amps ( self . power_consumption )","title":"SwitcherStateResponse"},{"location":"codedocs/#switchergetschedulesresponse","text":"Bases: SwitcherBaseResponse Representation of the switcher get schedule message. Source code in src/aioswitcher/api/messages.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 @final @dataclass class SwitcherGetSchedulesResponse ( SwitcherBaseResponse ): \"\"\"Representation of the switcher get schedule message.\"\"\" schedules : Set [ SwitcherSchedule ] = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization of the message.\"\"\" self . schedules = get_schedules ( self . unparsed_response ) @property def found_schedules ( self ) -> bool : \"\"\"Return true if found schedules in the response.\"\"\" return len ( self . schedules ) > 0","title":"SwitcherGetSchedulesResponse"},{"location":"codedocs/#src.aioswitcher.api.messages.SwitcherGetSchedulesResponse.found_schedules","text":"Return true if found schedules in the response. Source code in src/aioswitcher/api/messages.py 219 220 221 222 @property def found_schedules ( self ) -> bool : \"\"\"Return true if found schedules in the response.\"\"\" return len ( self . schedules ) > 0","title":"found_schedules()"},{"location":"codedocs/#aioswitcherbridge","text":"","title":"aioswitcher.bridge"},{"location":"codedocs/#switcherbridge","text":"Use for running a UDP client for bridging Switcher devices broadcast messages. Parameters: Name Type Description Default on_device Callable [[ SwitcherBase ], Any ] a callable to which every new SwitcherBase device found will be send. required broadcast_ports list [ int ] broadcast ports list, default for type 1 devices is 20002, default for type 2 devices is 20003 [SWITCHER_UDP_PORT_TYPE1, SWITCHER_UDP_PORT_TYPE2] Source code in src/aioswitcher/bridge.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @final class SwitcherBridge : \"\"\"Use for running a UDP client for bridging Switcher devices broadcast messages. Args: on_device: a callable to which every new SwitcherBase device found will be send. broadcast_ports: broadcast ports list, default for type 1 devices is 20002, default for type 2 devices is 20003 \"\"\" def __init__ ( self , on_device : Callable [[ SwitcherBase ], Any ], broadcast_ports : list [ int ] = [ SWITCHER_UDP_PORT_TYPE1 , SWITCHER_UDP_PORT_TYPE2 ], ) -> None : \"\"\"Initialize the switcher bridge.\"\"\" self . _on_device = on_device self . _broadcast_ports = broadcast_ports self . _is_running = False self . _transports = {} # type: Dict[int, Optional[BaseTransport]] async def __aenter__ ( self ) -> \"SwitcherBridge\" : \"\"\"Enter SwitcherBridge asynchronous context manager.\"\"\" await self . start () return self async def __aexit__ ( self , exc_type : Optional [ Type [ BaseException ]], exc_value : Optional [ BaseException ], traceback : Optional [ TracebackType ], ) -> None : \"\"\"Exit the SwitcherBridge asynchronous context manager.\"\"\" await self . stop () async def start ( self ) -> None : \"\"\"Create an asynchronous listener and start the bridge.\"\"\" for broadcast_port in self . _broadcast_ports : logger . info ( \"starting the udp bridge on port %s \" , broadcast_port ) protocol_factory = UdpClientProtocol ( partial ( _parse_device_from_datagram , self . _on_device ) ) transport , protocol = await get_running_loop () . create_datagram_endpoint ( lambda : protocol_factory , local_addr = ( \"0.0.0.0\" , broadcast_port ), # nosec family = AF_INET , ) self . _transports [ broadcast_port ] = transport logger . debug ( \"udp bridge on port %s started\" , broadcast_port ) self . _is_running = True async def stop ( self ) -> None : \"\"\"Stop the asynchronous bridge.\"\"\" for broadcast_port in self . _broadcast_ports : transport = self . _transports . get ( broadcast_port ) if transport and not transport . is_closing (): logger . info ( \"stopping the udp bridge on port %s \" , broadcast_port ) transport . close () else : logger . info ( \"udp bridge on port %s not started\" , broadcast_port ) self . _is_running = False @property def is_running ( self ) -> bool : \"\"\"bool: Return true if bridge is running.\"\"\" return self . _is_running","title":"SwitcherBridge"},{"location":"codedocs/#src.aioswitcher.bridge.SwitcherBridge.is_running","text":"bool: Return true if bridge is running. Source code in src/aioswitcher/bridge.py 228 229 230 231 @property def is_running ( self ) -> bool : \"\"\"bool: Return true if bridge is running.\"\"\" return self . _is_running","title":"is_running()"},{"location":"codedocs/#src.aioswitcher.bridge.SwitcherBridge.start","text":"Create an asynchronous listener and start the bridge. Source code in src/aioswitcher/bridge.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 async def start ( self ) -> None : \"\"\"Create an asynchronous listener and start the bridge.\"\"\" for broadcast_port in self . _broadcast_ports : logger . info ( \"starting the udp bridge on port %s \" , broadcast_port ) protocol_factory = UdpClientProtocol ( partial ( _parse_device_from_datagram , self . _on_device ) ) transport , protocol = await get_running_loop () . create_datagram_endpoint ( lambda : protocol_factory , local_addr = ( \"0.0.0.0\" , broadcast_port ), # nosec family = AF_INET , ) self . _transports [ broadcast_port ] = transport logger . debug ( \"udp bridge on port %s started\" , broadcast_port ) self . _is_running = True","title":"start()"},{"location":"codedocs/#src.aioswitcher.bridge.SwitcherBridge.stop","text":"Stop the asynchronous bridge. Source code in src/aioswitcher/bridge.py 215 216 217 218 219 220 221 222 223 224 225 226 async def stop ( self ) -> None : \"\"\"Stop the asynchronous bridge.\"\"\" for broadcast_port in self . _broadcast_ports : transport = self . _transports . get ( broadcast_port ) if transport and not transport . is_closing (): logger . info ( \"stopping the udp bridge on port %s \" , broadcast_port ) transport . close () else : logger . info ( \"udp bridge on port %s not started\" , broadcast_port ) self . _is_running = False","title":"stop()"},{"location":"codedocs/#aioswitcherdevice","text":"","title":"aioswitcher.device"},{"location":"codedocs/#devicecategory","text":"Bases: Enum Enum for relaying the device category. Source code in src/aioswitcher/device/__init__.py 24 25 26 27 28 29 30 31 @unique class DeviceCategory ( Enum ): \"\"\"Enum for relaying the device category.\"\"\" WATER_HEATER = auto () POWER_PLUG = auto () THERMOSTAT = auto () SHUTTER = auto ()","title":"DeviceCategory"},{"location":"codedocs/#devicetype","text":"Bases: Enum Enum for relaying the type of the switcher devices. Source code in src/aioswitcher/device/__init__.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @unique class DeviceType ( Enum ): \"\"\"Enum for relaying the type of the switcher devices.\"\"\" MINI = \"Switcher Mini\" , \"030f\" , 1 , DeviceCategory . WATER_HEATER POWER_PLUG = \"Switcher Power Plug\" , \"01a8\" , 1 , DeviceCategory . POWER_PLUG TOUCH = \"Switcher Touch\" , \"030b\" , 1 , DeviceCategory . WATER_HEATER V2_ESP = \"Switcher V2 (esp)\" , \"01a7\" , 1 , DeviceCategory . WATER_HEATER V2_QCA = \"Switcher V2 (qualcomm)\" , \"01a1\" , 1 , DeviceCategory . WATER_HEATER V4 = \"Switcher V4\" , \"0317\" , 1 , DeviceCategory . WATER_HEATER BREEZE = \"Switcher Breeze\" , \"0e01\" , 2 , DeviceCategory . THERMOSTAT RUNNER = \"Switcher Runner\" , \"0c01\" , 2 , DeviceCategory . SHUTTER RUNNER_MINI = \"Switcher Runner Mini\" , \"0c02\" , 2 , DeviceCategory . SHUTTER def __new__ ( cls , value : str , hex_rep : str , protocol_type : int , category : DeviceCategory ) -> \"DeviceType\" : \"\"\"Override the default enum constructor and include extra properties.\"\"\" new_enum = object . __new__ ( cls ) new_enum . _value = value # type: ignore new_enum . _hex_rep = hex_rep # type: ignore new_enum . _protocol_type = protocol_type # type: ignore new_enum . _category = category # type: ignore return new_enum @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore @property def hex_rep ( self ) -> str : \"\"\"Return the hexadecimal representation of the device type.\"\"\" return self . _hex_rep # type: ignore @property def protocol_type ( self ) -> int : \"\"\"Return the protocol type of the device.\"\"\" return self . _protocol_type # type: ignore @property def category ( self ) -> DeviceCategory : \"\"\"Return the category of the device type.\"\"\" return self . _category # type: ignore","title":"DeviceType"},{"location":"codedocs/#src.aioswitcher.device.DeviceType.category","text":"Return the category of the device type. Source code in src/aioswitcher/device/__init__.py 74 75 76 77 @property def category ( self ) -> DeviceCategory : \"\"\"Return the category of the device type.\"\"\" return self . _category # type: ignore","title":"category()"},{"location":"codedocs/#src.aioswitcher.device.DeviceType.hex_rep","text":"Return the hexadecimal representation of the device type. Source code in src/aioswitcher/device/__init__.py 64 65 66 67 @property def hex_rep ( self ) -> str : \"\"\"Return the hexadecimal representation of the device type.\"\"\" return self . _hex_rep # type: ignore","title":"hex_rep()"},{"location":"codedocs/#src.aioswitcher.device.DeviceType.protocol_type","text":"Return the protocol type of the device. Source code in src/aioswitcher/device/__init__.py 69 70 71 72 @property def protocol_type ( self ) -> int : \"\"\"Return the protocol type of the device.\"\"\" return self . _protocol_type # type: ignore","title":"protocol_type()"},{"location":"codedocs/#src.aioswitcher.device.DeviceType.value","text":"Return the value of the state. Source code in src/aioswitcher/device/__init__.py 59 60 61 62 @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore","title":"value()"},{"location":"codedocs/#devicestate","text":"Bases: Enum Enum class representing the device's state. Source code in src/aioswitcher/device/__init__.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @unique class DeviceState ( Enum ): \"\"\"Enum class representing the device's state.\"\"\" ON = \"01\" , \"on\" OFF = \"00\" , \"off\" def __new__ ( cls , value : str , display : str ) -> \"DeviceState\" : \"\"\"Override the default enum constructor and include extra properties.\"\"\" new_enum = object . __new__ ( cls ) new_enum . _value = value # type: ignore new_enum . _display = display # type: ignore return new_enum @property def display ( self ) -> str : \"\"\"Return the display name of the state.\"\"\" return self . _display # type: ignore @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore","title":"DeviceState"},{"location":"codedocs/#src.aioswitcher.device.DeviceState.display","text":"Return the display name of the state. Source code in src/aioswitcher/device/__init__.py 94 95 96 97 @property def display ( self ) -> str : \"\"\"Return the display name of the state.\"\"\" return self . _display # type: ignore","title":"display()"},{"location":"codedocs/#src.aioswitcher.device.DeviceState.value","text":"Return the value of the state. Source code in src/aioswitcher/device/__init__.py 99 100 101 102 @property def value ( self ) -> str : \"\"\"Return the value of the state.\"\"\" return self . _value # type: ignore","title":"value()"},{"location":"codedocs/#switcherpowerplug","text":"Bases: SwitcherPowerBase , SwitcherBase Implementation of the Switcher Power Plug device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. Source code in src/aioswitcher/device/__init__.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 @final @dataclass class SwitcherPowerPlug ( SwitcherPowerBase , SwitcherBase ): \"\"\"Implementation of the Switcher Power Plug device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. \"\"\" def __post_init__ ( self ) -> None : \"\"\"Post initialization validate device type category as POWER_PLUG.\"\"\" if self . device_type . category != DeviceCategory . POWER_PLUG : raise ValueError ( \"only power plugs are allowed\" ) super () . __post_init__ ()","title":"SwitcherPowerPlug"},{"location":"codedocs/#switcherwaterheater","text":"Bases: SwitcherTimedBase , SwitcherPowerBase , SwitcherBase Implementation of the Switcher Water Heater device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. Source code in src/aioswitcher/device/__init__.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 @final @dataclass class SwitcherWaterHeater ( SwitcherTimedBase , SwitcherPowerBase , SwitcherBase ): \"\"\"Implementation of the Switcher Water Heater device. Please Note the order of the inherited classes to understand the order of the instantiation parameters and the super call. \"\"\" def __post_init__ ( self ) -> None : \"\"\"Post initialization validate device type category as WATER_HEATER.\"\"\" if self . device_type . category != DeviceCategory . WATER_HEATER : raise ValueError ( \"only water heaters are allowed\" ) super () . __post_init__ ()","title":"SwitcherWaterHeater"},{"location":"codedocs/#aioswitcherschedule","text":"Bases: Enum Enum class representing the day entity. Source code in src/aioswitcher/schedule/__init__.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @unique class Days ( Enum ): \"\"\"Enum class representing the day entity.\"\"\" MONDAY = ( \"Monday\" , 0x02 , 2 , 0 ) TUESDAY = ( \"Tuesday\" , 0x04 , 4 , 1 ) WEDNESDAY = ( \"Wednesday\" , 0x08 , 8 , 2 ) THURSDAY = ( \"Thursday\" , 0x10 , 16 , 3 ) FRIDAY = ( \"Friday\" , 0x20 , 32 , 4 ) SATURDAY = ( \"Saturday\" , 0x40 , 64 , 5 ) SUNDAY = ( \"Sunday\" , 0x80 , 128 , 6 ) def __new__ ( cls , value : str , hex_rep : int , bit_rep : int , weekday : int ) -> \"Days\" : \"\"\"Override the default enum constructor and include extra properties.\"\"\" new_enum = object . __new__ ( cls ) new_enum . _value_ = value new_enum . _hex_rep = hex_rep # type: ignore new_enum . _bit_rep = bit_rep # type: ignore new_enum . _weekday = weekday # type: ignore return new_enum @property def bit_rep ( self ) -> int : \"\"\"Return the bit representation of the day.\"\"\" return self . _bit_rep # type: ignore @property def hex_rep ( self ) -> int : \"\"\"Return the hexadecimal representation of the day.\"\"\" return self . _hex_rep # type: ignore @property def weekday ( self ) -> int : \"\"\"Return the weekday of the day.\"\"\" return self . _weekday # type: ignore","title":"aioswitcher.schedule"},{"location":"codedocs/#src.aioswitcher.schedule.Days.bit_rep","text":"Return the bit representation of the day. Source code in src/aioswitcher/schedule/__init__.py 49 50 51 52 @property def bit_rep ( self ) -> int : \"\"\"Return the bit representation of the day.\"\"\" return self . _bit_rep # type: ignore","title":"bit_rep()"},{"location":"codedocs/#src.aioswitcher.schedule.Days.hex_rep","text":"Return the hexadecimal representation of the day. Source code in src/aioswitcher/schedule/__init__.py 54 55 56 57 @property def hex_rep ( self ) -> int : \"\"\"Return the hexadecimal representation of the day.\"\"\" return self . _hex_rep # type: ignore","title":"hex_rep()"},{"location":"codedocs/#src.aioswitcher.schedule.Days.weekday","text":"Return the weekday of the day. Source code in src/aioswitcher/schedule/__init__.py 59 60 61 62 @property def weekday ( self ) -> int : \"\"\"Return the weekday of the day.\"\"\" return self . _weekday # type: ignore representation of the Switcher schedule slot. Parameters: Name Type Description Default schedule_id str the id of the schedule required recurring bool is a recurring schedule required days Set [ Days ] a set of schedule days, or empty set for non recurring schedules required start_time str the start time of the schedule required end_time str the end time of the schedule required Source code in src/aioswitcher/schedule/parser.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @final @dataclass class SwitcherSchedule : \"\"\"representation of the Switcher schedule slot. Args: schedule_id: the id of the schedule recurring: is a recurring schedule days: a set of schedule days, or empty set for non recurring schedules start_time: the start time of the schedule end_time: the end time of the schedule \"\"\" schedule_id : str recurring : bool days : Set [ Days ] start_time : str end_time : str duration : str = field ( init = False ) display : str = field ( init = False ) def __post_init__ ( self ) -> None : \"\"\"Post initialization, set duration and display.\"\"\" self . duration = tools . calc_duration ( self . start_time , self . end_time ) self . display = tools . pretty_next_run ( self . start_time , self . days ) def __hash__ ( self ) -> int : \"\"\"For usage with set, implementation of the __hash__ magic method.\"\"\" return hash ( self . schedule_id ) def __eq__ ( self , obj : object ) -> bool : \"\"\"For usage with set, implementation of the __eq__ magic method.\"\"\" if isinstance ( obj , SwitcherSchedule ): return self . schedule_id == obj . schedule_id return False","title":"weekday()"},{"location":"install/","text":"Install \u2693\ufe0e pip install aioswitcher","title":"Install"},{"location":"install/#install","text":"pip install aioswitcher","title":"Install"},{"location":"scripts/","text":"Command line scripts \u2693\ufe0e Discover Devices \u2693\ufe0e scripts/discover_devices.py \u2693\ufe0e usage: discover_devices.py [ -h ] [ delay ] Discover and print info of Switcher devices positional arguments: delay number of seconds to run, defaults to 60 options: -h, --help show this help message and exit script/control_device.py \u2693\ufe0e usage: control_device.py [ -h ] [ -v ] -d DEVICE_ID -i IP_ADDRESS { get_state,turn_on,turn_off,set_name,set_auto_shutdown,get_schedules,delete_schedule, create_schedule,stop_shutter,set_shutter_position,control_thermostat } ... Control your Switcher device options: -h, --help show this help message and exit -v, --verbose include the raw message -d DEVICE_ID, --device-id DEVICE_ID the identification of the device -i IP_ADDRESS, --ip-address IP_ADDRESS the ip address assigned to the device subcommands: supported actions { get_state,turn_on,turn_off,set_name,set_auto_shutdown,get_schedules,delete_schedule,create_schedule,stop_shutter, set_shutter_position,control_thermostat } get_state get the current state of a device turn_on turn on the device turn_off turn off the device set_name set the name of the device set_auto_shutdown set the auto shutdown property ( 1h-24h ) get_schedules retrive a device schedules delete_schedule delete a device schedule create_schedule create a new schedule stop_shutter stop shutter set_shutter_position set shutter position control_thermostat create a new schedule example usage: python control_device.py -d ab1c2d -i \"111.222.11.22\" get_state python control_device.py -d ab1c2d -i \"111.222.11.22\" turn_on python control_device.py -d ab1c2d -i \"111.222.11.22\" turn_on -t 15 python control_device.py -d ab1c2d -i \"111.222.11.22\" turn_off python control_device.py -d ab1c2d -i \"111.222.11.22\" set_name -n \"My Boiler\" python control_device.py -d ab1c2d -i \"111.222.11.22\" set_auto_shutdown -r 2 -m 30 python control_device.py -d ab1c2d -i \"111.222.11.22\" get_schedules python control_device.py -d ab1c2d -i \"111.222.11.22\" delete_schedule -s 3 python control_device.py -d ab1c2d -i \"111.222.11.22\" create_schedule -n \"14:00\" -f \"14:30\" python control_device.py -d ab1c2d -i \"111.222.11.22\" create_schedule -n \"17:30\" -f \"18:30\" -w Sunday Monday Friday python control_device.py -d f2239a -i \"192.168.50.98\" stop_shutter python control_device.py -d f2239a -i \"192.168.50.98\" set_shutter_position -p 50 python control_device.py -d 3a20b7 -i \"192.168.50.77\" control_thermostat -m dry python control_device.py -d 3a20b7 -i \"192.168.50.77\" control_thermostat -s off script/control_device.py create_schedule \u2693\ufe0e usage: control_device.py create_schedule [ -h ] -n START_TIME -f END_TIME [ -w [{ Monday,Tuesday,Wednesday,Thursday,Friday, Saturday,Sunday } ... ]] options: -h, --help show this help message and exit -n START_TIME, --start-time START_TIME the on time for the schedule, e.g. 13 :00 -f END_TIME, --end-time END_TIME the off time for the schedule, e.g. 13 :30 -w [{ Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday } ... ] , --weekdays [{ Monday,Tuesday,Wednesday,Thursday, Friday,Saturday,Sunday } ... ] days for recurring schedules, possible values: [ 'Monday' , 'Tuesday' , 'Wednesday' , 'Thursday' , 'Friday' , 'Saturday' , 'Sunday' ] script/control_device.py delete_schedule \u2693\ufe0e usage: control_device.py delete_schedule [ -h ] -s SCHEDULE_ID options: -h, --help show this help message and exit -s SCHEDULE_ID, --schedule-id SCHEDULE_ID the id of the schedule for deletion script/control_device.py get_schedules \u2693\ufe0e usage: control_device.py get_schedules [ -h ] options: -h, --help show this help message and exit script/control_device.py get_state \u2693\ufe0e usage: control_device.py get_state [ -h ] options: -h, --help show this help message and exit script/control_device.py set_auto_shutdown \u2693\ufe0e usage: control_device.py set_auto_shutdown [ -h ] -r HOURS [ -m [ MINUTES ]] options: -h, --help show this help message and exit -r HOURS, --hours HOURS number hours for the auto shutdown -m [ MINUTES ] , --minutes [ MINUTES ] number hours for the auto shutdown script/control_device.py set_name \u2693\ufe0e usage: control_device.py set_name [ -h ] -n NAME options: -h, --help show this help message and exit -n NAME, --name NAME new name for the device script/control_device.py turn_off \u2693\ufe0e usage: control_device.py turn_off [ -h ] options: -h, --help show this help message and exit script/control_device.py turn_on \u2693\ufe0e usage: control_device.py turn_on [ -h ] [ -t [ TIMER ]] options: -h, --help show this help message and exit -t [ TIMER ] , --timer [ TIMER ] set minutes timer for turn on operation script/control_device.py set_shutter_position \u2693\ufe0e usage: control_device.py set_shutter_position [ -h ] -p POSITION options: -h, --help show this help message and exit -p POSITION, --position POSITION Shutter position percentage script/control_device.py stop_shutter \u2693\ufe0e usage: control_device.py stop_shutter [ -h ] options: -h, --help show this help message and exit script/control_device.py control_thermostat \u2693\ufe0e usage: control_device.py control_thermostat [ -h ] [ -s { on,off }] [ -m { auto,dry,fan,cool,heat }] [ -f { low,medium,high,auto }] [ -w { off,on }] [ -t TEMPERATURE ] options: -h, --help show this help message and exit -s { on,off } , --state { on,off } thermostat state, possible values -m { auto,dry,fan,cool,heat } , --mode { auto,dry,fan,cool,heat } thermostat mode -f { low,medium,high,auto } , --fan-level { low,medium,high,auto } thermostat fan level -w { off,on } , --swing { off,on } thermostat swing -t TEMPERATURE, --temperature TEMPERATURE thermostat temperature","title":"Command line scripts"},{"location":"scripts/#command-line-scripts","text":"","title":"Command line scripts"},{"location":"scripts/#discover-devices","text":"","title":"Discover Devices"},{"location":"scripts/#scriptsdiscover_devicespy","text":"usage: discover_devices.py [ -h ] [ delay ] Discover and print info of Switcher devices positional arguments: delay number of seconds to run, defaults to 60 options: -h, --help show this help message and exit","title":"scripts/discover_devices.py"},{"location":"scripts/#scriptcontrol_devicepy","text":"usage: control_device.py [ -h ] [ -v ] -d DEVICE_ID -i IP_ADDRESS { get_state,turn_on,turn_off,set_name,set_auto_shutdown,get_schedules,delete_schedule, create_schedule,stop_shutter,set_shutter_position,control_thermostat } ... Control your Switcher device options: -h, --help show this help message and exit -v, --verbose include the raw message -d DEVICE_ID, --device-id DEVICE_ID the identification of the device -i IP_ADDRESS, --ip-address IP_ADDRESS the ip address assigned to the device subcommands: supported actions { get_state,turn_on,turn_off,set_name,set_auto_shutdown,get_schedules,delete_schedule,create_schedule,stop_shutter, set_shutter_position,control_thermostat } get_state get the current state of a device turn_on turn on the device turn_off turn off the device set_name set the name of the device set_auto_shutdown set the auto shutdown property ( 1h-24h ) get_schedules retrive a device schedules delete_schedule delete a device schedule create_schedule create a new schedule stop_shutter stop shutter set_shutter_position set shutter position control_thermostat create a new schedule example usage: python control_device.py -d ab1c2d -i \"111.222.11.22\" get_state python control_device.py -d ab1c2d -i \"111.222.11.22\" turn_on python control_device.py -d ab1c2d -i \"111.222.11.22\" turn_on -t 15 python control_device.py -d ab1c2d -i \"111.222.11.22\" turn_off python control_device.py -d ab1c2d -i \"111.222.11.22\" set_name -n \"My Boiler\" python control_device.py -d ab1c2d -i \"111.222.11.22\" set_auto_shutdown -r 2 -m 30 python control_device.py -d ab1c2d -i \"111.222.11.22\" get_schedules python control_device.py -d ab1c2d -i \"111.222.11.22\" delete_schedule -s 3 python control_device.py -d ab1c2d -i \"111.222.11.22\" create_schedule -n \"14:00\" -f \"14:30\" python control_device.py -d ab1c2d -i \"111.222.11.22\" create_schedule -n \"17:30\" -f \"18:30\" -w Sunday Monday Friday python control_device.py -d f2239a -i \"192.168.50.98\" stop_shutter python control_device.py -d f2239a -i \"192.168.50.98\" set_shutter_position -p 50 python control_device.py -d 3a20b7 -i \"192.168.50.77\" control_thermostat -m dry python control_device.py -d 3a20b7 -i \"192.168.50.77\" control_thermostat -s off","title":"script/control_device.py"},{"location":"scripts/#scriptcontrol_devicepy-create_schedule","text":"usage: control_device.py create_schedule [ -h ] -n START_TIME -f END_TIME [ -w [{ Monday,Tuesday,Wednesday,Thursday,Friday, Saturday,Sunday } ... ]] options: -h, --help show this help message and exit -n START_TIME, --start-time START_TIME the on time for the schedule, e.g. 13 :00 -f END_TIME, --end-time END_TIME the off time for the schedule, e.g. 13 :30 -w [{ Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday } ... ] , --weekdays [{ Monday,Tuesday,Wednesday,Thursday, Friday,Saturday,Sunday } ... ] days for recurring schedules, possible values: [ 'Monday' , 'Tuesday' , 'Wednesday' , 'Thursday' , 'Friday' , 'Saturday' , 'Sunday' ]","title":"script/control_device.py create_schedule"},{"location":"scripts/#scriptcontrol_devicepy-delete_schedule","text":"usage: control_device.py delete_schedule [ -h ] -s SCHEDULE_ID options: -h, --help show this help message and exit -s SCHEDULE_ID, --schedule-id SCHEDULE_ID the id of the schedule for deletion","title":"script/control_device.py delete_schedule"},{"location":"scripts/#scriptcontrol_devicepy-get_schedules","text":"usage: control_device.py get_schedules [ -h ] options: -h, --help show this help message and exit","title":"script/control_device.py get_schedules"},{"location":"scripts/#scriptcontrol_devicepy-get_state","text":"usage: control_device.py get_state [ -h ] options: -h, --help show this help message and exit","title":"script/control_device.py get_state"},{"location":"scripts/#scriptcontrol_devicepy-set_auto_shutdown","text":"usage: control_device.py set_auto_shutdown [ -h ] -r HOURS [ -m [ MINUTES ]] options: -h, --help show this help message and exit -r HOURS, --hours HOURS number hours for the auto shutdown -m [ MINUTES ] , --minutes [ MINUTES ] number hours for the auto shutdown","title":"script/control_device.py set_auto_shutdown"},{"location":"scripts/#scriptcontrol_devicepy-set_name","text":"usage: control_device.py set_name [ -h ] -n NAME options: -h, --help show this help message and exit -n NAME, --name NAME new name for the device","title":"script/control_device.py set_name"},{"location":"scripts/#scriptcontrol_devicepy-turn_off","text":"usage: control_device.py turn_off [ -h ] options: -h, --help show this help message and exit","title":"script/control_device.py turn_off"},{"location":"scripts/#scriptcontrol_devicepy-turn_on","text":"usage: control_device.py turn_on [ -h ] [ -t [ TIMER ]] options: -h, --help show this help message and exit -t [ TIMER ] , --timer [ TIMER ] set minutes timer for turn on operation","title":"script/control_device.py turn_on"},{"location":"scripts/#scriptcontrol_devicepy-set_shutter_position","text":"usage: control_device.py set_shutter_position [ -h ] -p POSITION options: -h, --help show this help message and exit -p POSITION, --position POSITION Shutter position percentage","title":"script/control_device.py set_shutter_position"},{"location":"scripts/#scriptcontrol_devicepy-stop_shutter","text":"usage: control_device.py stop_shutter [ -h ] options: -h, --help show this help message and exit","title":"script/control_device.py stop_shutter"},{"location":"scripts/#scriptcontrol_devicepy-control_thermostat","text":"usage: control_device.py control_thermostat [ -h ] [ -s { on,off }] [ -m { auto,dry,fan,cool,heat }] [ -f { low,medium,high,auto }] [ -w { off,on }] [ -t TEMPERATURE ] options: -h, --help show this help message and exit -s { on,off } , --state { on,off } thermostat state, possible values -m { auto,dry,fan,cool,heat } , --mode { auto,dry,fan,cool,heat } thermostat mode -f { low,medium,high,auto } , --fan-level { low,medium,high,auto } thermostat fan level -w { off,on } , --swing { off,on } thermostat swing -t TEMPERATURE, --temperature TEMPERATURE thermostat temperature","title":"script/control_device.py control_thermostat"},{"location":"usage/","text":"Usage \u2693\ufe0e Bridge \u2693\ufe0e We can use the Bridge implementation to discover devices and their state. The following code will print all discovered devices for 60 seconds. async def print_devices ( delay ): def on_device_found_callback ( device ): print ( asdict ( device )) async with SwitcherBridge ( on_device_found_callback ): await asyncio . sleep ( delay ) asyncio . get_event_loop () . run_until_complete ( print_devices ( 60 )) Note A Switcher device will broadcast every 4 seconds. Discovered devices can either be a Power Plug or a Power Plug API \u2693\ufe0e Type1 API (Switcher Plug, V2, Touch, V4) \u2693\ufe0e We can use the Type1 API to gain the following capabilities: Get the current state Turn on and off Set the name Configure auto shutdown Retrieve the schedules Create and Delete schedules async def control_device ( device_ip , device_id ) : # for connecting to a device we need its id and ip address async with SwitcherType1Api ( device_ip , device_id ) as api : # get the device current state await api . get_state () # turn the device on for 15 await api . control_device ( Command . ON , 15 ) # turn the device off await api . control_device ( Command . OFF ) # set the device name await api . set_device_name ( \"my new name\" ) # configure the device for 02:30 auto shutdown await api . set_auto_shutdown ( timedelta ( hours = 2 , minutes = 30 )) # get the schedules from the device await api . get_schedules () # delete and existing schedule with id 1 await api . delete_schedule ( \"1\" ) # create a new recurring schedule for 13:00-14:30 executing on sunday and friday await api . create_schedule ( \"13:00\" , \"14:30\" , { Days . SUNDAY , Days . FRIDAY }) asyncio . get_event_loop () . run_until_complete ( control_device ( \"111.222.11.22\" , \"ab1c2d\" )) Type2 API (Switcher Breeze and Runner) \u2693\ufe0e We can use the Type2 API to gain the following capabilities on Switcher Breeze and Runner: Get the current state Control Runner position Control Breeze (State, Mode, Fan Level, Target Temperature, Vertical Swing) async def control_runner_device ( device_ip , device_id ) : # for connecting to a device we need its id and ip address async with SwitcherType2Api ( device_ip , device_id ) as api : # get the device current state state : SwitcherShutterStateResponse = await api . get_shutter_state () # state.position (int) holds the current position of the shutter # state.direction (ShutterDirection) holds the current direction # open the shutter to 30% await api . set_position ( 30 ) # stop the shutter if currently rolling await api . stop () asyncio . get_event_loop () . run_until_complete ( control_runner_device ( \"192.168.50.98\" , \"f2239a\" )) async def control_breeze_device ( device_ip , device_id ) : # for connecting to a device we need its id and ip address async with SwitcherType2Api ( device_ip , device_id ) as api : # get the device current state response : SwitcherThermostatStateResponse = await api . get_breeze_state () # Control Breeze Device # initialize the Breeze RemoteManager rm = BreezeRemoteManager () # get the remote structure (downloaded from the internet) # alternatively, you can get supply local directory path to the BreezeRemoteManager # and the BreezeRemoteManager will save and cache downloaded remotes into the directory async with ClientSession () as session : remote : BreezeRemote = await rm . get_remote ( response . remote_id , api , session ) # prepare a control command that turns on the Breeze # (24 degree (Celsius), cooling with vertical swing and keep the current Fan Level) command : SwitcherBreezeCommand = remote . get_command ( DeviceState . ON , ThermostatMode . COOL , 24 , resp . fan_level , ThermostatSwing . ON , response . state ) # send command to the device await api . control_breeze_device ( command ) asyncio . get_event_loop () . run_until_complete ( control_breeze_device ( \"192.168.50.77\" , \"3a20b7\" )) Note All requests return a response, you can use the asdict __utility function to get familiarize with the various responses. You can visit the API response messages section and review the various response objects. Note that if a request doesn't have a specific response extending the base response, then the base response is the yielding response. Supported Devices \u2693\ufe0e Info You can find the supported device types stated as this enum members.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#bridge","text":"We can use the Bridge implementation to discover devices and their state. The following code will print all discovered devices for 60 seconds. async def print_devices ( delay ): def on_device_found_callback ( device ): print ( asdict ( device )) async with SwitcherBridge ( on_device_found_callback ): await asyncio . sleep ( delay ) asyncio . get_event_loop () . run_until_complete ( print_devices ( 60 )) Note A Switcher device will broadcast every 4 seconds. Discovered devices can either be a Power Plug or a Power Plug","title":"Bridge"},{"location":"usage/#api","text":"","title":"API"},{"location":"usage/#type1-api-switcher-plug-v2-touch-v4","text":"We can use the Type1 API to gain the following capabilities: Get the current state Turn on and off Set the name Configure auto shutdown Retrieve the schedules Create and Delete schedules async def control_device ( device_ip , device_id ) : # for connecting to a device we need its id and ip address async with SwitcherType1Api ( device_ip , device_id ) as api : # get the device current state await api . get_state () # turn the device on for 15 await api . control_device ( Command . ON , 15 ) # turn the device off await api . control_device ( Command . OFF ) # set the device name await api . set_device_name ( \"my new name\" ) # configure the device for 02:30 auto shutdown await api . set_auto_shutdown ( timedelta ( hours = 2 , minutes = 30 )) # get the schedules from the device await api . get_schedules () # delete and existing schedule with id 1 await api . delete_schedule ( \"1\" ) # create a new recurring schedule for 13:00-14:30 executing on sunday and friday await api . create_schedule ( \"13:00\" , \"14:30\" , { Days . SUNDAY , Days . FRIDAY }) asyncio . get_event_loop () . run_until_complete ( control_device ( \"111.222.11.22\" , \"ab1c2d\" ))","title":"Type1 API (Switcher Plug, V2, Touch, V4)"},{"location":"usage/#type2-api-switcher-breeze-and-runner","text":"We can use the Type2 API to gain the following capabilities on Switcher Breeze and Runner: Get the current state Control Runner position Control Breeze (State, Mode, Fan Level, Target Temperature, Vertical Swing) async def control_runner_device ( device_ip , device_id ) : # for connecting to a device we need its id and ip address async with SwitcherType2Api ( device_ip , device_id ) as api : # get the device current state state : SwitcherShutterStateResponse = await api . get_shutter_state () # state.position (int) holds the current position of the shutter # state.direction (ShutterDirection) holds the current direction # open the shutter to 30% await api . set_position ( 30 ) # stop the shutter if currently rolling await api . stop () asyncio . get_event_loop () . run_until_complete ( control_runner_device ( \"192.168.50.98\" , \"f2239a\" )) async def control_breeze_device ( device_ip , device_id ) : # for connecting to a device we need its id and ip address async with SwitcherType2Api ( device_ip , device_id ) as api : # get the device current state response : SwitcherThermostatStateResponse = await api . get_breeze_state () # Control Breeze Device # initialize the Breeze RemoteManager rm = BreezeRemoteManager () # get the remote structure (downloaded from the internet) # alternatively, you can get supply local directory path to the BreezeRemoteManager # and the BreezeRemoteManager will save and cache downloaded remotes into the directory async with ClientSession () as session : remote : BreezeRemote = await rm . get_remote ( response . remote_id , api , session ) # prepare a control command that turns on the Breeze # (24 degree (Celsius), cooling with vertical swing and keep the current Fan Level) command : SwitcherBreezeCommand = remote . get_command ( DeviceState . ON , ThermostatMode . COOL , 24 , resp . fan_level , ThermostatSwing . ON , response . state ) # send command to the device await api . control_breeze_device ( command ) asyncio . get_event_loop () . run_until_complete ( control_breeze_device ( \"192.168.50.77\" , \"3a20b7\" )) Note All requests return a response, you can use the asdict __utility function to get familiarize with the various responses. You can visit the API response messages section and review the various response objects. Note that if a request doesn't have a specific response extending the base response, then the base response is the yielding response.","title":"Type2 API (Switcher Breeze and Runner)"},{"location":"usage/#supported-devices","text":"Info You can find the supported device types stated as this enum members.","title":"Supported Devices"}]}